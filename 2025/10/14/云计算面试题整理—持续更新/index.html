<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>云计算面试题整理—持续更新 | Felix的个人博客</title><meta name="author" content="Felix"><meta name="copyright" content="Felix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.查看资源占用 题目： 1、当前系统很卡，cpu占用很高，我应该如何排查具体哪个进程占用资源最多  2、接上一题，如何定位这个进程的哪个子进程占用CPU资源更大。  3、接上一题，遇到以上问题，如何处理。 整理为故障文档 2.三握四挥 3.检查Linux版本号 4.配置yum本地仓库 5.LVM扩容 6.RAID和RAID创建 7.平时shell干什么 8.内网服务器下很慢 借其他电脑windo">
<meta property="og:type" content="article">
<meta property="og:title" content="云计算面试题整理—持续更新">
<meta property="og:url" content="http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html">
<meta property="og:site_name" content="Felix的个人博客">
<meta property="og:description" content="1.查看资源占用 题目： 1、当前系统很卡，cpu占用很高，我应该如何排查具体哪个进程占用资源最多  2、接上一题，如何定位这个进程的哪个子进程占用CPU资源更大。  3、接上一题，遇到以上问题，如何处理。 整理为故障文档 2.三握四挥 3.检查Linux版本号 4.配置yum本地仓库 5.LVM扩容 6.RAID和RAID创建 7.平时shell干什么 8.内网服务器下很慢 借其他电脑windo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/imgs/adater.jpg">
<meta property="article:published_time" content="2025-10-14T05:41:59.000Z">
<meta property="article:modified_time" content="2025-12-17T05:19:11.697Z">
<meta property="article:author" content="Felix">
<meta property="article:tag" content="学习过程中持续积累的面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/adater.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "云计算面试题整理—持续更新",
  "url": "http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/",
  "image": "http://example.com/imgs/adater.jpg",
  "datePublished": "2025-10-14T05:41:59.000Z",
  "dateModified": "2025-12-17T05:19:11.697Z",
  "author": [
    {
      "@type": "Person",
      "name": "Felix",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '云计算面试题整理—持续更新',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/imgs/background_header.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Felix的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">云计算面试题整理—持续更新</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">云计算面试题整理—持续更新</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-10-14T05:41:59.000Z" title="Created 2025-10-14 13:41:59">2025-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-12-17T05:19:11.697Z" title="Updated 2025-12-17 13:19:11">2025-12-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>1.查看资源占用</p>
<p>题目：</p>
<p>1、当前系统很卡，cpu占用很高，我应该如何排查具体哪个进程占用资源最多 </p>
<p>2、接上一题，如何定位这个进程的哪个子进程占用CPU资源更大。 </p>
<p>3、接上一题，遇到以上问题，如何处理。</p>
<p>整理为故障文档</p>
<p>2.三握四挥</p>
<p>3.检查Linux版本号</p>
<p>4.配置yum本地仓库</p>
<p>5.LVM扩容</p>
<p>6.RAID和RAID创建</p>
<p>7.平时shell干什么</p>
<p>8.内网服务器下很慢</p>
<p>借其他电脑windows下载，再传过去比如堡垒机</p>
<p>scp 文件 用户@IP：路径  （ssh copy）用法和cp一样</p>
<p>9.DNS: 主机A记录  域名解析为IP</p>
<p>​	主机P记录 反向解析记录，IP转换为域名</p>
<p>10.内存OOM怎么处理</p>
<p>OOM 是 Out Of Memory 的缩写，表示系统内存不足。当系统物理内存和虚拟内存（Swap）都不足时，会触发 OOM Killer 机制，强制杀死占用内存最多的进程来释放内存。</p>
<p>后果主要有：</p>
<ol>
<li>进程被强制杀死，导致服务中断</li>
<li>数据丢失，业务受损</li>
<li>系统不稳定，严重时会导致宕机</li>
</ol>
<p>诊断：</p>
<p><img src="/./imgs/image-20251103092337592.png" alt="image-20251103092337592"></p>
<p><img src="/./imgs/image-20251103092400284.png" alt="image-20251103092400284"></p>
<p>处理：</p>
<p><img src="/./imgs/image-20251103092556237.png" alt="image-20251103092556237"></p>
<p><img src="/./imgs/image-20251103092620631.png" alt="image-20251103092620631"></p>
<p>11.grep awk sed的处理逻辑是什么？</p>
<p>行处理grep：输出的是符合条件的文本内容的行”输出行”</p>
<p>列处理awk：匹配符合条件的列</p>
<p>修改sed：主要做修改&#x2F;或者打印指定条件的行</p>
<p>shell相关</p>
<p>12、提取日志中，访问次数最多的IP地址</p>
<p>查找access 访问日志中，来访最多的IP地址，统计次数并排序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk &#x27;&#123;print $1&#125;&#x27; | egrep -v &quot;^$&quot; | sort -n | uniq -c | sort -rk 1</span><br></pre></td></tr></table></figure>

<p>13、提取本机指定网卡的IP地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 | grep &quot;broadcast&quot; | awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>14、提取、计算内存&#x2F;cpu使用率(awk精确到$几，具体的命令)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存使用率</span></span><br><span class="line">mem_rate=$(free -m | grep &quot;Mem:&quot; | awk &#x27;&#123;print ($3/$2)*100&#125;&#x27;</span><br><span class="line">echo &quot;内存使用率为$&#123;mem_rate&#125;%&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cpu使用率⭐</span></span><br><span class="line">grep &#x27;^cpu &#x27; /proc/stat | awk &#x27;&#123;usage=($2+$3+$4)*100/($2+$3+$4+$5)&#125; END &#123;printf &quot;CPU Usage: %.2f%\n&quot;, usage&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>15、组合:怎么周期备份指定目录下的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * 7 * * /usr/bin/cp /etc/passwd /opt/bak</span><br></pre></td></tr></table></figure>

<p>16、怎么周期删除7天前的日志文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * 7 * * /usr/bin/rm -rf `find /var/log -mtime +7 -name &quot;*.log&quot;`</span><br></pre></td></tr></table></figure>

<p>17、过滤出当前目录下所有普通文件中包含xxxx字符串的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rl &quot;xxxx&quot; ./ | find -type f</span><br></pre></td></tr></table></figure>

<p>18、如何反向过滤出以空格开头与#号注释为开头的行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -v &quot;^#|^[[:space:]]|^$&quot;</span><br></pre></td></tr></table></figure>

<p>19、怎么校对2个文件中不同的部分(shell工具可以直接完成这个任务)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff</span><br></pre></td></tr></table></figure>

<p>20、其他的应用场景，比如筛选出当前目录下占用磁盘最高的前10个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah ./ | sort -nr  | sed -n &#x27;2,11p&#x27;</span><br></pre></td></tr></table></figure>

<p>21、我要筛选出1.txt 文件中第10~20行内，包含abc字符串的行，并修改为def</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;NR&gt;=10,NR&lt;=20&#123;print&#125;&#x27; 1.txt | sed &#x27;s/abc/def/&#x27;</span><br></pre></td></tr></table></figure>

<p>22、变量有哪些类型? $? $# $0 $1 $* 分别代表什么意思?</p>
<p>Shell变量主要有：<strong>字符串、数字、数组、环境变量、只读变量、特殊变量和本地变量</strong>这几种类型。</p>
<p>$?:上一个表达式的返回值</p>
<p>$#:位置参数的个数</p>
<p>$0:命令本身</p>
<p>$1:第一个参数</p>
<p>$*:所有位置参数，作为一个字符串</p>
<p>23、cpu压力值过大怎么处理？</p>
<p>排查框架</p>
<p>0、怎么接收到异常信息</p>
<p>1、观测</p>
<p>观测到异常以及更准确的信息(初步的定位范围–》定位到关键点&#x2F;参数)</p>
<p>top htop “ps” “aux&#x2F;elf | grep” “uptime”</p>
<p>2、初步的处理方案</p>
<p>① 先判断（描述动作）占资源前十的进程中，是什么类型的任务（系统任务、业务任务、异常任务）</p>
<p>②考虑解决方案</p>
<p>​	判断可以关闭–》直接关闭</p>
<p>​	主进程、子进程都存在–》其他指令来查看这个进程任务的大致情况（htop–》F5）</p>
<p>3、处理后观测效果</p>
<ol start="24">
<li></li>
</ol>
<p><img src="/./imgs/image-20251103190637524.png" alt="image-20251103190637524"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -r &#x27;s/.*-(.*).jar/\1/&#x27; banben</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251103191159382.png" alt="image-20251103191159382"></p>
<p>25.shell脚本编写规范，shell脚本怎么写的？写过什么脚本</p>
<p>声明解释器，注释说明</p>
<p>按常量、函数、主程序的顺序组织代码</p>
<p>#!&#x2F;bin&#x2F;bash	先写解释器</p>
<p>① 定义变量</p>
<p>重复使用且书写比加长的适合作为变量</p>
<p>IP地址、路径，适合作为变量</p>
<p>（自定义变量）</p>
<p>② 写环境判断</p>
<p>③ 定义函数</p>
<p>④ 有交互写交互，无交互写判断执行逻辑（if、for&#x2F;while循环）</p>
<p>在执行的过程中调用对应的函数名字</p>
<p>⑤ 最好有输出，或者有观测结果的提示</p>
<p>建议准备脚本案例，以防面试官问举例子</p>
<p>写过哪些脚本</p>
<p>① 重复任务 –》备份(tar cp rsync差异备份)、清理、批量创建管理(低频)</p>
<p>② 巡检（）</p>
<p>③ 服务的安装、管理</p>
<p>26.状态码404 403 301 302 503</p>
<p>27.503可能是哪些原因，怎么判断怎么做？</p>
<p>28.nginx反向代理与负载均衡</p>
<p>29.LVS的优势，与nignx的区别</p>
<p>30.nginx配置文件</p>
<ol start="31">
<li></li>
</ol>
<p><img src="/./imgs/image-20251113093357151.png" alt="image-20251113093357151"></p>
<p>32.keepalived（脑裂）双VIP</p>
<ol start="33">
<li></li>
</ol>
<p><img src="/./imgs/image-20251113093426419.png" alt="image-20251113093426419"></p>
<p>34.索引是什么？怎么做的？怎么知道该不该创建索引？</p>
<p><img src="/./imgs/image-20251120113033686.png" alt="image-20251120113033686"></p>
<p><img src="/./imgs/image-20251120113254798.png" alt="image-20251120113254798"></p>
<p>35.索引的种类？有什么区别？</p>
<p>36.mysql的优化（包含创建合适的索引）</p>
<p>云计算面试题</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p><strong>1、docker 常用命令（增删改查）</strong></p>
<p>增：docker run&#x2F;create 删：docker rm&#x2F;rmi 改：docker commit、docker build 查：docker ps&#x2F;images&#x2F;inspect</p>
<p><strong>2、docker -i -t -d什么意思</strong></p>
<p><code>-i</code> (interactive)：交互模式，保持标准输入开放。</p>
<p><code>-t</code> (tty)：分配一个伪终端。</p>
<p><code>-d</code> (detach)：后台运行容器。</p>
<p><strong>3、dockerfile 有哪些指令，dockerfile内容怎么写的，写过哪些dockerfile</strong></p>
<p><strong>常见指令：</strong> <code>FROM</code> (基础镜像), <code>RUN</code> (执行命令), <code>COPY/ADD</code> (拷贝文件), <code>WORKDIR</code> (工作目录), <code>CMD/ENTRYPOINT</code> (启动命令), <code>ENV</code> (环境变量), <code>EXPOSE</code> (暴露端口)。</p>
<p><strong>写法：</strong> 从基础镜像开始，逐层添加配置和依赖，最后定义启动命令。</p>
<p><strong>示例：</strong> 编写过 Java (Jar包启动)、Nginx (修改配置)、Python 项目的 Dockerfile。</p>
<p>1、首先写一个基础镜像<br>FROM 基础镜像 as builder<br>2、使用RUN 执行command 命令，准备依赖环境、执行命令操作<br>3、使用COPY ADD 传入文件<br>4、EXPOSE 暴露端口<br>5、ENV 申明环境变量<br>6、FROM 基础镜像 as runtime<br>7、准备启动环境 CMD ENTRYPOINT </p>
<p><strong>4、dockerfile中cmd 和entrypoint 有什么区别，copy和add有什么区别</strong></p>
<p>CMD：可被覆盖；ENTRYPOINT：容器入口点，难以覆盖 COPY：只复制；ADD：复制+解压+拉取</p>
<p><strong>CMD vs ENTRYPOINT：</strong></p>
<ul>
<li><code>CMD</code>：容器启动时的默认参数，<strong>可以</strong>被 <code>docker run</code> 后面的参数覆盖。</li>
<li><code>ENTRYPOINT</code>：容器启动时执行的命令，<strong>不可</strong>被直接覆盖（参数会追加到后面）。</li>
</ul>
<p><strong>COPY vs ADD：</strong></p>
<ul>
<li><code>COPY</code>：仅支持本地文件拷贝。</li>
<li><code>ADD</code>：支持本地文件，<strong>还支持URL下载</strong>，且会自动<strong>解压</strong> tar 包。</li>
</ul>
<p><strong>5、容器和虚拟化的区别是什么，为什么要用容器？</strong></p>
<p>容器共享宿主机内核，秒级启动、轻量级、镜像小；虚拟化每个OS独立，启动慢、资源占用大</p>
<p><strong>区别：</strong> 虚拟机是<strong>硬件模拟</strong>，有完整OS，重；容器是<strong>共享内核</strong>，进程级隔离，轻。</p>
<p><strong>为什么用：</strong> 启动快（秒级）、占用资源少、移植性强（一次构建，到处运行）、易于交付和扩缩容。<br>⭐本质：容器是<strong>进程级</strong>别，<strong>共享宿主机内核</strong>的，虚拟机技术，完整<strong>OS(操作系统)级别</strong>，<strong>完整的操作系统内核</strong>。</p>
<p><strong>6、docker的底层原理是什么（cgroup namespace）</strong></p>
<p>cgroup控制资源；namespace隔离(网络、进程、文件系统、用户、ipc等)</p>
<p>gemini:</p>
<p><strong>Cgroup：</strong> 资源限制（限制 CPU、内存使用量）。</p>
<p><strong>Namespace：</strong> 资源隔离（隔离 PID、网络、挂载点等，也就是通常说的”沙盒”）。</p>
<p><strong>UnionFS (联合文件系统)：</strong> 镜像分层存储。</p>
<p><strong>7、docker的工作流程是什么？</strong></p>
<p>client → docker daemon → 检查镜像 → 不存在下载 → 创建容器 → 运行</p>
<p><strong>8、docker 怎么发布容器到外面？引申：-p -P区别</strong></p>
<p>使用-p&#x2F;-P映射端口 </p>
<p>-p指定映射(宿主机:容器)、-P随机映射所有EXPOSE端口</p>
<p><strong>9、docker 网络有哪些，有什么特性？</strong></p>
<p>bridge(默认)、host(共享宿主机网络)、overlay(跨主机)、none(无网络) bridge隔离性好、overhead开销低</p>
<p><strong>Bridge (默认)：</strong> 桥接模式，容器有独立IP，通过 docker0 网桥通信。</p>
<p><strong>Host：</strong> 共享宿主机网络栈，无隔离，性能好但端口易冲突。</p>
<p><strong>None：</strong> 无网络，需手动配置。</p>
<p><strong>Container：</strong> 与另一个容器共享网络。</p>
<p><strong>Overlay：</strong> 跨主机通信（Swarm&#x2F;K8S常用）。</p>
<p><strong>10、docker-compose会写么，有没有用过，在哪用的？</strong></p>
<p>会；用于多容器编排(如Web+MySQL)，一个yml定义多个服务</p>
<p><strong>会写：</strong> YAML 格式，定义 services, networks, volumes。</p>
<p><strong>场景：</strong> 开发环境、测试环境、单机部署多容器应用（如 Nginx+App+MySQL 组合）。</p>
<p>比如单机部署前后端服务ruoyi，Promethus等</p>
<p><strong>11、除了docker 有没有用过其他容器？</strong></p>
<p>containerd；去除了docker engine和server，直接与CRI接口交互，K8S高版本标准</p>
<p><strong>12、docker中 怎么把文件传到运行的容器中</strong></p>
<p>docker cp 本地文件 容器id:容器路径</p>
<p><strong>13、dockerfile 怎么写</strong>——与3类似</p>
<p>核心原则：选择最小基础镜像(Alpine)、合并 RUN 指令减少层数、清理缓存减小体积。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p><strong>①  K8S 核心组件有哪些？每个组件是干嘛的？</strong></p>
<p>Master：</p>
<ul>
<li>apiserver(API接口，集群管理调度任务分配，etcd数据库交互)</li>
<li>scheduler(调度器，选择最合适创建Pod的节点)</li>
<li>controller-manager(控制器，管理各类控制器，管理pod生命周期)</li>
<li>etcd(存储，集群核心库)</li>
<li>kubectl(管理集群的命令)</li>
<li>auth(认证鉴权)</li>
</ul>
<p>Node：</p>
<ul>
<li>kubelet(节点代理，管理监控节点中k8s资源与任务的核心组件，将节点信息返回给api-server给etcd保存)</li>
<li>kube-proxy(网络代理，把pod暴露到集群外，给用户访问)</li>
<li>pod(资源调度的最小单位，分装了多个容器，业务运行在容器中)</li>
</ul>
<p><strong>②  K8S 工作流程是什么？</strong><br>简版：</p>
<p>用户kubct→auth认证鉴权→apiserver→etcd(存储)→list清单给apiserver</p>
<p>scheduler与scheduler监听apiserver中list（获取需要干的事情）</p>
<p>scheduler选择合适的节点 controller准备对应的资源 </p>
<p>apiserver通知调度器选择节点的kubelet执行<br>详细：</p>
<p>① kubectl 创建一个Pod 资源（指令&#x2F;yml文件）<br>② 通过auth 认证鉴权后，到达api-server<br>③ api-server将信息记录在etcd中，etcd 会创建一个ADD的事件，并返回给api-server一个<br>list清单（清单中，会申明需要哪些资源）<br>④ Scheduler 监听到Api-server上的ADD事件后，会触发default-scheduler 规则，选择出<br>最适合创建Pod的节点（如worker02），并提交到api-server的list清单中<br>⑤ worker02 的kubelet组件监听到Api-server上的List清单的调度结果后，会触发连接容器<br>运行时的动作，从而pull image 、create container、start container<br>（主要管理的是容器，比如pause 容器、init容器、主应用容器）<br>⑥ controller-manager 控制器管理中心，也会监听到api-server上的List 清单add事件<br>此时，controller-manager会创建deployment–》创建RS—》RS创建Pod 管理kubelet<br>创建的容器<br>⑦ 后续pod的状态，容器的探针等均由kubelet来监控、管理与汇报给api-server<br>⑧ api-server会持续记录在etcd中</p>
<p><strong>③  K8S 搭建用的是什么方式，你们CNI（容器网络接口）用的是什么？</strong></p>
<p><strong>搭建：</strong> <code>kubeadm</code> (常用)、二进制 (高难度，方便排错)、云厂商托管 (ACK&#x2F;EKS)。</p>
<p><strong>CNI (网络插件)：</strong> <code>Calico</code> (性能好，支持BGP&#x2F;IPIP，支持网络策略) 或 <code>Flannel</code> (简单，Overlay模式)。</p>
<p><strong>④  你们K8S集群规模大概多大（1、节点数量-包括master数量和worker数量 2、Pod数量）</strong></p>
<p>(参考话术) 测试环境：3 Master + 5 Worker。生产环境：3 Master + 20~50 Worker。Pod 数量：几百上千个。</p>
<p><strong>⑤  你们K8S中跑的是什么？</strong></p>
<p>K8S 中可以运行所有微服务业务、应用服务、各类的管理系统，除了数据库、中间件（rabbitmq、kafka 等）以及其他极度吃资源的服务&#x2F;环境，其他都可以跑在K8S中</p>
<p>无状态服务 (SpringBoot&#x2F;Go 微服务)、Nginx、前端应用。</p>
<p>⭐1、微服务（前后端项目）<br>⭐2、配置文件、加密文件<br>⭐3、挂载存储<br>4、管理网络通讯<br>⭐5、管理系统 （OA CRM REPORT 财务系统）<br>6、微服务Pod的调度、控制器<br>7、权限管理<br>⭐8、监控<br>⭐9、注册中心<br>⭐10、网关服务</p>
<p>PS:除了数据库、部分中间件也不会跑在里面，对资源使用要求特别高的项目&#x2F;技术</p>
<p>比如：Ruo-Yi ： 前端项目  后端项目 注册中心 网关服务 认证鉴权服务<br>spring cloud&#x2F;spring boot 数据库集群</p>
<p><strong>⑥  K8S 云上还是自建（看你们业务）；什么是私有云、公有云、混合云？</strong></p>
<p><strong>私有云：</strong> 自建机房，数据安全，成本高。</p>
<p><strong>公有云：</strong> 阿里云&#x2F;AWS，弹性伸缩，按需付费。</p>
<p><strong>混合云：</strong> 核心数据在私有云，业务突发在公有云。</p>
<p><strong>⑦  K8S 常用命令（简单问）详细参考50</strong></p>
<p>kubectl get&#x2F;describe&#x2F;create&#x2F;delete&#x2F;apply&#x2F;edit kubectl logs&#x2F;exec&#x2F;port-forward</p>
<p><strong>⑧  有哪些控制器</strong></p>
<p><strong>Deployment：</strong> 无状态应用 (Web服务)。</p>
<p><strong>StatefulSet：</strong> 有状态应用 (DB、Redis，有顺序和固定ID)。</p>
<p><strong>DaemonSet：</strong> 每个节点跑一个 (日志采集、监控Agent)。</p>
<p><strong>Job&#x2F;CronJob：</strong> 一次性任务&#x2F;定时任务。</p>
<p><img src="/./imgs/image-20251217125544956.png" alt="image-20251217125544956"></p>
<p><strong>⑨  你们项目中的产品&#x2F;业务是怎么更新的</strong></p>
<p>一套完整流程：①开发→git commit(提交代码)→CI(jenkins)→镜像构建push→CD(kubectl apply更新)→验证</p>
<p>②开发提交代码 -&gt; GitLab -&gt; Jenkins (CI) 构建镜像 -&gt; 推送 Harbor -&gt; 触发 K8S 修改 Deployment 镜像版本 -&gt; 滚动更新。</p>
<p><strong>10  容器的重启策略、镜像下载策略</strong></p>
<p><strong>重启策略：</strong> <code>Always</code> (总是重启，默认), <code>OnFailure</code> (失败&#x2F;非正常退出才重启), <code>Never</code>。</p>
<p><strong>镜像策略：</strong> <code>Always</code> (总是拉), <code>IfNotPresent</code> (本地没有才拉), <code>Never</code>。</p>
<p><strong>11  Pod内有几种容器，分别是做什么的</strong></p>
<p>app 主容器：业务逻辑 </p>
<p>init 容器：进行初始化操作，为后续容器准备初始化环境(挂载、权限设置等) </p>
<p>pause容器：为其他容器准备网络和挂载命名空间等 </p>
<p>补充（主要是上面三个）：Sidecar容器： 辅助功能（如日志搜集filebeat等、ServiceMesh代理）。</p>
<p><strong>12  Pod类型有哪些，有什么区别</strong></p>
<p>自主式：直接由用户创建的独立Pod，没有任何控制器管理，Pod被删除后不会自动重建</p>
<p>动态（声明式）&#x2F;控制器管理的pod：<strong>声明式创建</strong> - 通过YAML文件描述期望状态，由控制器（Deployment、StatefulSet、DaemonSet等）管理，Pod被删除后，控制器会自动重建以维持期望副本数，支持自动扩缩容、滚动更新、自愈能力</p>
<p>静态式：由kubelet直接管理，不需要API Server，不受控制器管理，Kubelet 会自动根据该目录中的 YAML 文件创建静态 Pod</p>
<p><strong>13、Pod 删除的工作流程是什么</strong>参考工作流程详细版</p>
<p>claude:</p>
<p>① 参与组件：apiserver、etcd、controller-manager、kubelet ② 起始位置：kubectl delete → apiserver ③ 过程：apiserver更新etcd → controller-manager监听删除事件 → 通知kubelet → kubelet删除容器 → 从etcd移除 ④ 方向：单向下行(apiserver→kubelet) ⑤ 机制：grace period(优雅关闭，默认30s) </p>
<p>gemini:</p>
<p>① User 发删请求 -&gt; ② Pod 状态变 Terminating -&gt; ③ <strong>同时进行</strong>：从 Service 端点移除流量 + 容器内执行 <code>preStop</code> 钩子 + 发送 <code>SIGTERM</code> 信号 -&gt; ④ 等待 <code>terminationGracePeriodSeconds</code> (默认30s) -&gt; ⑤ 强制发送 <code>SIGKILL</code> 删除。<br><strong>参考工作流程详细版本，上面两个AI版本都比较简略</strong></p>
<p>比如scheduler会停止调度</p>
<p><strong>14、pod 增删改查命令是什么，以Nginx 为例</strong></p>
<p>① 增：<code>kubectl create deployment ng-deploy --replicas=3 --image=nginx:latest --port=80 -n abc</code> </p>
<p>② 修改镜像：<code>kubectl set image deployment/ng-deploy nginx=nginx:1.20 -n abc</code> </p>
<p>③ 查询：<code>kubectl get po -l app=nginx -n abc</code></p>
<p>④ 删除：<code>kubectl delete deployment ng-deploy -n abc</code></p>
<p><strong>15、Pod 如何发布的（过程描述）以service 的NodePort 模式为例</strong></p>
<p>claude:</p>
<p>创建deployment→生成Pod→创建service(NodePort)→分配31xxx端口→外部通过NodeIP:31xxx访问→kube-proxy转发到Pod:80</p>
<p>gemini:</p>
<p>Pod 启动并拥有 IP -&gt; Service 选择 Pod 标签 -&gt; Service 创建 ClusterIP 和 Endpoints -&gt; NodePort 在每台宿主机开端口 -&gt; 外部访问 NodeIP:NodePort -&gt; 转发给 Service -&gt; 负载均衡到 Pod。</p>
<p><strong>T15需要重新组织</strong></p>
<p><strong>16、K8S 更新Pod 方法（滚动、蓝绿、金丝雀&#x2F;灰度）分别是怎么发布的</strong></p>
<p><strong>滚动更新 (Rolling Update)：</strong> K8S 默认。启动一个新版，杀一个旧版，平滑过渡。</p>
<p><strong>蓝绿发布 (Blue&#x2F;Green)：</strong> 新旧版本并存，测试通过后，Service 流量一次性切到新版。</p>
<p><strong>金丝雀&#x2F;灰度 (Canary)：</strong> 先发极少量新版（如10%流量），观察无误后，逐步扩大比例直至全量。</p>
<p><strong>17、K8S Pod资源限制怎么做的，参数是什么？</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span> &#123;<span class="attr">cpu:</span> <span class="string">100m</span>, <span class="attr">memory:</span> <span class="string">128Mi</span>&#125;  <span class="comment"># 最低保证</span></span><br><span class="line">  <span class="attr">limits:</span> &#123;<span class="attr">cpu:</span> <span class="string">500m</span>, <span class="attr">memory:</span> <span class="string">512Mi</span>&#125;    <span class="comment"># 上限</span></span><br></pre></td></tr></table></figure>

<p><strong>18、K8S集群的默认驱逐机制中，各个资源的驱逐阈值是多少？</strong></p>
<p><strong>memory.available &lt; 100Mi</strong> - 可用内存少于 100M</p>
<p><strong>nodefs.available &lt; 10%</strong> - 节点文件系统可用空间少于 10%</p>
<p><strong>nodefs.inodesFree &lt; 5%</strong> - 节点文件系统可用 inode 少于 5%</p>
<p><strong>imagefs.available &lt; 15%</strong> - 镜像文件系统可用空间少于 15%（如果镜像存储单独分区）</p>
<p><strong>pid.available &lt; 4%</strong> - 可用 PID 少于 4%</p>
<p>NodeCondition 为 NotReady等 </p>
<p>kubelet触发驱逐</p>
<p><strong>驱逐优先级</strong></p>
<p>kubelet 驱逐 Pod 时会按照优先级顺序选择：</p>
<ol>
<li><strong>Best Effort 类 Pod</strong>（优先驱逐）- 没有 requests&#x2F;limits 定义</li>
<li><strong>Burstable 类 Pod</strong> - 有 requests 但 limits 高于 requests</li>
<li><strong>Guaranteed 类 Pod</strong>（最后驱逐）- requests &#x3D; limits</li>
</ol>
<p><strong>19、Pod 健康检查机制是什么，有哪些（探针）类型，有什么区别</strong></p>
<p>健康检查通过探针（Probe）来实现，kubelet 定期执行这些检查来判断容器的健康状态。</p>
<p><strong>liveness探针</strong>：检测Pod是否存活，失败重启 </p>
<p><strong>readiness探针</strong>：检测是否就绪，失败则从service的endpoint移除 </p>
<p><strong>startup探针</strong>：专为启动慢的应用设计，成功前不执行其他探针。</p>
<p><strong>20、Pod 探针的检查方式有哪些</strong></p>
<p>exec(执行命令)、httpGet(http请求，状态码200-399)、tcpSocket(端口连接)</p>
<p><strong>21、钩子的使用作为加分项，在容器创建后，启动前，想插入一段指令或准备一个环境，应该怎么做</strong></p>
<p><strong>PreStop：</strong> 容器终止前执行（如：平滑关闭连接、注册中心下线）。</p>
<p><strong>PostStart：</strong> 容器启动后执行（极少用）。</p>
<p>使用lifecycle钩子PostStart(启动后)或PreStop(停止前)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line">  <span class="attr">postStart:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>22、第一层面试题：直接问调度策略有哪些，怎么做的</strong></p>
<p>nodeSelector、affinity(亲和性)、taints&#x2F;tolerations(污点容忍)、priorityClass(优先级)</p>
<p><strong>默认调度流程：</strong> 预选 (Predicates, 过滤节点) -&gt; 优选 (Priorities, 打分)-&gt;打分。</p>
<p><strong>NodeSelector：</strong> 简单的节点选择 (key&#x3D;value)。</p>
<p><strong>Affinity (亲和性)：</strong></p>
<ul>
<li><code>NodeAffinity</code>：喜欢调度到哪些节点 (软策略&#x2F;硬策略)。</li>
<li><code>PodAffinity</code>：喜欢和哪些 Pod 在一起 (如 App 和 Redis)。</li>
<li><code>PodAntiAffinity</code>：反亲和，<strong>不</strong>和哪些 Pod 在一起 (如高可用部署，两副本不在同一节点)。</li>
</ul>
<p><strong>Taints (污点) &amp; Tolerations (容忍)：</strong></p>
<ul>
<li><p>污点是打在<strong>节点</strong>上的 (拒绝 Pod)。</p>
</li>
<li><p>容忍是打在<strong>Pod</strong>上的 (允许进入污点节点)。</p>
</li>
<li><p><strong>场景：</strong> Master 节点默认有污点不跑业务；专用 GPU 节点打污点，只让 AI 业务跑。</p>
<p>三种污点机制：NoSchedule,PreferNoSchedule,NoExcute</p>
</li>
</ul>
<p><strong>23、第二层面试题：给需求，然后让你使用对应的调度策略完成</strong></p>
<p>例如需求”Pod与app&#x3D;web标签Pod同节点”→用nodeAffinity或podAffinity实现</p>
<p><strong>24、第三层面试题：实际业务报错场景下，如何排查错误发生的可能性</strong></p>
<p>查Pod日志→describe Pod查events→检查节点资源→检查污点→检查调度器日志→验证selector匹配</p>
<p><strong>25、调度器的默认调度规则&#x2F;策略是什么？</strong></p>
<p>predicates(节点过滤)+ priority(优先级评分) 默认按资源、端口、label筛选</p>
<p><strong>26、污点和容忍的作用是什么，什么时候会使用污点机制？</strong></p>
<p>污点：标记节点不可用 </p>
<p>容忍：Pod可在污点节点运行 </p>
<p>用于隔离特殊节点(GPU节点、专用集群)</p>
<p><strong>27、存储类型有哪些，你们用的是什么存储，什么场景使用？</strong></p>
<p>EmptyDir(临时)、HostPath(主机路径)、PV&#x2F;PVC(持久化)、ConfigMap&#x2F;Secret(配置) NFS用于共享存储、Ceph用于块存储、云存储用于云平台</p>
<p><code>EmptyDir</code>：临时存储，Pod 删数据丢 (缓存)。</p>
<p><code>HostPath</code>：挂载宿主机路径 (日志采集)。</p>
<p><code>NFS/Ceph/GlusterFS</code>：网络存储，数据持久化 (数据库、文件服务)。</p>
<p><strong>28、Pod的生命周期有哪些（指的是Pod的状态及对应场景）</strong></p>
<p><strong>1. Pending（待处理）</strong> Pod 已被创建并存储在 etcd 中，但还未被调度到任何节点上。这个阶段可能是因为集群资源不足、节点选择器不匹配或其他调度限制。</p>
<p><strong>2. ContainerCreating（容器创建中）</strong> Pod 已被调度到某个节点，kubelet 正在为 Pod 中的容器拉取镜像并启动容器。</p>
<p><strong>3. Running（运行中）</strong> Pod 中至少有一个容器正在运行。如果 Pod 中有多个容器，这个阶段表示至少一个已经启动。在这个阶段，容器可能会出现失败或重启的情况。</p>
<p><strong>4. Succeeded（成功）</strong> Pod 中的所有容器都已成功退出，且不会重启。通常用于 Job 和 CronJob 这类一次性任务。</p>
<p><strong>5. Failed（失败）</strong> Pod 中至少有一个容器异常终止（退出码非零）。此时 Pod 不会自动重启（除非配置了重启策略）。</p>
<p><strong>6. Unknown（未知）</strong> 由于某种原因，无法获取 Pod 的状态。通常表示 kubelet 与 API 服务器之间的通信出现问题。</p>
<p><strong>7. CrashLoopBackOff（崩溃回退）</strong> 容器不断崩溃并尝试重启，但重启失败，进入指数级的等待后重试。这通常表示应用程序存在问题。</p>
<p><strong>8.ImagePullBackOff（镜像拉取回退）</strong> kubelet 尝试拉取容器镜像失败，然后进入指数级退避重试。常见原因包括镜像不存在、镜像仓库网络不可达、镜像仓库认证失败或镜像tag错误。这个状态会持续重试，直到镜像拉取成功或 Pod 被删除。</p>
<p><strong>9.Terminating（终止中）</strong> Pod 正在被删除。当收到删除请求后，Pod 会进入这个状态。在这个阶段，kubelet 会给容器一个优雅关闭的机会（由 terminationGracePeriodSeconds 指定，默认30秒），超时后会强制杀死容器。</p>
<p><strong>10.Error（错误）</strong> Pod 处于错误状态，通常表示发生了某种异常。比如 API 对象配置错误、资源不足导致 Pod 无法调度、或者节点状态异常等情况。</p>
<p><strong>其他补充的常见状态：</strong></p>
<p><strong>Evicted（驱逐）</strong> 当节点资源不足时（如内存、磁盘），kubelet 会驱逐 Pod 以释放资源。被驱逐的 Pod 会显示这个状态。</p>
<p><strong>init 0&#x2F;2（初始化）</strong> 初始化容器 –》pause创建之后，主容器之前；表示未初始化完成，正在进行初始化环境</p>
<p><strong>OOMKILL（内存溢出）</strong> OOM内存溢出，</p>
<p><strong>29、新建污点的命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key=value:NoSchedule</span><br></pre></td></tr></table></figure>

<p><strong>30、PV PVC SC 有没有用过，用在哪些场景&#x2F;业务？</strong></p>
<p>有；PV(持久卷)→PVC(持久卷申请)→SC(存储类自动配置) 用于数据库、文件存储、日志等</p>
<p><strong>PV (持久卷)：</strong> 运维人员定义的存储资源。</p>
<p><strong>PVC (卷申明)：</strong> 开发人员申请存储的请求。</p>
<p><strong>SC (StorageClass)：</strong> 动态创建 PV 的模板 (自动化)。</p>
<p><strong>关系：</strong> Pod 绑定 PVC，PVC 绑定 PV。</p>
<p><strong>31、你们的PV PVC用的是什么？ NFS Ceph 云存储</strong></p>
<p>NFS(共享存储)或Ceph(分布式)或阿里云NAS 根据业务选择</p>
<p><strong>32、控制器有哪些，分别是干嘛的？</strong></p>
<p>Deployment(无状态) </p>
<p>StatefulSet(有状态) </p>
<p>DaemonSet(每节点一个)</p>
<p> Job(一次性) </p>
<p>CronJob(定时)</p>
<p><strong>33、控制器+调度器的需求场景，例如我有20个节点，每个节点都需要跑一个pod副本，怎么做？</strong></p>
<p>使用DaemonSet，自动在每个节点运行一个Pod副本(如日志收集agent)</p>
<p><strong>34、以33题为基础，增加一个需求，新增的Pod需要和拥有app&#x3D;a标签的Pod 跑在一起</strong></p>
<p>使用DaemonSet+podAffinity(requiredDuringScheduling)指定与app&#x3D;a同节点</p>
<p><strong>35、K8S 控制组合题，比如daemonset 搭配调度器的需求场景</strong></p>
<p>DaemonSet部署监控agent→配合nodeSelector选择特定节点(如GPU节点)+污点容忍</p>
<p><strong>36、你们业务&#x2F;应用会使用哪些控制器</strong></p>
<p>Deployment(Web应用) </p>
<p>StatefulSet(数据库) </p>
<p>DaemonSet(监控&#x2F;日志)</p>
<p>CronJob(定时任务)</p>
<p><strong>37、你们配置文件是怎么管理的&#x2F;或者直接问configmap和secret分别用在什么场景</strong></p>
<p>ConfigMap(非敏感配置)、Secret(敏感信息如密码) git&#x2F;Helm管理yaml</p>
<p><strong>ConfigMap：</strong> 存明文配置 (nginx.conf, application.yml)。</p>
<p><strong>Secret：</strong> 存敏感信息，base64 编码 (密码, 证书, Token)。</p>
<p><strong>使用：</strong> 环境变量注入，或挂载为文件。</p>
<p><strong>38、你们是怎么暴露服务的？</strong></p>
<p>ClusterIP(内部) </p>
<p>NodePort(节点暴露)</p>
<p>LoadBalancer(负载均衡) </p>
<p>Ingress(七层路由)</p>
<p><strong>39、你们用的是哪个ingress？</strong></p>
<p>nginx-ingress-controller(开源)</p>
<p>或云平台自带(如阿里云SLB)</p>
<p><strong>40、ingress的工作原理是什么？</strong></p>
<p>ingress-controller监听ingress资源→更新nginx配置→nginx根据规则路由到后端service→转发到Pod</p>
<p><strong>41、ingress怎么做https转发？</strong></p>
<p>申请tls证书→创建Secret资源→ingress spec.tls字段指定证书Secret→rules定义443端口</p>
<p><strong>42、我K8S节点资源充足的，但是为什么我在创建pod的时候一直创建失败呢</strong></p>
<p>排查：namespace资源限制(ResourceQuota)—是否限制了 Pod 数量或 CPU&#x2F;内存总量、亲和性冲突、污点无容忍、镜像拉取失败</p>
<p>LimitRange</p>
<p><strong>43、怎么将http的流量转到https下？</strong></p>
<p>ingress annotations添加<code>nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;</code></p>
<p><strong>44、你们平时是怎么管理K8S集群的？</strong></p>
<p>Rancher&#x2F;KubeSphere(管理平台) </p>
<p>Prometheus(监控) </p>
<p>EFK(日志)ELK </p>
<p>Helm(资源管理)</p>
<p><strong>45、你们的K8S安全管理是什么？</strong></p>
<p>RBAC(认证→role&#x2F;clusterrole、鉴权→rolebinding&#x2F;clusterrolebinding、准入控制) 绑定user&#x2F;group&#x2F;sa</p>
<p><strong>RBAC (基于角色的访问控制)：</strong></p>
<ul>
<li><code>Role/ClusterRole</code>：定义权限 (能干什么)。</li>
<li><code>RoleBinding/ClusterRoleBinding</code>：绑定 (把权限给谁)。</li>
<li><code>ServiceAccount</code>：Pod 的身份。</li>
</ul>
<p><strong>46、低概率问到helm组件、怎么用的?</strong></p>
<p><strong>Helm：</strong> K8S 的包管理工具 (类似 Yum&#x2F;Apt)。</p>
<p><strong>概念：</strong> <code>Chart</code> (包模板), <code>Values</code> (参数配置), <code>Release</code> (运行实例)。</p>
<p><strong>优势：</strong> 统一管理复杂应用的一堆 YAML，一键部署&#x2F;回滚。</p>
<p>chart(tgz包)、repository(仓库)、release(实例)</p>
<p>文件：Chart.yaml(信息)、values.yaml(参数)、template目录(资源模板)</p>
<p>用法：<code>helm install release-name ./chart-dir -n namespace</code></p>
<p>场景：CI&#x2F;CD中复杂应用发布</p>
<p><strong>47、你们采集K8S日志是怎么做的？</strong></p>
<p><strong>方案1 (Sidecar)：</strong> Pod 里多跑一个 Filebeat 容器搜集日志 (资源消耗大)。</p>
<p><strong>方案2 (DaemonSet)：</strong> 每个 Node 跑一个 Logstash&#x2F;Fluentd，挂载宿主机日志目录 (推荐)。</p>
<p><strong>架构：</strong> Pod -&gt; Console&#x2F;File -&gt; Fluentd -&gt; ElasticSearch -&gt; Kibana (EFK)。</p>
<p>EFK(Elasticsearch+Filebeat+Kibana)或ELK+ Logstash Pod日志→Filebeat采集→Elasticsearch存储→Kibana展示</p>
<p><strong>48、K8S内的Pod 怎么抓包？</strong></p>
<p><code>kubectl exec -it pod-name -- tcpdump -i any -w /tmp/capture.pcap</code> 或在Pod内安装tcpdump</p>
<p>gemini:</p>
<p><code>kubectl exec</code> 进入容器安装 tcpdump。</p>
<p>或者进入宿主机，找到容器网卡 (veth pair) 进行抓包。</p>
<p>使用 <code>ksniff</code> 插件。</p>
<p><strong>49、怎么排查k8s故障的？</strong></p>
<p>kubectl get：查看状态</p>
<p>descibe 资源对象 查看event事件</p>
<p>logs 查看日志</p>
<p>详细讲，比如crashloopbackoff，什么环境，怎么做？</p>
<p>业务问题：观测容器日志</p>
<p><strong>50、K8S 常用命令</strong></p>
<p>查看资源</p>
<p>get - 查看资源列表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods              <span class="comment"># 查看 Pod 列表</span></span><br><span class="line">kubectl get svc               <span class="comment"># 查看 Service 列表</span></span><br><span class="line">kubectl get nodes             <span class="comment"># 查看集群节点</span></span><br><span class="line">kubectl get deployment        <span class="comment"># 查看 Deployment</span></span><br><span class="line">kubectl get all               <span class="comment"># 查看所有资源</span></span><br><span class="line">kubectl get pods -n kube-system  <span class="comment"># 查看指定命名空间的 Pod</span></span><br><span class="line">kubectl get [资源类型] [资源对象] [-n namespace] [--show-labels] <span class="comment">#查看标签</span></span><br><span class="line">kubectl get [资源类型] [资源对象] [-n namespace] [- 标签名=标签值] <span class="comment">#查看指定标签名/标签名=标签值</span></span><br></pre></td></tr></table></figure>

<p>kubectl get [资源类型] [资源对象] [-n namespace]</p>
<p>详细查看资源</p>
<p>describe - 查看资源详细信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;      <span class="comment"># 查看 Pod 详细信息</span></span><br><span class="line">kubectl describe svc &lt;service-name&gt;  <span class="comment"># 查看 Service 详细信息</span></span><br><span class="line">kubectl describe node &lt;node-name&gt;    <span class="comment"># 查看节点详细信息</span></span><br></pre></td></tr></table></figure>

<p>创建和删除资源</p>
<p>create、delete、apply</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f &lt;file.yaml&gt;    <span class="comment"># 创建资源</span></span><br><span class="line">kubectl delete pod &lt;pod-name&gt;    <span class="comment"># 删除 Pod</span></span><br><span class="line">kubectl delete svc &lt;svc-name&gt;    <span class="comment"># 删除 Service</span></span><br><span class="line">kubectl delete -f &lt;file.yaml&gt;    <span class="comment"># 删除 YAML 文件中定义的资源</span></span><br><span class="line">kubectl apply -f &lt;file.yaml&gt;     <span class="comment"># 创建或更新资源</span></span><br></pre></td></tr></table></figure>

<p>Pod 操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;                    <span class="comment"># 查看 Pod 日志</span></span><br><span class="line">kubectl logs -f &lt;pod-name&gt;                 <span class="comment"># 实时查看 Pod 日志</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod-name&gt; -- /bin/bash   <span class="comment"># 进入 Pod 容器</span></span><br></pre></td></tr></table></figure>

<p>Deployment 操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment &lt;deployment-name&gt; --replicas=3          <span class="comment"># 扩缩容</span></span><br><span class="line">kubectl rollout status deployment/&lt;deployment-name&gt;             <span class="comment"># 查看更新状态</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment/&lt;deployment-name&gt;            <span class="comment"># 查看版本历史</span></span><br><span class="line">kubectl rollout undo deployment/&lt;deployment-name&gt;               <span class="comment"># 回滚到上一版本</span></span><br><span class="line">kubectl expose deployment &lt;deployment-name&gt; --target-port=&lt;port&gt; --port=&lt;port&gt; -n &lt;namespace&gt;  <span class="comment"># 创建 Service 暴露服务</span></span><br></pre></td></tr></table></figure>

<p>标签操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">kubectl label [资源类型] [资源对象] [-n namespace] [标签名=标签值]</span><br><span class="line"><span class="comment"># 修改标签</span></span><br><span class="line">kubectl label [资源类型] [资源对象] [-n namespace] [标签名=标签值] --overwrite</span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">kubectl label [资源类型] [资源对象] [-n namespace] [标签名=标签值]-</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ansible-prometheus-elk"><a href="#ansible-prometheus-elk" class="headerlink" title="ansible prometheus elk"></a>ansible prometheus elk</h2><h3 id="ansible-面试题："><a href="#ansible-面试题：" class="headerlink" title="ansible 面试题："></a>ansible 面试题：</h3><p><strong>1、自动化工具你们用过哪些？</strong></p>
<p>ansible：批管理&#x2F;配置管理 </p>
<p>git&#x2F;gitlab：代码管理 </p>
<p>jenkins：CI&#x2F;CD </p>
<p>Docker&#x2F;K8S：容器编排</p>
<p><strong>2、ansible 你用过哪些模块？</strong></p>
<p><strong>模块：</strong> <code>shell/command</code> (执行命令), <code>copy</code> (发文件), <code>file</code> (文件属性), <code>yum/apt</code> (装包), <code>service/systemd</code> (服务管理)。</p>
<p>shell、command、copy、file、yum&#x2F;apt、service、template、script、user等</p>
<p><strong>3、ansible-playbook是怎么写的？</strong></p>
<p>剧本，YAML 格式，定义任务编排。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure>

<p><strong>4、ansible 管理多少台服务器，怎么管理的，用ansible 批量处理什么工作？</strong></p>
<p>管理100+台 </p>
<p>通过inventory分组 </p>
<p>批量处理：系统更新、应用部署、配置管理、巡检等</p>
<h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus:"></a>prometheus:</h3><p><strong>1、工作流程是什么</strong></p>
<p>exporter暴露指标→prometheus定时(15s)抓取→TSDB时序库存储→alertmanager告警→grafana展示</p>
<p><strong>2、prometheus 是用什么部署的，怎么监控的项目？</strong></p>
<p>docker部署或K8S部署 </p>
<p>通过exporter(node-exporter、mysql-exporter)</p>
<p>或内建metrics(cadvisor、metrics-server)</p>
<p><strong>3、prometheus 监控哪些对象？怎么监控的？</strong></p>
<p>系统层：CPU、内存、磁盘、网络 </p>
<p>应用层：QPS、RT、错误率、连接数 </p>
<p>业务层：订单、用户、交易量 </p>
<p>方式：exporter、push gateway、内建指标</p>
<p><strong>4、prometheus 监控了哪些具体指标？</strong></p>
<p>node_cpu_seconds_total(CPU) </p>
<p>node_memory_MemAvailable(内存) </p>
<p>http_request_duration_seconds(响应时间) </p>
<p>http_requests_total(请求数) </p>
<p>container_cpu_usage_seconds(容器CPU)等</p>
<p><strong>5、PromQL怎么写？用过哪些聚合函数？</strong></p>
<p>sum(rate(http_requests_total[5m]))：5分钟请求速率求和 avg(container_memory_usage_bytes)：平均内存 </p>
<p>topk(5, rate(…))：排序取top5 分组：<code>sum(rate(...)) by (instance, job)</code></p>
<p><strong>6、PromQL 的数据类型有哪些？</strong></p>
<p>Instant Vector(瞬时向量) </p>
<p>Range Vector(范围向量) </p>
<p>Scalar(标量) </p>
<p>String(字符串)</p>
<p><strong>7、你们的pro用的时序数据库是哪个?</strong></p>
<p>InfluxDB(通用)或OpenTSDB(大规模数据) </p>
<p>一般用prometheus内置TSDB</p>
<p><strong>8、prometheus 监控多少台服务器？prometheus 架构是什么？</strong></p>
<p>监控100+台 架构：多个exporter→prometheus server(单点或高可用)→alertmanager→notification→grafana</p>
<h3 id="日志分析系统"><a href="#日志分析系统" class="headerlink" title="日志分析系统"></a>日志分析系统</h3><p><strong>1、你们采集哪些日志？</strong></p>
<p>应用日志(tomcat&#x2F;nginx) </p>
<p>系统日志(syslog) </p>
<p>容器日志(stdout) </p>
<p>数据库日志(慢查询)</p>
<p><strong>2、你们怎么部署的日志分析系统？</strong></p>
<p>Docker部署或K8S部署ELK(Elasticsearch (存储+搜索) + Logstash (收集+过滤) + Kibana (展示))改进后EFK，如下</p>
<p>EFK Stack(Elasticsearch+Filebeat&#x2F;Fluentd+Kibana)</p>
<p><strong>3、你们使用什么方法采集的日志？</strong></p>
<p>Filebeat(轻量级)采集→Logstash&#x2F;Fluentd处理→Elasticsearch存储→Kibana展示</p>
<p><strong>4、elasticsearch 查询语句是什么？怎么查看索引</strong></p>
<p>查询：GET &#x2F;index&#x2F;_search {“query”:{“match”:{“field”:”value”}}} 查看索引：GET &#x2F;_cat&#x2F;indices</p>
<hr>
<h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><p><strong>1、git 工具用过么，git是干嘛的？你是怎么用的？哪些命令?</strong></p>
<p>版本控制工具；常用命令：</p>
<ul>
<li>git init&#x2F;clone：初始化&#x2F;克隆</li>
<li>git add&#x2F;commit：暂存&#x2F;提交</li>
<li>git push&#x2F;pull：推送&#x2F;拉取</li>
<li>git branch&#x2F;checkout&#x2F;merge：分支操作</li>
<li>git tag：版本标签</li>
<li>git reset&#x2F;reflog：版本回退</li>
</ul>
<p><strong>冲突解决：</strong> 手动修改冲突文件 -&gt; 重新 add&#x2F;commit。</p>
<p><strong>2、代码管理的流程是什么？工作原理？</strong></p>
<p>流程：开发分支→commit→push→code review→merge到main→触发CI </p>
<p>工作原理：git分布式存储，本地仓库→远程仓库，通过commit记录完整历史</p>
<p><strong>CI (持续集成)：</strong> 代码提交 -&gt; 自动构建 (Maven&#x2F;Go build) -&gt; 单元测试 -&gt; 制作 Docker 镜像。</p>
<p><strong>CD (持续部署)：</strong> 镜像推送到仓库 -&gt; 自动更新 K8S YAML -&gt; 应用滚动更新。</p>
<p><strong>工具：</strong> Jenkins, GitLab CI, ArgoCD (GitOps)。</p>
<p><strong>3、你们的代码仓库是什么？怎么使用？</strong></p>
<p>gitlab&#x2F;gitee&#x2F;github </p>
<p>创建项目→clone到本地→开发→push→merge request→review→merge</p>
<h1 id="云计算相关知识整合"><a href="#云计算相关知识整合" class="headerlink" title="云计算相关知识整合"></a>云计算相关知识整合</h1><h3 id="一、整体框架"><a href="#一、整体框架" class="headerlink" title="一、整体框架"></a>一、整体框架</h3><p><img src="/./imgs/image-20251211152752810.png" alt="image-20251211152752810"></p>
<h3 id="二、技术栈"><a href="#二、技术栈" class="headerlink" title="二、技术栈"></a>二、技术栈</h3><h4 id="1、Linux"><a href="#1、Linux" class="headerlink" title="1、Linux"></a>1、Linux</h4><p>**核心：**增删改查，排查故障的思路与使用的核心命令</p>
<h5 id="（1）基础命令"><a href="#（1）基础命令" class="headerlink" title="（1）基础命令"></a>（1）基础命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下·运维工作（初级）</span><br><span class="line"><span class="comment">#######新增：</span></span><br><span class="line">基本新增指令：<span class="built_in">mkdir</span> <span class="built_in">touch</span> <span class="built_in">cp</span> <span class="built_in">mv</span> tar vim/vi   <span class="built_in">echo</span> <span class="string">&quot;xxxx&quot;</span> &gt;&gt; xx useradd groupadd yum 等等</span><br><span class="line"></span><br><span class="line"><span class="comment">#######删除：</span></span><br><span class="line">基础指令：<span class="built_in">rm</span></span><br><span class="line">组合删除指令： &gt; /var/log/access.log (删除)  rsync（同步文件内容，达到一致，可以跨节点同步，可以用于删除与数据同步操作）</span><br><span class="line"></span><br><span class="line"><span class="comment">######修改：</span></span><br><span class="line">基础指令: vi/vim sed -i </span><br><span class="line"></span><br><span class="line"><span class="comment">######查询：</span></span><br><span class="line">基础指令：<span class="built_in">ls</span> <span class="built_in">cat</span>  <span class="built_in">which</span>(查询<span class="variable">$PATH</span>中包含的系统可识别的命令是否存在以及绝对路径) rpm find(条件匹配查询)  journalctl（-u指定服务 -f 持续查看） <span class="built_in">tail</span> <span class="built_in">head</span></span><br><span class="line"><span class="comment">#围绕基础资源的查询指令(CPU 内存 I/O)</span></span><br><span class="line"><span class="built_in">du</span> free top/htop <span class="built_in">uptime</span> ifconfig vmstate vmtop lsof <span class="built_in">df</span>  netstat/ss  lsblk iostat iotop fdisk  <span class="built_in">cat</span> /proc/cpuinfo（查看CPU信息）  <span class="built_in">cat</span> /etc/redhat-release（查看操作系统与内核版本） ps （elf|aux） pstree pgrep tcpdump</span><br></pre></td></tr></table></figure>

<p><strong>命令用途分类</strong></p>
<h6 id="基础文件与命令操作-The-Basics"><a href="#基础文件与命令操作-The-Basics" class="headerlink" title="基础文件与命令操作 (The Basics)"></a>基础文件与命令操作 (The Basics)</h6><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录内容。</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>查看文件内容 (适用于小文件)。</td>
</tr>
<tr>
<td><code>head</code></td>
<td>查看文件<strong>头部</strong>内容 (默认为前 10 行)。</td>
</tr>
<tr>
<td><code>tail</code></td>
<td>查看文件<strong>尾部</strong>内容 (默认为后 10 行)，常用于实时日志查看 (<code>tail -f</code>)。</td>
</tr>
<tr>
<td><code>find</code></td>
<td>在文件系统中按条件 (名称、时间、大小等) 查找文件。</td>
</tr>
<tr>
<td><code>which</code></td>
<td>查找命令的<strong>绝对路径</strong>（$PATH），确认系统是否能识别该命令。</td>
</tr>
<tr>
<td><code>rpm</code></td>
<td>Red Hat 系系统 (如 CentOS&#x2F;RHEL) 的软件包管理工具，用于查询、安装、卸载软件包。</td>
</tr>
</tbody></table>
<h6 id="系统状态与性能资源-System-Resource-Status"><a href="#系统状态与性能资源-System-Resource-Status" class="headerlink" title="系统状态与性能资源 (System &amp; Resource Status)"></a>系统状态与性能资源 (System &amp; Resource Status)</h6><table>
<thead>
<tr>
<th><strong>资源类别</strong></th>
<th><strong>关键指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPU&#x2F;内存</strong></td>
<td><code>top</code>&#x2F;<code>htop</code></td>
<td>实时查看系统整体性能 (CPU, 内存, 负载) 和进程资源占用情况。</td>
</tr>
<tr>
<td><strong>CPU</strong></td>
<td><code>cat /proc/cpuinfo</code></td>
<td>查看 CPU 硬件详细信息 (核数、型号等)。</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td><code>free</code></td>
<td>查看系统内存 (物理内存和 Swap) 的使用情况。</td>
</tr>
<tr>
<td><strong>系统</strong></td>
<td><code>uptime</code></td>
<td>查看系统已运行时间、登录用户数和<strong>平均负载 (Load Average)</strong>。</td>
</tr>
<tr>
<td><strong>操作系统</strong></td>
<td><code>cat /etc/redhat-release</code></td>
<td>查看操作系统版本信息。</td>
</tr>
<tr>
<td><strong>其他状态</strong></td>
<td><code>vmstat</code></td>
<td>报告虚拟内存统计信息 (包括 I&#x2F;O 块、CPU 活动等)。</td>
</tr>
</tbody></table>
<h6 id="进程管理与日志-Process-Logs"><a href="#进程管理与日志-Process-Logs" class="headerlink" title="进程管理与日志 (Process &amp; Logs)"></a>进程管理与日志 (Process &amp; Logs)</h6><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ps</code> (<code>elf</code>&#x2F;<code>aux</code>)</td>
<td>查看当前运行的进程状态。<code>aux</code> (BSD 风格) 或 <code>elf</code> (System V 风格) 提供详细信息。</td>
</tr>
<tr>
<td><code>pstree</code></td>
<td>以树状图显示进程之间的关系。</td>
</tr>
<tr>
<td><code>pgrep</code></td>
<td>按名称或其他属性查找进程 ID (PID)。</td>
</tr>
<tr>
<td><code>journalctl</code></td>
<td>查看 <code>systemd</code> 服务的日志。<code>-u</code> 指定服务，<code>-f</code> 实时跟踪。</td>
</tr>
</tbody></table>
<h6 id="存储与网络-Storage-Network"><a href="#存储与网络-Storage-Network" class="headerlink" title="存储与网络 (Storage &amp; Network)"></a>存储与网络 (Storage &amp; Network)</h6><table>
<thead>
<tr>
<th><strong>资源类别</strong></th>
<th><strong>关键指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>磁盘空间</strong></td>
<td><code>df</code></td>
<td>查看文件系统 (分区) 的<strong>磁盘空间</strong>使用情况。</td>
</tr>
<tr>
<td><strong>目录大小</strong></td>
<td><code>du</code></td>
<td>查看文件或目录的<strong>磁盘使用量</strong>。</td>
</tr>
<tr>
<td><strong>磁盘 I&#x2F;O</strong></td>
<td><code>iostat</code></td>
<td>报告 CPU 统计信息和设备的输入&#x2F;输出统计信息。</td>
</tr>
<tr>
<td><strong>磁盘 I&#x2F;O</strong></td>
<td><code>iotop</code></td>
<td>实时查看进程级别的磁盘 I&#x2F;O 活动 (类似于 <code>top</code> 看 I&#x2F;O)。</td>
</tr>
<tr>
<td><strong>块设备</strong></td>
<td><code>lsblk</code></td>
<td>列出所有<strong>块设备</strong> (磁盘、分区等)。</td>
</tr>
<tr>
<td><strong>网络配置</strong></td>
<td><code>ifconfig</code>&#x2F;<code>ip a</code></td>
<td>查看或配置网络接口信息 (IP 地址、MAC 地址等)。</td>
</tr>
<tr>
<td><strong>网络连接</strong></td>
<td><code>netstat</code>&#x2F;<code>ss</code></td>
<td>查看网络连接、路由表、接口统计等。<code>ss</code> 是更高效的替代者。</td>
</tr>
<tr>
<td><strong>网络抓包</strong></td>
<td><code>tcpdump</code></td>
<td>抓取和分析网络数据包。</td>
</tr>
<tr>
<td><strong>文件&#x2F;端口</strong></td>
<td><code>lsof</code></td>
<td><strong>列出打开的文件</strong>。常用于查询进程占用的文件或端口。</td>
</tr>
</tbody></table>
<hr>
<h6 id="场景一：高负载与慢响应-High-Load-Slow-Response"><a href="#场景一：高负载与慢响应-High-Load-Slow-Response" class="headerlink" title="场景一：高负载与慢响应 (High Load &amp; Slow Response)"></a>场景一：高负载与慢响应 (High Load &amp; Slow Response)</h6><p>这是最常见的生产环境问题，通常表现为服务响应变慢甚至连接超时。</p>
<p><strong>故障描述</strong></p>
<ul>
<li><strong>现象：</strong> 应用程序响应时间急剧增加，甚至无法访问。</li>
<li><strong>目标：</strong> 确定是 <strong>CPU 瓶颈</strong>、<strong>内存不足</strong>、还是 <strong>I&#x2F;O 瓶颈</strong>导致的。</li>
</ul>
<p>**排查步骤 **</p>
<ol>
<li><strong>快速检查系统整体状态和负载：</strong><ul>
<li><code> uptime</code> → <strong>关键：</strong> 观察 <strong>Load Average</strong> (平均负载)。如果远高于 CPU 核数，说明系统严重过载。</li>
<li><code> free -h</code> → 检查内存是否基本耗尽 (used 接近 total) 或 Swap 是否被大量使用。</li>
</ul>
</li>
<li><strong>定位资源瓶颈和具体进程：</strong><ul>
<li><code>top</code> 或 <code>htop</code> → <strong>关键：</strong><ul>
<li>查看 <strong>%CPU</strong> (哪个进程占用最高？)</li>
<li>查看 <strong>%MEM</strong> (哪个进程占用内存最高？)</li>
<li>查看 <strong>wa</strong> (iowait，如果很高，说明是 I&#x2F;O 瓶颈)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果是 I&#x2F;O 瓶颈 (wa 很高)：</strong><ul>
<li><code>iostat -x 1 5</code> → <strong>关键：</strong> 观察 <code>await</code> (平均 I&#x2F;O 等待时间) 和 <code>%util</code> (磁盘利用率)。</li>
<li><code>iotop</code> → 找到是哪个进程正在执行高强度的磁盘读写。</li>
</ul>
</li>
<li><strong>定位进程路径和日志：</strong><ul>
<li>假设 <code>top</code> 发现 PID 为 <strong>12345</strong> 的进程 CPU 异常：</li>
<li><code>ps -fp 12345</code> → 查看该进程的完整命令和启动路径。</li>
<li><code>lsof -p 12345</code> → 检查该进程打开了哪些文件和网络连接。</li>
<li><code>journalctl -u &lt;服务名&gt; -f</code> → 查看应用服务的实时日志，是否有大量错误或异常请求。</li>
</ul>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>CPU 瓶颈：</strong> 优化代码逻辑，增加缓存，升级硬件或水平扩展。</li>
<li><strong>I&#x2F;O 瓶颈：</strong> 优化磁盘读写，减少日志量，升级 SSD 或使用更专业的存储服务。</li>
</ul>
<hr>
<h6 id="场景二：重大故障：OOMKilled-Out-of-Memory-Killed"><a href="#场景二：重大故障：OOMKilled-Out-of-Memory-Killed" class="headerlink" title="场景二：重大故障：OOMKilled (Out of Memory Killed)"></a>场景二：重大故障：OOMKilled (Out of Memory Killed)</h6><p>这是实际工作中非常重要的故障，系统内核会杀掉占用内存过高的进程以保护自身。</p>
<p><strong>故障描述</strong></p>
<ul>
<li><strong>现象：</strong> 某个关键进程突然消失 (没有正常退出日志)，过了一段时间后又自动重启 (如果配置了自启动)，或者直接宕机。</li>
<li><strong>目标：</strong> 确认进程是被 <strong>OOM Killer</strong> 杀死的，并找到导致内存泄漏&#x2F;溢出的元凶。</li>
</ul>
<p><strong>排查步骤</strong></p>
<ol>
<li><strong>确认 OOMKilled 事件：</strong><ul>
<li><code>journalctl -k -r | grep -i oom</code> → <strong>关键：</strong> 搜索内核日志 ( <code>-k</code> )，查找 <code>Out of memory</code> 或 <code>oom-killer</code> 相关的记录。</li>
<li><strong>或</strong> <code>dmesg | grep -i oom</code> → 确认 OOM killer 杀死了哪个进程 (通常会显示<strong>被杀进程的 PID 和 OOM Score</strong>)。</li>
</ul>
</li>
<li><strong>查看内存使用情况：</strong><ul>
<li><code>free -h</code> → 确认事件发生前内存是否已基本耗尽。</li>
</ul>
</li>
<li><strong>定位被杀进程的详细信息：</strong><ul>
<li>假设被杀进程名为 <code>java</code> 或 <code>nginx</code>：</li>
<li><code>which &lt;进程名&gt;</code> → 确认进程的绝对路径。</li>
<li><code>find / -name &lt;进程名&gt;.log</code> → 查找应用自身日志，看是否有内存溢出 (OOM Exception) 相关的错误。</li>
</ul>
</li>
<li><strong>查看系统的内存配置：</strong><ul>
<li><code>cat /proc/sys/vm/overcommit_memory</code> → 了解内核允许内存超额分配的策略。</li>
</ul>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>根本原因：</strong> 应用程序存在<strong>内存泄漏</strong>或启动时设置的<strong>内存上限过高</strong>。</li>
<li><strong>解决：</strong><ul>
<li><strong>临时：</strong> 增加 Swap 空间，或降低进程的 OOM Score (不推荐，治标不治本)。</li>
<li><strong>治本：</strong> 优化程序代码，设置合理的内存上限 (如 JVM 的 <code>-Xmx</code>)，或升级服务器内存。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="场景三：磁盘空间爆满-Disk-Full"><a href="#场景三：磁盘空间爆满-Disk-Full" class="headerlink" title="场景三：磁盘空间爆满 (Disk Full)"></a>场景三：磁盘空间爆满 (Disk Full)</h6><p>磁盘空间满会导致日志无法写入、应用崩溃、数据库锁死等一系列问题。</p>
<p><strong>故障描述</strong></p>
<ul>
<li><strong>现象：</strong> 应用报错 “No space left on device” 或 “&#x2F;var&#x2F;log” 目录下的日志文件不再更新。</li>
<li><strong>目标：</strong> 确定哪个分区已满，以及是哪个文件&#x2F;目录占用了最大的空间。</li>
</ul>
<p><strong>排查步骤</strong></p>
<ol>
<li><strong>确认哪个分区已满：</strong><ul>
<li><code>df -h</code> → <strong>关键：</strong> 查看 <strong>Use%</strong> 最高的挂载点 (Mounted on)，确定是 <code>/</code> 根目录还是 <code>/home</code> 或 <code>/var/log</code> 等分区。</li>
</ul>
</li>
<li><strong>查找占用空间最大的目录：</strong><ul>
<li>假设 <code>/opt</code> 分区已满：</li>
<li><code>du -sh /opt/*</code> → 逐级查看 <code>/opt</code> 下的一级子目录大小。</li>
<li><code>du -sch /opt/appdata | sort -hr | head -n 10</code> → 深入到目标目录 (<code>/opt/appdata</code>)，列出占用空间最大的前 10 个文件&#x2F;目录。</li>
</ul>
</li>
<li><strong>处理大文件：</strong><ul>
<li><code>find /opt/appdata -type f -size +1G</code> → 查找大于 1GB 的文件 (通常是大日志文件或备份文件)。</li>
</ul>
</li>
<li><strong>处理被删除但仍被占用的文件 (重点，面试高频)：</strong><ul>
<li>如果你删除了一个大文件，但 <code>df -h</code> 空间没有释放，说明该文件仍然被某个进程占用。</li>
<li><code>lsof | grep deleted</code> → 找到那些被标记为 <code>(deleted)</code> 的大文件，以及占用它们的进程 PID。</li>
<li><code>kill -HUP &lt;PID&gt;</code> → <strong>优雅重启</strong> (发 SIGHUP 信号) 占用该文件的进程，或直接 <code>kill &lt;PID&gt;</code> 强制停止，让系统释放文件句柄。</li>
</ul>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>删除：</strong> 清理日志文件 (<code>truncate</code> 或 <code>rm</code>)、旧备份、大缓存文件。</li>
<li><strong>配置：</strong> 配置日志轮转 (<code>logrotate</code>)，防止日志文件无限制增长。</li>
<li><strong>扩容：</strong> 如果是业务数据增长，则需要申请扩容磁盘空间。</li>
</ul>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######常用的指令 </span></span><br><span class="line">ssh （指定密钥文件登录的场景） </span><br><span class="line">⭐⭐tcpdump （网络抓包的指令，可以用于检测网络故障 + 抓取IP 数据包信息---》案例，跑一个nginx，然后使用tcpdump 抓取ens33网卡的网络流量，观测数据。案例2：怎么使用tcpdump 抓取K8S里 Pod 内的流量，命令是什么）</span><br><span class="line">网络检测指令，</span><br><span class="line">telnet （可以检测网络连通性，也可以用于网络监控数据的抓取（使用SNMP简单网络管理协议抓取网络数据，有的时候，面试官会问：你们怎么抓取网络的监控数据的））</span><br><span class="line"></span><br><span class="line">系统资源不足时的排查方法：（Linux阶段）</span><br><span class="line">排查框架：</span><br><span class="line">0、接收到异常信息的</span><br><span class="line">1、观测</span><br><span class="line">如果观测到这个异常，以及更准确的信息（初步的定位范围--》定位到关键点/参数）</span><br><span class="line"><span class="string">&quot;top&quot;</span> <span class="string">&quot;htop&quot;</span> <span class="string">&quot;ps&quot;</span>  <span class="string">&quot;aux/elf | grep &quot;</span>  <span class="string">&quot;uptime&quot;</span></span><br><span class="line"></span><br><span class="line">2、初步的处理方案</span><br><span class="line">① 先判断（描述动作）占资源前10进程中，是什么类型的任务（系统任务、业务任务、异常任务）</span><br><span class="line">② 考虑解决方案</span><br><span class="line">   判断可以关闭--》可以直接关闭</span><br><span class="line">   主进程、子进程都存在---》其他指令来查看这个进程任务的大致情况（htop--》F5）</span><br><span class="line"></span><br><span class="line">3、处理后观测效果</span><br><span class="line">4、持续记录、编写文档（故障文档）</span><br></pre></td></tr></table></figure>

<h6 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h6><p><code>tcpdump</code> 是命令行下的强大网络抓包工具，用于实时监听和分析网络接口上的数据包流量。</p>
<p><strong>核心指令结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i &lt;interface&gt; [options] [filter]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>-i &lt;interface&gt;</code>：</strong> 指定要监听的网络接口 (如 <code>eth0</code>, <code>ens33</code> 等)。</li>
<li><strong><code>-n</code>：</strong> 不进行主机名和端口名解析，直接显示 IP 和端口号 (加快速度)。</li>
<li><strong><code>-nn</code>：</strong> 不解析主机名和端口名。</li>
<li><strong><code>-X</code>：</strong> 以十六进制和 ASCII 码显示数据包内容。</li>
<li><strong><code>-s 0</code>：</strong> 抓取完整的数据包内容 (snaplen 设为 0)。</li>
<li><strong><code>-w &lt;file&gt;</code>：</strong> 将抓包结果写入文件，常用于后续使用 <strong>Wireshark</strong> 分析。</li>
</ul>
<p><strong>案例一：nginx流量观测</strong></p>
<p><strong>目标：</strong> 抓取 <code>ens33</code> 网卡上，与 Nginx 服务（默认 80 端口）相关的网络流量。</p>
<ol>
<li><p><strong>启动抓包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取 ens33 网卡上所有目标端口或来源端口为 80 的流量，并显示 IP 和端口</span></span><br><span class="line">tcpdump -i ens33 -nn port 80</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行操作：</strong> 在另一终端或本机浏览器访问 Nginx 服务 IP。</p>
</li>
<li><p><strong>观测数据：</strong> 你会看到类似以下格式的数据流，清晰展示了 <strong>TCP 三次握手</strong> (<code>[S]</code>, <code>[.]</code>, <code>[S.]</code>) 和 <strong>HTTP 请求</strong>。</p>
</li>
</ol>
<p><img src="/./imgs/image-20251214175002268.png" alt="image-20251214175002268"></p>
<p><strong>案例二：抓取 K8S Pod 内的流量</strong> </p>
<p>在 Kubernetes 环境中，<code>tcpdump</code> 不能直接在宿主机上通过 <code>docker/crictl</code> 进程名去抓取 <strong>Pod 内部</strong> 的流量。正确的做法是进入 Pod 容器内部执行抓包。</p>
<p><strong>K8S 抓包命令</strong></p>
<ol>
<li><p><strong>找到 Pod 名称：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入 Pod 内部并执行 <code>tcpdump</code>：</strong></p>
<ul>
<li><p>首先，确保目标 Pod 内已安装 <code>tcpdump</code> 工具。</p>
</li>
<li><p>使用 <code>kubectl exec</code> 命令进入 Pod 的 Shell (如果容器内有 Shell)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 Pod 名为 my-app-pod，容器名也为 my-app-container</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-app-pod -c my-app-container -- /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Pod 内部执行抓包：</strong> K8S&#x2F;Docker 容器内部的网络接口通常是 <strong><code>eth0</code></strong> 或 <strong><code>lo</code></strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取 eth0 接口上所有 TCP 流量</span></span><br><span class="line"><span class="comment"># 注意：这里已经是 Pod 内部了，不需要 sudo</span></span><br><span class="line">tcpdump -i eth0 -nn tcp</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>简化抓包 (更常用，无需进入 Shell)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在宿主机上执行 Pod 内部的 tcpdump 命令，并抓取 8080 端口的流量</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-app-pod -- tcpdump -i eth0 -nn port 8080 -c 10</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>重点：</strong> Pod 内部的抓包关注的是 <strong>Pod 自身的网络命名空间</strong> 发生的流量，这对于排查 <strong>应用间通信</strong> 或 <strong>Service Mesh</strong> 的问题至关重要。</p>
</blockquote>
<h6 id="telnet的作用？平时怎么抓取网络的监控数据的"><a href="#telnet的作用？平时怎么抓取网络的监控数据的" class="headerlink" title="telnet的作用？平时怎么抓取网络的监控数据的?"></a>telnet的作用？平时怎么抓取网络的监控数据的?</h6><p><code>telnet</code> 通常用于测试特定主机和端口的<strong>连通性</strong>。虽然它本身不再作为安全的远程管理工具使用，但在网络排查中仍然高效。</p>
<p><img src="/./imgs/image-20251214175041366.png" alt="image-20251214175041366"></p>
<p><strong>场景：测试应用端口连通性</strong></p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>目的&#x2F;说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>$ telnet remote_host 80</code></td>
<td>测试远程主机的 80 端口是否开放并可连接。</td>
</tr>
<tr>
<td><code>$ telnet 192.168.1.1 3306</code></td>
<td>测试数据库服务 (MySQL) 的端口连通性。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>排查要点：</strong></p>
<ul>
<li>如果连接成功，显示 <code>Connected to remote_host</code>，说明网络通畅，防火墙也允许该端口流量。</li>
<li>如果连接失败，可能是<strong>防火墙 (iptables&#x2F;firewalld)</strong>、<strong>安全组</strong>或<strong>路由</strong>问题。</li>
</ul>
</blockquote>
<p><strong>平时怎么抓取网络的监控数据的?</strong></p>
<p><strong>第一层：实时、深度的故障排查 (Ad-hoc Analysis)</strong></p>
<p>“在遇到突发网络报错或性能抖动时，我会直接登录服务器，使用命令行工具进行<strong>包级别的抓取</strong>。”</p>
<ul>
<li><strong>流量分析：</strong> 使用 <code>tcpdump</code> 抓取原始数据包（IP、端口、TCP 标志位等）。<ul>
<li><em>示例：</em> “我会用 <code>tcpdump -i eth0 -nn port 80 -w traffic.pcap</code> 抓包，然后导出到 Wireshark 分析是否存在大量重传或延迟。”</li>
</ul>
</li>
<li><strong>连接状态：</strong> 使用 <code>ss</code> 或 <code>netstat</code> 查看当前的 TCP 连接状态（ESTABLISHED、TIME_WAIT 等）。</li>
<li><strong>连通性探测：</strong> 使用 <code>telnet</code> 或 <code>nc (netcat)</code> 验证特定端口的开启情况，使用 <code>ping</code> 或 <code>mtr</code> 观察网络链路的丢包率。</li>
</ul>
<hr>
<p><strong>第二层：自动化的周期性监控 (Automated Monitoring)</strong></p>
<p>“为了实现长期的趋势分析和告警，我们会使用<strong>监控代理 (Agent)</strong> 自动采集数据。”</p>
<ul>
<li><strong>SNMP 采集：</strong> “对于交换机、路由器等硬件网络设备，我们通常开启 <strong>SNMP (简单网络管理协议)</strong>。通过监控软件（如 Zabbix）定时下发 <code>snmpwalk</code> 或 <code>snmpget</code> 命令，采集设备的带宽利用率、接口丢包率、CPU 温度等指标。”<ul>
<li><em>技术细节：</em> “我们会关注 <strong>OID (对象标识符)</strong>，针对不同的硬件厂商配置对应的 MIB 库。”</li>
</ul>
</li>
<li><strong>内建采集器：</strong> “对于 Linux 服务器，我们会部署 <strong>Prometheus 的 Node Exporter</strong>。它会自动读取 <code>/proc/net/dev</code> 文件，抓取网卡的每秒收发包数 (pps) 和吞吐量 (bytes)。”</li>
</ul>
<hr>
<p><strong>第三层：业务层面的网络质量探测 (Application Performance)</strong></p>
<p>“除了基础流量，我们还会监控<strong>业务的端到端网络质量</strong>。”</p>
<ul>
<li><strong>黑盒监控：</strong> “使用 Prometheus 的 <strong>Blackbox Exporter</strong>。它会模拟客户端定期发送 HTTP&#x2F;TCP 请求，监控响应时间、SSL 证书到期时间以及 HTTP 状态码。”</li>
<li><strong>日志分析：</strong> “通过采集 Nginx&#x2F;Envoy 的访问日志（Access Log），分析请求的 Upstream 响应时间，从而判断是网络延迟还是后端应用变慢。”</li>
</ul>
<hr>
<h5 id="（2）Shell-脚本"><a href="#（2）Shell-脚本" class="headerlink" title="（2）Shell 脚本"></a>（2）Shell 脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##写脚本的好习惯</span></span><br><span class="line">初学脚本时，确认环境是干净，然后确定命令可以正确执行。前一条完成后再写脚本</span><br><span class="line">① 要养成生产环境中写脚本的习惯--》路径位置，最好都是用绝对路径来表示</span><br><span class="line">② 变量，在脚本开头先定义好</span><br><span class="line">③ 变量定义的规则： ① 路径比较长的，且多次反复使用的，建议做自定义变量</span><br><span class="line">                  ② 经常需要修改的（IP、路径、文件名字），建议做变量</span><br><span class="line">④ 建议每个执行的操作，写注释</span><br><span class="line">⑤ 脚本使用场景可以更宽阔一些，（加入交互功能）</span><br><span class="line"></span><br><span class="line">Shell脚本用在哪些运维工作</span><br><span class="line">1、重复任务(定期备份、删除、数据同步、巡检、更新发布-》借助ansible 或者 jenkins )</span><br><span class="line">2、用于监控指标数据，管理日志（分割、压缩、归档）</span><br><span class="line">3、复杂任务标准化</span><br><span class="line">4、服务器环境初始化（防火墙 核心防护 系统内核优化 安装常用工具）</span><br></pre></td></tr></table></figure>

<h6 id="案例：shell构建系统监视器"><a href="#案例：shell构建系统监视器" class="headerlink" title="案例：shell构建系统监视器"></a>案例：shell构建系统监视器</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义阈值</span></span><br><span class="line">CPU_THRESHOLD=80</span><br><span class="line">MEMORY_THRESHOLD=80</span><br><span class="line">DISK_THRESHOLD=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送警告的函数</span></span><br><span class="line"><span class="function"><span class="title">send_alert</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(tput setaf 1)</span>ALERT: <span class="variable">$1</span> usage exceeded threshold! Current value: <span class="variable">$2</span>%<span class="subst">$(tput sgr0)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环执行监控</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Monitor CPU</span></span><br><span class="line">  cpu_usage=$(top -bn1 | grep <span class="string">&quot;Cpu(s)&quot;</span> | awk <span class="string">&#x27;&#123;print $2 + $4&#125;&#x27;</span>)</span><br><span class="line">  cpu_usage=<span class="variable">$&#123;cpu_usage%.*&#125;</span></span><br><span class="line">  <span class="keyword">if</span> ((cpu_usage &gt;= CPU_THRESHOLD)); <span class="keyword">then</span></span><br><span class="line">    send_alert <span class="string">&quot;CPU&quot;</span> <span class="string">&quot;<span class="variable">$cpu_usage</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Monitor memory</span></span><br><span class="line">  memory_usage=$(free | awk <span class="string">&#x27;/Mem/ &#123;printf(&quot;%3.1f&quot;, ($3/$2) * 100)&#125;&#x27;</span>)</span><br><span class="line">  memory_usage=<span class="variable">$&#123;memory_usage%.*&#125;</span></span><br><span class="line">  <span class="keyword">if</span> ((memory_usage &gt;= MEMORY_THRESHOLD)); <span class="keyword">then</span></span><br><span class="line">    send_alert <span class="string">&quot;Memory&quot;</span> <span class="string">&quot;<span class="variable">$memory_usage</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Monitor disk</span></span><br><span class="line">  disk_usage=$(<span class="built_in">df</span> -h / | awk <span class="string">&#x27;/\// &#123;print $(NF-1)&#125;&#x27;</span>)</span><br><span class="line">  disk_usage=<span class="variable">$&#123;disk_usage%?&#125;</span></span><br><span class="line">  <span class="keyword">if</span> ((disk_usage &gt;= DISK_THRESHOLD)); <span class="keyword">then</span></span><br><span class="line">    send_alert <span class="string">&quot;Disk&quot;</span> <span class="string">&quot;<span class="variable">$disk_usage</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Display current stats</span></span><br><span class="line">  clear</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Resource Usage:&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;-------------------------&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;CPU: <span class="variable">$cpu_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Memory: <span class="variable">$memory_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Disk: <span class="variable">$disk_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> 2</span><br><span class="line">  <span class="comment"># 添加日志</span></span><br><span class="line">  log_entry=<span class="string">&quot;<span class="subst">$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)</span> CPU: <span class="variable">$cpu_usage</span>% Memory: <span class="variable">$memory_usage</span>% Disk: <span class="variable">$disk_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$log_entry</span>&quot;</span> &gt;&gt; /home/labex/project/resource_usage.log</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214170022336.png" alt="image-20251214170022336"></p>
<h5 id="（3）核心的内容"><a href="#（3）核心的内容" class="headerlink" title="（3）核心的内容"></a>（3）核心的内容</h5><p><strong>面试题</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########常规面试题</span></span><br><span class="line">1、如何查看磁盘空间并排序/并筛选出占用最多的空间的文件？</span><br><span class="line">先选择命令工具用哪个，然后管道符，筛选排序</span><br><span class="line">答：</span><br><span class="line">①<span class="built_in">df</span> -h查看磁盘使用情况</span><br><span class="line">②<span class="built_in">du</span> -sh * | <span class="built_in">sort</span> -hr查看当前目录下文件大小，降序排序</span><br><span class="line">③find 路径 -<span class="built_in">type</span> f <span class="built_in">exec</span> <span class="built_in">ls</span> -<span class="built_in">ln</span> &#123;&#125; \; | <span class="built_in">sort</span> -k5 -hr | <span class="built_in">head</span> -10查看指定目录下最大的10个文件</span><br><span class="line">④<span class="built_in">du</span> -sh */ | <span class="built_in">sort</span> -hr查看指定目录下各子目录占用空间，排序</span><br><span class="line"></span><br><span class="line">⭐⭐2、查看内存、查看cpu、查看网络、查看进程等命令/也会问：你进行日常Linux运维会使用哪些工具？</span><br><span class="line">常用的查询命令：不止是free -m top ps ifconfig netstat（企业中ss用的比较多）</span><br><span class="line">查看文件的：<span class="built_in">cat</span> /proc/cpuinfo(面试问法：查看当前系统CPU核心数量及相关信息的命令)，查看内存的<span class="built_in">cat</span> /proc/meminfo,查看进程类的⭐⭐lsof （查看进程名、查看pid、查看端口号），iotop vmstat ，网络的tcpdump ⭐nload ，tree ，pstree、egrep等等</span><br><span class="line">grep sed awk 视为工具</span><br><span class="line">以上仅表达的是使用Linux的工具作日常运维，可以从写巡检脚本的方向进行介绍对于管理各类资源的工具使用，但是还会涉及以下的内容，这部分也是需要讲的：</span><br><span class="line">例如：git（代码管理）工具、pxe-server工具、wireshark工具，navicat 、protainer 、rancher 、gitlab 、maven、ansible（批量管理） 、grafana（可视化） 等等</span><br><span class="line">查看磁盘I/O的指令</span><br><span class="line">查看网络流量数据的指令</span><br><span class="line"><span class="comment"># 内存</span></span><br><span class="line">free -m              <span class="comment"># 查看内存使用情况</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo    <span class="comment"># 详细内存信息</span></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">top                  <span class="comment"># 实时查看CPU、内存使用情况</span></span><br><span class="line">htop                 <span class="comment"># 更友好的top界面</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo    <span class="comment"># 查看CPU核心数及详细信息</span></span><br><span class="line">lscpu                <span class="comment"># 查看CPU架构信息</span></span><br><span class="line"><span class="comment"># 进程</span></span><br><span class="line">ps aux               <span class="comment"># 查看所有进程</span></span><br><span class="line">ps -ef | grep xxx    <span class="comment"># 查看特定进程</span></span><br><span class="line">pstree               <span class="comment"># 进程树形显示</span></span><br><span class="line">lsof -p [pid]        <span class="comment"># 查看进程打开的文件和端口</span></span><br><span class="line">lsof -i :8080        <span class="comment"># 查看指定端口的进程</span></span><br><span class="line"><span class="comment"># 网络</span></span><br><span class="line">ifconfig / ip addr   <span class="comment"># 查看网络接口</span></span><br><span class="line">netstat -tulnp       <span class="comment"># 查看网络连接和监听端口</span></span><br><span class="line">ss -tulnp            <span class="comment"># netstat的替代品（更推荐）</span></span><br><span class="line">nload                <span class="comment"># 实时查看网络流量</span></span><br><span class="line">tcpdump              <span class="comment"># 抓包分析网络流量</span></span><br><span class="line">iftop                <span class="comment"># 显示网络接口流量</span></span><br><span class="line"><span class="comment"># 磁盘I/O</span></span><br><span class="line">iostat -x 1 5        <span class="comment"># 查看磁盘I/O统计</span></span><br><span class="line">iotop                <span class="comment"># 实时查看磁盘I/O</span></span><br><span class="line">vmstat 1 5           <span class="comment"># 查看虚拟内存统计</span></span><br><span class="line"><span class="comment"># 文件查看</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version    <span class="comment"># 查看内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -a             <span class="comment"># 查看系统信息</span></span><br><span class="line"></span><br><span class="line">⭐⭐3、你们是怎么抓包判断网络问题的，在哪抓，命令+选项是什么？</span><br><span class="line">Linux的抓包工具，提示：包括但不限于tcpdump  wireshark工具。提示:K8S环境如何抓Pod/container的包</span><br><span class="line">答：命令行常用tcpdump 图形化wireshark</span><br><span class="line">抓包位置：①客户端/服务端网卡： 判断请求是否发出或到达</span><br><span class="line">②网关/负载均衡（LVS/Nginx）： 判断中转是否存在丢包或延迟</span><br><span class="line">③K8S 环境： 抓取 Pod 对应的 veth 设备或直接进入 Pod 网络命名空间</span><br><span class="line">tcpdump -i eth0 -nn -s 0 -v port 80 -w /tmp/server.pcap</span><br><span class="line">-i：指定网卡 -nn：不解析主机名和端口（显示数字，提高效率且防DNS阻塞） -s 0：抓取完整包内容（不截断数据部分） -w：将原始包写入文件，方便后续分析。</span><br><span class="line">常用过滤： host &lt;IP&gt;（查指定主机）、tcp port 80（查特定服务）、icmp（查Ping包）。</span><br><span class="line"><span class="comment"># K8S 环境如何抓 Pod 的包</span></span><br><span class="line">方法 A（最快）： 若容器内有工具，直接 kubectl <span class="built_in">exec</span> &lt;pod-name&gt; -- tcpdump -i eth0 -nn。</span><br><span class="line">方法 B（推荐）： 容器内无工具时，使用 kubectl debug 启动一个工具齐全的临时容器共享网络栈。</span><br><span class="line">kubectl debug -it &lt;pod-name&gt; --image=nicolaka/netshoot</span><br><span class="line">方法 C（宿主机级）： 在宿主机找到该 Pod 容器的 PID，进入其网络命名空间抓取。</span><br><span class="line">nsenter -t &lt;PID&gt; -n tcpdump -i eth0</span><br><span class="line"></span><br><span class="line">4、查询命令类的面试题？一般会配合通配符或正则表达式使用</span><br><span class="line">find  <span class="built_in">which</span>  whereis </span><br><span class="line"></span><br><span class="line">5、符号链接中，<span class="built_in">ln</span>的软链接与硬链接命令是什么，有什么区别</span><br><span class="line"><span class="comment"># 软链接（符号链接）:快捷方式，存储源文件路径(删除原文件链接失效)</span></span><br><span class="line"><span class="built_in">ln</span> -s /path/to/original /path/to/link</span><br><span class="line"><span class="comment"># 硬链接:多个指向同一inode的目录项(删除原文件链接任可用)</span></span><br><span class="line"><span class="built_in">ln</span> /path/to/original /path/to/link</span><br><span class="line"></span><br><span class="line">6、Raid 有哪些级别，特性是什么？命令是什么（可能会问）</span><br><span class="line">RAID级别 特性 优势劣势 最小磁盘数</span><br><span class="line">RAID0 条纹化 高性能、容量全利用 无容错，一块坏全损 2</span><br><span class="line">RAID1 镜像 高可靠性、读性能好 磁盘利用率50% 2</span><br><span class="line">RAID5 条纹+奇偶校验 容错+性能+容量平衡 重建速度慢 3</span><br><span class="line">RAID6 双奇偶校验 可容纳2块磁盘故障 写性能降低 4</span><br><span class="line">RAID10 RAID1+RAID0 性能好、可靠性 高磁盘利用率50% 4</span><br><span class="line"></span><br><span class="line">7、组合其他命令的通配符使用，例如：我批量创建10个以demo+[1—10]数字的普通文件，命令是什么？find 查询名称以xxx为开头。大于xxx大小 类型xxx 等条件的文件</span><br><span class="line"><span class="comment"># 批量创建</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span> <span class="built_in">touch</span> demo<span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># find查询</span></span><br><span class="line">find /path -name <span class="string">&quot;demo*&quot;</span> -<span class="built_in">type</span> f                    <span class="comment"># 按名称开头</span></span><br><span class="line">find /path -name <span class="string">&quot;*.log&quot;</span> -size +100M                <span class="comment"># 按大小</span></span><br><span class="line">find /path -<span class="built_in">type</span> f -name <span class="string">&quot;test*&quot;</span>                    <span class="comment"># 按类型</span></span><br><span class="line">find /path -<span class="built_in">type</span> f -mtime -7                        <span class="comment"># 7天内修改的文件</span></span><br><span class="line">find /path -<span class="built_in">type</span> f -name <span class="string">&quot;*.bak&quot;</span> -delete            <span class="comment"># 删除符合条件的文件</span></span><br><span class="line"></span><br><span class="line">8、小概率问：yum仓库怎么配？</span><br><span class="line">答：</span><br><span class="line"><span class="comment"># 查看yum仓库配置</span></span><br><span class="line"><span class="built_in">cat</span> /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"><span class="comment"># 备份原配置</span></span><br><span class="line"><span class="built_in">cp</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line"><span class="comment"># 配置yum仓库（以阿里源为例）</span></span><br><span class="line">vi /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"><span class="comment"># 清理缓存并重建缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line">9、<span class="built_in">ls</span> -l 查看到的结果中，每一列代表什么意思？</span><br><span class="line">-rw-r--r-- 1 root root 1024 Dec 14 10:30 filename</span><br><span class="line">第1位：- （文件类型）</span><br><span class="line">第2-4位：rw- （所有者权限：读写）</span><br><span class="line">第5-7位：r-- （所属组权限：只读）</span><br><span class="line">第8-10位：r-- （其他人权限：只读）</span><br><span class="line">第1列文件类型和权限首字符：- 普通文件, d 目录, l 链接</span><br><span class="line">第2列硬链接数指向该inode的目录项数量</span><br><span class="line">第3列所有者文件的拥有者用户名</span><br><span class="line">第4列所有组文件的所属组名</span><br><span class="line">第5列文件大小字节数</span><br><span class="line">第6-8列时间戳修改日期和时间</span><br><span class="line">第9列文件名文件或目录名称</span><br><span class="line"></span><br><span class="line">⭐10、top 中有哪些信息，load avarage 代表什么？ 你一般用top哪些快捷键看用户、cpu、内存资源的？</span><br><span class="line">top - 10:30:45 up 10 days, 3:25, 2 <span class="built_in">users</span>, load average: 0.5, 0.8, 0.9</span><br><span class="line">Tasks: 150 total, 2 running, 148 sleeping, 0 stopped, 0 zombie</span><br><span class="line">%Cpu(s): 20.0 us, 5.0 sy, 0.0 ni, 75.0 <span class="built_in">id</span>, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br><span class="line">KiB Mem: 8167452 total, 5234567 used, 2932885 free, 123456 buffers</span><br><span class="line">KiB Swap: 2097152 total, 0 used, 2097152 free, 4567890 cached</span><br><span class="line"></span><br><span class="line">  PID USER  PR  NI  VIRT  RES  SHR  S %CPU %MEM TIME+ COMMAND</span><br><span class="line"></span><br><span class="line">load average：平均负载，三个数字分别表示1分钟、5分钟、15分钟的平均负载。数值 = 当前运行进程数+等待队列中的进程数，理想值为CPU核心数。</span><br><span class="line">四核CPU：load &lt; 4 正常，&gt; 4 开始拥塞</span><br><span class="line">%CPU：该进程占用的CPU百分比</span><br><span class="line">%MEM：该进程占用的内存百分比</span><br><span class="line">VIRT：进程虚拟内存大小</span><br><span class="line">RES：进程实际占用物理内存</span><br><span class="line">常用快捷键：</span><br><span class="line">P     <span class="comment"># 按CPU使用率排序（默认）</span></span><br><span class="line">M     <span class="comment"># 按内存使用率排序</span></span><br><span class="line">T     <span class="comment"># 按运行时间排序</span></span><br><span class="line">u     <span class="comment"># 按指定用户过滤</span></span><br><span class="line">k     <span class="comment"># 杀死指定PID进程</span></span><br><span class="line">1     <span class="comment"># 显示各CPU核心使用情况</span></span><br><span class="line">H     <span class="comment"># 显示线程</span></span><br><span class="line">c     <span class="comment"># 显示完整命令行</span></span><br><span class="line">q     <span class="comment"># 退出</span></span><br><span class="line"></span><br><span class="line">11、开机启动顺序</span><br><span class="line">答：BIOS POST → Bootloader(GRUB) → Kernel → Init进程 → 运行级别 → 启动服务</span><br><span class="line">BIOS自检：检查硬件</span><br><span class="line">Bootloader：GRUB加载内核到内存</span><br><span class="line">Kernel：Linux内核初始化</span><br><span class="line">Init进程：PID=1，init读取/etc/inittab或systemd</span><br><span class="line">运行级别（SysVinit）或目标单元（systemd）</span><br><span class="line">启动服务：执行相应的启动脚本</span><br><span class="line"></span><br><span class="line">12、syslog 有哪些日志类型？syslog你怎么管理维护的</span><br><span class="line">答：</span><br><span class="line">syslog 的核心逻辑是基于 “来源 (Facility)” 和 “级别 (Severity)” 进行分类的。</span><br><span class="line">常见的日志来源 (Facilities)</span><br><span class="line">用来标识产生日志的子系统：</span><br><span class="line">auth / authpriv： 安全和认证相关信息（如 ssh 登录）。</span><br><span class="line">cron： 定时任务相关日志。</span><br><span class="line">kern： 内核产生的日志（如驱动报错、OOM）。</span><br><span class="line">mail： 邮件系统日志。</span><br><span class="line">syslog： syslog 服务自身产生的日志。</span><br><span class="line">user： 用户级程序产生的日志（默认分类）。</span><br><span class="line">local0 - local7： 预留给用户自定义的类别（常用于 Nginx、Haproxy 等应用）。</span><br><span class="line">日志级别 (Severities)</span><br><span class="line">按严重程度排序（0最高，7最低）：</span><br><span class="line">0 (emerg)： 系统不可用（紧急）。</span><br><span class="line">1 (alert)： 必须立即采取措施。</span><br><span class="line">2 (crit)： 临界状态（严重错误）。</span><br><span class="line">3 (err)： 普通错误。</span><br><span class="line">4 (warning)： 警告。</span><br><span class="line">5 (notice)： 普通但重要的通知。</span><br><span class="line">6 (info)： 信息性消息。</span><br><span class="line">7 (debug)： 调试级信息。</span><br><span class="line"></span><br><span class="line"><span class="comment"># syslog 的管理与维护 (运维实践)</span></span><br><span class="line">在实际工作中，通常使用 rsyslog 或 syslog-ng。维护工作主要围绕：配置分流、日志轮转、集中存储。</span><br><span class="line">A. 配置分流 (Configuration)</span><br><span class="line">修改 /etc/rsyslog.conf，将不同类型的日志发送到指定位置：</span><br><span class="line"><span class="comment"># 规则：来源.级别   存储路径</span></span><br><span class="line">authpriv.* /var/log/secure       <span class="comment"># 登录信息存这里</span></span><br><span class="line">mail.* -/var/log/maillog     <span class="comment"># 邮件信息异步写入</span></span><br><span class="line">cron.* /var/log/cron</span><br><span class="line">local7.* /var/log/boot.log     <span class="comment"># 自定义应用日志</span></span><br><span class="line">B. 日志轮转 (Logrotate)</span><br><span class="line">为防止单个日志文件无限增大撑爆磁盘，必须配置 logrotate。</span><br><span class="line">位置： /etc/logrotate.d/syslog</span><br><span class="line">策略： 按天（daily）或按大小（size）切割，并进行压缩（compress）和保留天数设置（rotate 7）。</span><br><span class="line">C. 远程集中管理 (Centralization)</span><br><span class="line">在大型生产环境，单机日志不便于查询且不安全。</span><br><span class="line">转发： 将所有服务器日志实时转发到远端日志服务器。</span><br><span class="line"><span class="comment"># 在客户端配置转发到远程服务器</span></span><br><span class="line">*.* @192.168.1.100:514    <span class="comment"># 使用 UDP 转发</span></span><br><span class="line">*.* @@192.168.1.100:514   <span class="comment"># 使用 TCP 转发</span></span><br><span class="line">收集： 现代架构通常采用 ELK (Elasticsearch, Logstash, Kibana) 或 Loki。rsyslog 作为数据源，通过采集器发往 Elasticsearch，实现全文检索和可视化监控。</span><br><span class="line">D. 实时维护指令</span><br><span class="line">查看服务状态： systemctl status rsyslog</span><br><span class="line">实时观察： <span class="built_in">tail</span> -f /var/log/messages</span><br><span class="line">查看系统日志（systemd）： journalctl -xe</span><br><span class="line"></span><br><span class="line">⭐13、iptables/firewalld 会不会用，四表五链有哪些，分别是干什么的？</span><br><span class="line">四表：</span><br><span class="line">filter表：数据过滤（默认）</span><br><span class="line">nat表：网络地址转换</span><br><span class="line">mangle表：修改数据包</span><br><span class="line">raw表：跟踪数据包状态</span><br><span class="line">五链：</span><br><span class="line">INPUT：入站流量</span><br><span class="line">OUTPUT：出站流量</span><br><span class="line">FORWARD：转发流量</span><br><span class="line">PREROUTING：路由前处理（nat表）</span><br><span class="line">POSTROUTING：路由后处理（nat表）</span><br><span class="line"><span class="comment"># 查看规则</span></span><br><span class="line">iptables -L -n</span><br><span class="line">iptables -t nat -L -n</span><br><span class="line">iptables -L -n -v</span><br><span class="line"><span class="comment"># 添加规则</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line"><span class="comment"># 删除规则</span></span><br><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">⭐14、firewalld 怎么拒绝xxx网段 xxx端口的访问,具体的命令是什么？</span><br><span class="line"><span class="comment"># 拒绝指定网段访问指定端口</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.0/24&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; reject&#x27;</span></span><br><span class="line"><span class="comment"># 拒绝指定IP访问</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;10.0.0.5&quot; reject&#x27;</span></span><br><span class="line"><span class="comment"># 拒绝指定网段的所有流量</span></span><br><span class="line">firewall-cmd --permanent --add-source=192.168.1.0/24 --zone=drop</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看规则</span></span><br><span class="line">firewall-cmd --list-rich-rules</span><br><span class="line"></span><br><span class="line">⭐15、firewalld 怎么放通xxx网络 xxx端口的访问,具体的命令是什么？</span><br><span class="line"><span class="comment"># 放通指定网段的指定端口</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.0/24&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&#x27;</span></span><br><span class="line"><span class="comment"># 简单放通端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line"><span class="comment"># 放通指定IP访问指定端口</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;10.0.0.5&quot; port protocol=&quot;tcp&quot; port=&quot;3306&quot; accept&#x27;</span></span><br><span class="line"><span class="comment"># 放通服务</span></span><br><span class="line">firewall-cmd --permanent --add-service=http</span><br><span class="line">firewall-cmd --permanent --add-service=https</span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看允许的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line">firewall-cmd --list-services</span><br><span class="line"></span><br><span class="line">⭐16、firewalld 怎么对内网数据包进行NAT映射（SNAT DNAT）,具体的命令是什么</span><br><span class="line"><span class="comment"># 启用IP转发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="comment"># SNAT：内网访问外网时修改源IP</span></span><br><span class="line">firewall-cmd --permanent --add-masquerade</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 或指定具体网段</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.0/24&quot; masquerade&#x27;</span></span><br><span class="line"><span class="comment"># DNAT：外网访问内网某服务时，修改目标IP和端口</span></span><br><span class="line"><span class="comment"># 访问本机8080端口转发到内网192.168.1.10:3306</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; destination address=&quot;192.168.1.1&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; forward-port to-addr=&quot;192.168.1.10&quot; to-port=&quot;3306&quot;&#x27;</span></span><br><span class="line"><span class="comment"># 或使用iptables</span></span><br><span class="line">iptables -t nat -A PREROUTING -d 192.168.1.1 -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.10:3306</span><br><span class="line">iptables -t nat -A POSTROUTING -d 192.168.1.10 -p tcp --dport 3306 -j MASQUERADE</span><br><span class="line"><span class="comment"># 保存iptables规则</span></span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line">17、你有没有做过内核优化？做的哪些？</span><br><span class="line">① 网络类的内核优化</span><br><span class="line">② 线程池的内核优化</span><br><span class="line">③ cpu 、内存 、io的资源优化</span><br><span class="line">④ 文件描述符，队列等策略上的优化</span><br><span class="line"></span><br><span class="line">18、DNS类：问主机的Cname P记录A记录是什么</span><br><span class="line">A 记录 (Address Record)</span><br><span class="line">定义： 最基本的 DNS 记录，用于将域名直接映射到一个 IPv4 地址。</span><br><span class="line">作用： 告诉浏览器，访问 www.example.com 时应该去哪个物理服务器 IP。</span><br><span class="line"><span class="comment">#补充AAAA 记录是什么？ 答：类似于 A 记录，但它是指向 IPv6 地址 的。</span></span><br><span class="line"></span><br><span class="line">CNAME 记录 (Canonical Name Record)</span><br><span class="line">定义： 别名记录，用于将一个域名指向另一个域名，而不是 IP 地址。</span><br><span class="line">作用： 当一个服务器有多个业务域名，或者使用 CDN（内容分发网络）时非常有用。如果目标 IP 变了，你只需要修改那个“最终域名”的 A 记录，所有指向它的 CNAME 都会自动同步。</span><br><span class="line"></span><br><span class="line">PTR 记录（P记录） (Pointer Record)</span><br><span class="line">定义： 指针记录，也被称为反向 DNS 查询。</span><br><span class="line">作用： 与 A 记录相反，它是将 IP 地址 映射回 域名。</span><br><span class="line">常见场景：</span><br><span class="line">邮件过滤： 很多邮件服务器会检查发件 IP 是否有对应的 PTR 记录，如果没有，可能会被判定为垃圾邮件。</span><br><span class="line">排查工具： 执行 nslookup 或 dig -x 时使用的就是 PTR 记录。</span><br><span class="line"><span class="comment"># TTL 是什么意思？答：Time To Live（生存时间）。指的是 DNS 记录在缓存服务器中保留的时间（秒）。调低 TTL 可以加快 DNS 变更的生效速度，但会增加 DNS 查询压力。</span></span><br><span class="line"></span><br><span class="line">19、怎么输出本机的主机名、内核版本、cpu内核数量</span><br><span class="line"><span class="comment"># 主机名</span></span><br><span class="line">hostname</span><br><span class="line">hostnamectl status</span><br><span class="line"><span class="comment"># 内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line"><span class="comment"># CPU核心数</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="built_in">nproc</span></span><br><span class="line">lscpu | grep <span class="string">&quot;CPU(s)&quot;</span></span><br><span class="line"><span class="comment"># 综合信息</span></span><br><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">hostnamectl</span><br><span class="line"><span class="comment"># 补充操作系统信息cat /etc/redhat-release</span></span><br><span class="line"></span><br><span class="line">⭐20、怎么使用iptables 限制流量访问频次</span><br><span class="line"><span class="comment"># 限制单个IP每分钟最多10次请求</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/minute --limit-burst 20 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"><span class="comment"># 限制单个IP每秒最多3次连接</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/second --limit-burst 10 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"><span class="comment"># 使用recent模块限制（10分钟内最多10个连接）</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --<span class="built_in">set</span> --name http_limit</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --update --seconds 600 --hitcount 10 --name http_limit -j DROP</span><br><span class="line"><span class="comment"># 基于连接数限制</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j DROP</span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line"><span class="comment">############组合类</span></span><br><span class="line">⭐1、你们的巡检脚本怎么写的？？巡检了哪些资源，怎么做的</span><br><span class="line">答：巡检项目：CPU使用率、内存使用率、磁盘使用率、网络连接数、进程运行状态、系统负载、磁盘I/O、网络流量</span><br><span class="line">实例：</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 系统巡检脚本</span></span><br><span class="line">HOSTNAME=$(hostname)</span><br><span class="line">TIMESTAMP=$(<span class="built_in">date</span> +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">LOG_FILE=<span class="string">&quot;/var/log/system_check.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;========== 系统巡检 [<span class="variable">$TIMESTAMP</span>] ==========&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># CPU检查</span></span><br><span class="line">CPU_USAGE=$(top -bn1 | grep <span class="string">&quot;Cpu(s)&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;%&#x27;</span> -f1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;CPU使用率: <span class="variable">$&#123;CPU_USAGE&#125;</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$CPU_USAGE</span> &gt; <span class="number">80</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;⚠️ CPU告警: 使用率过高&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 内存检查</span></span><br><span class="line">MEM_USAGE=$(free | grep Mem | awk <span class="string">&#x27;&#123;printf(&quot;%.2f&quot;, ($3/$2)*100)&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内存使用率: <span class="variable">$&#123;MEM_USAGE&#125;</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$MEM_USAGE</span> &gt; <span class="number">85</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;⚠️ 内存告警: 使用率过高&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 磁盘检查</span></span><br><span class="line"><span class="built_in">df</span> -h | grep -v <span class="string">&quot;^Filesystem&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    USAGE=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;%&#x27;</span> -f1)</span><br><span class="line">    MOUNT=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;磁盘[<span class="variable">$MOUNT</span>]使用率: <span class="variable">$&#123;USAGE&#125;</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$USAGE</span> -gt 85 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;⚠️ 磁盘告警[<span class="variable">$MOUNT</span>]: 使用率过高&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 负载检查</span></span><br><span class="line">LOAD=$(<span class="built_in">uptime</span> | awk <span class="string">&#x27;&#123;print $(NF-2)&#125;&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;系统负载(1min): <span class="variable">$LOAD</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># 进程检查</span></span><br><span class="line">PROCESS_COUNT=$(ps aux | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;运行进程数: <span class="variable">$PROCESS_COUNT</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># 网络连接数</span></span><br><span class="line">CONN_COUNT=$(ss -tan | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;网络连接数: <span class="variable">$CONN_COUNT</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># 磁盘I/O检查</span></span><br><span class="line">iostat -x 1 1 | <span class="built_in">tail</span> -n +4 | awk <span class="string">&#x27;&#123;print &quot;磁盘: &quot;$1&quot; I/O使用率: &quot;$4&quot;%&quot;&#125;&#x27;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;========== 巡检完成 ==========&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"></span><br><span class="line">⭐2、网络波动较大，你们是怎么排查故障和解决的？使用哪些工具？（一种类型，还包含磁盘、CPU负载、进程资源不够用的、OOM的）</span><br><span class="line">问题与思路：</span><br><span class="line">① 网络波动较大的话，如何判断是<span class="string">&quot;波动&quot;</span>大？而不是<span class="string">&quot;网络负载压力大&quot;</span>，工具是什么，如何观测到的</span><br><span class="line">② 排查顺序，例如：先ssh进入到服务器，或者直接使用工具观测到，和查看到波动异常的数据</span><br><span class="line">③ 然后通过pid、网络、内存、cpu进程等这类资源管理工具的使用，定位到具体是哪个区域出现了问题</span><br><span class="line">④ 逐个排查引起问题的原因，然后判断后续的解决方案是否影响业务线，然后尝试解决并记录</span><br><span class="line">⑤ 优化后续的运维方法与调整策略，尽量避免此类问题</span><br><span class="line">答：分5步：</span><br><span class="line">① 判断是波动还是压力大</span><br><span class="line">  用nload看流量min/max、ping看延迟stddev、netstat看错误统计</span><br><span class="line">② 排查顺序</span><br><span class="line">  top看系统全景 → nload/netstat看网络 → 找主要进程</span><br><span class="line">③ 定位问题区域</span><br><span class="line">  看CPU/内存/磁盘/网络各个资源，判断瓶颈所在</span><br><span class="line">④ 排查根本原因</span><br><span class="line">  DDoS → 限流</span><br><span class="line">  应用慢 → 优化或重启</span><br><span class="line">  网络不稳定 → 调参</span><br><span class="line">  磁盘IO高 → 优化</span><br><span class="line">⑤ 事后处理</span><br><span class="line">  分析日志 → 找规律 → 优化策略 → 建监控</span><br><span class="line"></span><br><span class="line"><span class="comment">###########场景类：</span></span><br><span class="line"><span class="comment">#给一个具体的案例现象，问你⭐思路与⭐具体命令（逻辑）</span></span><br><span class="line">第一类和上述组合面试题中第2题类似</span><br><span class="line">1、我磁盘明明有空间，但是为什么创建不了文件？</span><br><span class="line">现象</span><br><span class="line"><span class="comment"># 磁盘显示有空间，但touch新文件报错：No space left on device</span></span><br><span class="line"><span class="built_in">touch</span> /data/test.txt</span><br><span class="line"><span class="comment"># 报错！</span></span><br><span class="line">排查思路 + 命令：</span><br><span class="line">第一步：检查磁盘空间</span><br><span class="line">bashdf -h /data        <span class="comment"># 看使用率 &lt; 100% 确实有空间</span></span><br><span class="line">第二步：检查Inode（真正原因）</span><br><span class="line">bashdf -i /data        <span class="comment"># 看IUse% &gt;= 100% → Inode满了！</span></span><br><span class="line"><span class="comment"># 输出示例：IUse% 100% → 问题找到</span></span><br><span class="line">第三步：找出占用Inode最多的文件</span><br><span class="line">bashfind /data -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l        <span class="comment"># 统计文件总数</span></span><br><span class="line">find /data -<span class="built_in">type</span> d | <span class="built_in">wc</span> -l        <span class="comment"># 统计目录总数</span></span><br><span class="line"><span class="comment"># 找占用最多的小文件</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -size -1k | <span class="built_in">wc</span> -l</span><br><span class="line">第四步：清理</span><br><span class="line">bash# 删除临时文件</span><br><span class="line">find /data -name <span class="string">&quot;*.tmp&quot;</span> -delete</span><br><span class="line">find /data -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">type</span> f -size +100M -delete</span><br><span class="line"><span class="comment"># 或清理很久没修改的文件</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -mtime +30 -delete</span><br><span class="line"></span><br><span class="line">2、我要筛选出指定目录下，占用磁盘空间最多的普通文件，怎么找到？（可以配合find + 通配符 找到符合条件的问及那）</span><br><span class="line"><span class="comment"># 最快最简单</span></span><br><span class="line"><span class="built_in">du</span> -sh /data/* | <span class="built_in">sort</span> -hr | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 如果要递归所有子目录</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -size +10M | xargs <span class="built_in">ls</span> -lh | <span class="built_in">sort</span> -k5 -hr</span><br><span class="line"></span><br><span class="line">⭐3、演进版的，某一个目录的磁盘空间满了，我要怎么处理？</span><br><span class="line">① 查看到这个目录占用最大的文件是什么？</span><br><span class="line">② 判断是否可以删除，还是需要先备份部分文件</span><br><span class="line">③ 有一种简单粗暴的解决方法发，如果该内容还需要继续使用，可以先备份、再删除</span><br><span class="line">④ 另一种可行性的方法：先删一部分不用的文件，然后临时创建一个存储卷/或者nfs共享存储，挂载给这个目录（空间就有了），最后再对这个目录内容进行调整优化。</span><br><span class="line">⑤ xxxx</span><br><span class="line">答：</span><br><span class="line">① 查看占用最大的文件</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="comment"># 查看大文件</span></span><br><span class="line"><span class="built_in">du</span> -sh * | <span class="built_in">sort</span> -hr | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 找出最大的单个文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \; | <span class="built_in">sort</span> -k5 -hr | <span class="built_in">head</span> -1</span><br><span class="line">② 判断是否可以删除</span><br><span class="line"><span class="comment"># 检查文件被使用情况</span></span><br><span class="line">lsof /data/large_file.log      <span class="comment"># 看有没有进程在使用</span></span><br><span class="line"><span class="comment"># 查看文件修改时间</span></span><br><span class="line"><span class="built_in">ls</span> -l /data/large_file.log     <span class="comment"># 很久没改的可以删</span></span><br><span class="line"><span class="comment"># 查看文件内容是否重要</span></span><br><span class="line">file /data/large_file</span><br><span class="line"><span class="built_in">head</span> -10 /data/large_file</span><br><span class="line">③ 简单粗暴方案：备份 + 删除</span><br><span class="line"><span class="comment"># 1. 备份</span></span><br><span class="line">tar -czf backup_$(<span class="built_in">date</span> +%Y%m%d).tar.gz /data/large_file</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">rsync -avz /data/large_file remote_server:/backup/</span><br><span class="line"><span class="comment"># 2. 删除</span></span><br><span class="line"><span class="built_in">rm</span> /data/large_file</span><br><span class="line"><span class="comment"># 3. 清空日志（如果是日志文件）</span></span><br><span class="line">&gt; /data/app.log</span><br><span class="line"><span class="comment"># 4. 重启应用（如果文件被占用）</span></span><br><span class="line">systemctl restart app</span><br><span class="line">④ 扩容方案：挂载新存储（更可靠）</span><br><span class="line"><span class="comment"># 1. 创建备份</span></span><br><span class="line"><span class="built_in">cp</span> -r /data /backup</span><br><span class="line"><span class="comment"># 2. 准备新磁盘（假设为/dev/sdb1）</span></span><br><span class="line">mkfs.ext4 /dev/sdb1</span><br><span class="line"><span class="comment"># 3. 挂载新磁盘</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /data_new</span><br><span class="line">mount /dev/sdb1 /data_new</span><br><span class="line"><span class="comment"># 4. 移动数据到新磁盘</span></span><br><span class="line"><span class="built_in">mv</span> /data/* /data_new/</span><br><span class="line"><span class="comment"># 5. 用bind mount把新磁盘挂到原目录</span></span><br><span class="line">umount /data_new</span><br><span class="line">mount --<span class="built_in">bind</span> /data_new /data</span><br><span class="line"><span class="comment"># 6. 永久配置（编辑/etc/fstab）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/sdb1  /data_new  ext4  defaults  0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/data_new  /data  none  bind  0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line"><span class="comment"># 7. 验证</span></span><br><span class="line"><span class="built_in">df</span> -h /data</span><br><span class="line">⑤ 日志轮转配置（预防措施）</span><br><span class="line"><span class="comment"># 编辑/etc/logrotate.d/app</span></span><br><span class="line">vi /etc/logrotate.d/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置示例：</span></span><br><span class="line">/var/log/app.log &#123;</span><br><span class="line">    daily              <span class="comment"># 每天轮转</span></span><br><span class="line">    rotate 7           <span class="comment"># 保留7个备份</span></span><br><span class="line">    compress           <span class="comment"># 压缩旧日志</span></span><br><span class="line">    missingok          <span class="comment"># 文件不存在不报错</span></span><br><span class="line">    notifempty         <span class="comment"># 空文件不轮转</span></span><br><span class="line">    size 100M          <span class="comment"># 或按大小轮转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 手动执行</span></span><br><span class="line">logrotate -f /etc/logrotate.d/app</span><br><span class="line"><span class="comment"># 定时清理（编辑crontab）</span></span><br><span class="line">crontab -e</span><br><span class="line">0 1 * * * find /var/log -name <span class="string">&quot;*.log.*&quot;</span> -mtime +30 -delete</span><br><span class="line">答题框架：</span><br><span class="line">答：分4步</span><br><span class="line">① 诊断：用什么工具确认问题</span><br><span class="line">   磁盘: <span class="built_in">df</span> -h / <span class="built_in">du</span> -sh / <span class="built_in">df</span> -i</span><br><span class="line">   内存: ps aux / top / <span class="built_in">cat</span> /proc/status</span><br><span class="line">   网络: nload / netstat / ss</span><br><span class="line">② 定位：问题具体在哪儿</span><br><span class="line">   磁盘: inode满 / 某个文件太大 / 日志堆积</span><br><span class="line">   内存: 内存泄漏 / 缓存未清理</span><br><span class="line">   网络: DDoS / 应用慢 / 网络不稳定</span><br><span class="line">③ 解决：提供2-3个方案</span><br><span class="line">   快速方案（临时）</span><br><span class="line">   长期方案（根本）</span><br><span class="line">④ 事后：如何预防</span><br><span class="line">   建监控 / 调参数 / 优化代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">⭐⭐⭐4、报错--》内存泄漏(OOM KILL)，怎么办？（一般是可以做为故障案例来描述解决方法，也会出现在面试题中）</span><br><span class="line">⭐⭐5、网络现象导致的异常，怎么排查，例如网络压力过大，系统处理卡顿，怎么处理（iptables） </span><br><span class="line">查询：（目的是判断网络资源占用最大的进程是哪个）：使用哪些工具？nload 、日志、监控其他命令和可视化工具。先判断是异常还是激增流量带来的问题</span><br><span class="line">解决：</span><br><span class="line">    ① 使用iptables/firewalld工具做限流，例如10分钟内相同来源 不可以访问超过10次（示例），要有命令</span><br><span class="line">    ② 是否可以做服务临时优化？（nginx类、ACL访问控制类、访问策略类）</span><br><span class="line">    ③ 考虑是否有必要临时扩容？还是已经定义了弹性伸缩，可以自行进行伸缩处理，以面对高并发</span><br><span class="line">事后：总结记录，有必要的情况下要复盘，优化管控流程</span><br></pre></td></tr></table></figure>

<h6 id="OOM-KILL"><a href="#OOM-KILL" class="headerlink" title="OOM KILL"></a>OOM KILL</h6><p><strong>现象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用运行一段时间后，内存占用不断增加，最终被OOM杀死</span><br></pre></td></tr></table></figure>

<p><strong>排查思路 + 命令</strong></p>
<p><strong>第一步：确认是内存泄漏</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控进程内存</span></span><br><span class="line">watch -n 5 <span class="string">&#x27;ps aux | grep [app_name] | awk &quot;&#123;print \$6&#125;&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或持续监控</span></span><br><span class="line">top -p [pid] -b &gt; mem_trend.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析趋势</span></span><br><span class="line"><span class="built_in">tail</span> -20 mem_trend.log | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 如果数字持续增长 → 内存泄漏</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：查看内存详情</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的峰值内存</span></span><br><span class="line"><span class="built_in">cat</span> /proc/[pid]/status | grep -E <span class="string">&quot;VmPeak|VmHWM|VmRSS&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VmPeak: 进程用过的最大虚拟内存</span></span><br><span class="line"><span class="comment"># VmHWM:  进程用过的最大物理内存</span></span><br><span class="line"><span class="comment"># VmRSS:  当前实际物理内存</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：Java应用分析</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出堆转储</span></span><br><span class="line">jmap -dump:live,format=b,file=heap.dump [pid]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看大对象</span></span><br><span class="line">jcmd [pid] GC.class_histogram | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用</span></span><br><span class="line">jmap -heap [pid]</span><br></pre></td></tr></table></figure>

<p><strong>第四步：Python&#x2F;C应用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">pip install memory_profiler</span><br><span class="line">python -m memory_profiler app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># C应用</span></span><br><span class="line">valgrind --leak-check=full ./app</span><br></pre></td></tr></table></figure>

<p><strong>临时解决方案</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 增加交换空间（临时缓冲）</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1G count=4</span><br><span class="line"><span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定时重启应用</span></span><br><span class="line">crontab -e</span><br><span class="line">0 2 * * * systemctl restart app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置内存限制</span></span><br><span class="line"><span class="comment"># 编辑systemd配置</span></span><br><span class="line">vi /etc/systemd/system/app.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">MemoryLimit=2G</span><br><span class="line">MemoryAccounting=<span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart app</span><br></pre></td></tr></table></figure>

<p><strong>长期解决方案</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 代码审查 - 找泄漏点</span></span><br><span class="line"><span class="comment"># Java常见问题：</span></span><br><span class="line"><span class="comment">#   - 静态集合未清空</span></span><br><span class="line"><span class="comment">#   - 监听器未移除</span></span><br><span class="line"><span class="comment">#   - ThreadLocal未释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启用GC日志</span></span><br><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">&quot;-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/var/log/gc.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 堆内存参数优化</span></span><br><span class="line">-Xms1024m -Xmx2048m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 建立监控告警</span></span><br><span class="line"><span class="comment"># Prometheus + Grafana</span></span><br><span class="line"><span class="comment"># 当内存 &gt; 85% 时告警</span></span><br></pre></td></tr></table></figure>

<h6 id="网络压力过大"><a href="#网络压力过大" class="headerlink" title="网络压力过大"></a>网络压力过大</h6><p><strong>现象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络流量激增 → 应用响应慢 → 系统卡顿</span><br></pre></td></tr></table></figure>

<p><strong>排查思路 + 命令</strong></p>
<p><strong>第一步：确认网络异常</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时查看流量</span></span><br><span class="line">nload -u h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看连接数</span></span><br><span class="line">netstat -i | grep eth0</span><br><span class="line">ss -tan | grep ESTABLISHED | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看丢包</span></span><br><span class="line">netstat -s | grep -E <span class="string">&quot;dropped|errors&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：定位异常流量来源</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看客户端IP分布</span></span><br><span class="line">netstat -an | grep ESTABLISHED | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d: -f1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment">#   1000 192.168.1.1  ← 某个IP连接特别多 → DDoS迹象</span></span><br><span class="line"><span class="comment">#    500 10.0.0.5</span></span><br><span class="line"><span class="comment">#    300 203.0.113.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓包分析</span></span><br><span class="line">tcpdump -i eth0 -w traffic.pcap host 192.168.1.1 -c 100</span><br><span class="line">tcpdump -r traffic.pcap | <span class="built_in">head</span> -20</span><br><span class="line"><span class="comment"># 都是SYN包 → SYN flood</span></span><br><span class="line"><span class="comment"># 都是HTTP → 恶意爬虫</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：找出占用网络最多的进程</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的连接数</span></span><br><span class="line">netstat -tulnp | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="built_in">cut</span> -d/ -f2 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment">#   200 nginx       ← nginx占用最多</span></span><br><span class="line"><span class="comment">#   150 java</span></span><br><span class="line"><span class="comment">#    50 mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<p><strong>① iptables限流</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制单个IP的并发连接数</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 50 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制请求频率（每秒10个请求）</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/second --limit-burst 20 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制特定网段（10分钟内最多100个连接）</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --<span class="built_in">set</span> --name http_limit</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --update --seconds 600 --hitcount 100 --name http_limit -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝特定IP</span></span><br><span class="line">iptables -A INPUT -s 192.168.1.1 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>

<p><strong>② firewalld限流</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拒绝恶意IP</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.1&quot; reject&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制特定网段访问频率</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;0.0.0.0/0&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; limit value=&quot;10/m&quot; accept&#x27;</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-rich-rules</span><br></pre></td></tr></table></figure>

<p><strong>③ Nginx应用层限流</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=one burst=<span class="number">20</span> nodelay;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>④ TCP参数优化</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=8192</span><br><span class="line">sysctl -w net.core.somaxconn=32768</span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout=30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久生效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_max_syn_backlog=8192&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<p><strong>⑤ 扩容&#x2F;弹性伸缩</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是合法流量激增：</span></span><br><span class="line"><span class="comment"># - 立即增加服务器（垂直扩展或水平扩展）</span></span><br><span class="line"><span class="comment"># - Kubernetes自动扩展：HPA (Horizontal Pod Autoscaler)</span></span><br><span class="line"><span class="comment"># - 云厂商自动扩展：Auto Scaling Group</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时扩容示例（Docker）</span></span><br><span class="line">docker run -d --name nginx2 -p 8081:80 nginx</span><br><span class="line"><span class="comment"># 更新负载均衡器指向两个实例</span></span><br></pre></td></tr></table></figure>

<p><strong>事后处理</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 分析日志找规律</span></span><br><span class="line"><span class="built_in">tail</span> -10000 /var/log/nginx/access.log | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 统计访问路径</span></span><br><span class="line"><span class="built_in">tail</span> -10000 /var/log/nginx/access.log | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 复盘总结</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;事件时间: 2024-12-14 14:00-15:30&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;表现: 流量激增10倍，应用响应慢&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;根因: IP 192.168.1.1 发起攻击&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;处理: 用iptables限流，10分钟恢复&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;预案: 建立自动化限流规则，提高告警阈值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 优化策略</span></span><br><span class="line"><span class="comment"># - 增加CDN缓存（减少源站压力）</span></span><br><span class="line"><span class="comment"># - 启用WAF（防火墙规则）</span></span><br><span class="line"><span class="comment"># - 优化应用性能（减少响应时间）</span></span><br><span class="line"><span class="comment"># - 建立自动扩展（应对突发流量）</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2、应用服务"><a href="#2、应用服务" class="headerlink" title="2、应用服务"></a>2、应用服务</h4><p><strong>企业通用架构如下：</strong></p>
<p><img src="/./imgs/image-20251211152818758.png" alt="image-20251211152818758"></p>
<h5 id="（1）LVS-keepalived-Nginx-体系"><a href="#（1）LVS-keepalived-Nginx-体系" class="headerlink" title="（1）LVS + keepalived + Nginx 体系"></a>（1）LVS + keepalived + Nginx 体系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#####从运维角度来看</span><br><span class="line">这部分属于&quot;前端&quot;，一般作为门户入口，提供外网---》内网 通讯，中间会进行内外网映射。</span><br><span class="line">从外网---》内网的区域，分为以下部分</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251211152831594.png" alt="image-20251211152831594"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">话术：</span><br><span class="line">用户访问到我们内网前，会先经过前端的一个<span class="string">&quot;缓存区域&quot;</span>,一般会使用CDN技术（内容分发网络），其实就是做了一个前端缓存服务器，这个是一套完整的系统，对于我们运维来说，只需要申请CDN的资源，需要校对缓存区需要存储的图片、文件，做好流量监控与流量的数据抓取分析。</span><br><span class="line">CDN的基本原理如下图</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251211152843532.png" alt="image-20251211152843532"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">运维的工作（CDN）：</span><br><span class="line">申请CDN 资源（云上），把数据与前端对接好，明确要对哪些数据进行CDN加速处理就可以了，后续要跟进监控（流量），抓取数据进行分析</span><br><span class="line">如果CDN没有命中数据，那么则会进入到企业内网，到达LVS+keepliaved（线下）或者到达SLB(云上)</span><br><span class="line">技术栈：</span><br><span class="line">CDN 加速 + LVS+keepalived（云上SLB） + Nginx（动静分离+反向代理）</span><br><span class="line">分解：</span><br><span class="line">LVS+keepalived : </span><br><span class="line">   ① LVS有哪些类型?（直接路由、NAT、⭐DR）</span><br><span class="line">   ② 为什么用LVS + keepalived ？（这里问了2个问题---第一个问题是 为什么使用LVS 做LB 第二个问题是为什么使用LVS + KEEPALIVED） </span><br><span class="line">   提示：这个时候各位需要想到: LVS NGINX haproxy SLB区别</span><br><span class="line">   答：因为但以负载均衡能力来看，LVS是远超于Nginx 的，Nginx（稳定抗高并发能力，大约为20W左右），而我们业务的“日活”量可能超过1 5w，并发流量大约会达到25~30w，甚至更多</span><br><span class="line">      lvs+keepalived ： 做主备容灾，避免单点故障，更重要的原因是，LVS 自己是L4层的代理无法很好的实现L7层代理，一般配合keepalived做L7层，并且keepalived 还有健康检查机制。</span><br><span class="line"></span><br><span class="line">keepalived 什么协议？怎么进行健康检查？怎么实现高可用的？</span><br><span class="line">   答：ICMP协议实现健康检查 VRRP协议实现高可用</span><br><span class="line">   高可用具体怎么实现的？基本原理是啥？</span><br><span class="line">   使用VIP作为外部访问的IP地址 优先级 VIP（虚拟IP。只会存在于优先级最高的节点） 热备组（主-备关系） VIP漂移机制 kp节点宕机，优先级下降，触发VIP漂移 </span><br><span class="line"></span><br><span class="line">Nginx（动静分离+反向代理）</span><br><span class="line"> Nginx 怎么实现动静分离？</span><br><span class="line"> 通过监听80/443端口，匹配URL访问的入口（进入对应的server &#123;&#125;区域），匹配server中的location ，如果是静态请求，则自己处理，如果是动态请求，则反向跳转到后端的应用/业务服务器上进行处理</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">##### Nginx 面试题 </span></span><br><span class="line">⭐⭐1、你们的Nginx 做过哪些优化？？</span><br><span class="line">在介绍的过程中，Nginx的使用</span><br><span class="line">- 安全加固（隐藏版本号、运行权限最小化user nginx nginx）</span><br><span class="line">- 性能优化（配置缓存expires、压缩Gzip、超时 KeepAlive、进程数worker_processes）</span><br><span class="line">- 资源保护（防盗链）</span><br><span class="line">- 日志管理（定期切割清理）</span><br><span class="line"></span><br><span class="line">⭐2、Nginx 怎么做反向代理的？？怎么做负载均衡的？？Nginx 有哪些负载均衡的算法？</span><br><span class="line">答：静态资源由nginx直接处理后返回，动态资源由 Nginx 将请求转发给后端的服务器（如 Tomcat、Python、PHP）。</span><br><span class="line">配置http中的upstream后端地址池，server中的proxy_pass</span><br><span class="line"><span class="comment"># 负载均衡算法</span></span><br><span class="line">轮询 (Round Robin - 默认)： 每个请求按时间顺序逐一分配到不同服务器。</span><br><span class="line">加权轮询 (Weight)： 指定轮询几率，权重越高，分配到的请求越多（用于服务器性能不均的场景）。</span><br><span class="line">IP Hash (ip_hash)： 根据客户端 IP 的 Hash 结果分配，确保同一客户端始终访问同一台后端服务器（解决 Session 保持问题）。</span><br><span class="line">最少连接 (least_conn)： 将请求分配到当前活动连接数最少的服务器（适合后端处理时间长短不一的场景）。</span><br><span class="line"></span><br><span class="line">⭐3、你们管理Nginx 遇到过哪些故障？？怎么处理的？？？（准备2个有价值的，不要写在搭建过程中遇到的故障）</span><br><span class="line"><span class="comment"># 案例 1：大量 504 Gateway Timeout（上游超时故障）</span></span><br><span class="line">现象： 业务高峰期，前端页面频繁出现 504 错误，监控显示 Nginx 负载不高，但后端业务响应变慢。</span><br><span class="line">排查思路：</span><br><span class="line">查日志： <span class="built_in">tail</span> -f /var/log/nginx/error.log。发现大量 upstream timed out (110: Connection timed out) <span class="keyword">while</span> reading response header from upstream。</span><br><span class="line">看连接： 使用 netstat -ant | grep TIME_WAIT | <span class="built_in">wc</span> -l 发现大量连接处于等待状态。</span><br><span class="line">因果分析： 504 通常意味着 Nginx 等待后端（如 PHP-FPM 或 Java）响应超时。由于后端数据库慢查询，导致请求堆积，超出了 Nginx 预设的 proxy_read_timeout。</span><br><span class="line">解决方案：</span><br><span class="line">临时避险： 适当调大 proxy_read_timeout 和 proxy_connect_timeout，缓解报错。</span><br><span class="line">核心治理： 配合研发优化后端接口耗时和数据库索引；在 Nginx 端开启 Keepalive，保持与后端长连接，减少频繁握手的开销。</span><br><span class="line"><span class="comment"># 案例 2：大量 502 Bad Gateway（后端服务崩溃或配置冲突）</span></span><br><span class="line">现象： 网站瞬间无法访问，报错 502。</span><br><span class="line">排查思路：</span><br><span class="line">检查后端状态： 首先确认后端服务（如 Tomcat）是否存活。发现后端存活，但 Nginx 依然报错。</span><br><span class="line">检查文件句柄： 查看内核日志 dmesg 发现 TCP: possible SYN flooding on port 80. Sending cookies. 且 Nginx 报错 open() ... failed (24: Too many open files)。</span><br><span class="line">因果分析： 高并发下，Linux 系统默认的**文件描述符上限（Limit）**太低，导致 Nginx 无法建立新连接。</span><br><span class="line">解决方案：</span><br><span class="line">系统级： 修改 /etc/security/limits.conf，将 soft nofile 和 hard nofile 调至 65535。</span><br><span class="line">Nginx 级： 在全局配置中设置 worker_rlimit_nofile 65535;。</span><br><span class="line">重载配置： nginx -s reload。</span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">502 找 Nginx 和后端之间的连通性： “后端挂了”、“防火墙拦截”或“连接数满了”。</span><br><span class="line">504 找后端业务的处理速度： “后端太慢了”、“数据库慢查询”或“程序死锁”。</span><br><span class="line"></span><br><span class="line">⭐4、20x、30x、40x、50x 这些Nginx状态码代表的是什么意思? ⭐跟进问几个状态码 ： 404 301/302 502（bad gateway） 403 </span><br><span class="line">- **2xx（成功）**：请求成功处理</span><br><span class="line">- **3xx（重定向）**：需要进一步操作完成请求</span><br><span class="line">- **4xx（客户端错误）**：请求有问题，服务器拒绝处理</span><br><span class="line">- **5xx（服务器错误）**：服务器处理请求时出错</span><br><span class="line">404 Not Found 资源不存在/权限</span><br><span class="line">403 Forbidden 禁止访问（无权限）</span><br><span class="line">301 Moved Permanently 永久重定向（如HTTP→HTTPS）</span><br><span class="line">302 Found 临时重定向（登录后重定向到首页）</span><br><span class="line">502 Bad Gateway 网关错误（反向代理后端出错）</span><br><span class="line"></span><br><span class="line">5、nginx、 haproxy 、lvs 、SLB区别是什么?</span><br><span class="line">LVS (Linux Virtual Server): 它是 Linux 内核的一部分（四层）。它不看你的 HTTP 请求内容，只看 IP+端口。因为不需要解析复杂的协议头，所以它的处理速度最快，是承载海量流量的“大门”。</span><br><span class="line">HAProxy: 它比 Nginx 更纯粹地专注于“负载均衡”。在高并发下，它的稳定性比 Nginx 略好，且健康检查机制（探测后端服务器死活）非常精准。</span><br><span class="line">Nginx: 虽然也做负载均衡（七层），但它更多被当作 Web 服务器使用。它最强大的地方在于处理 HTTP 协议细节，比如重写 URL、压缩图片、灰度发布等灵活配置。</span><br><span class="line">SLB (Server Load Balancer): 这不是一个开源软件，而是公有云的产品（通常底层是由 LVS + Tengine/Nginx 封装的）。它最大的特点是免运维，自带跨可用区高可用，能自动对接云服务器的增减。</span><br><span class="line">总结：</span><br><span class="line">LVS 做最前端的流量分发（抗压），Nginx/HAProxy 做具体的业务调度（精细），而 SLB 是在云环境下为了省事和高可用直接购买的交钥匙方案。</span><br><span class="line"></span><br><span class="line">⭐6、你们业务的平均吞吐量多少？平时在线流量多少，高并发时期流量大概多少，以及你们的nginx 怎么配置的？？（这个配置的效果是什么）</span><br><span class="line">（nginx 怎么应对高并发、nginx 平时做了哪些策略来应对流量正常访问、流量激增等场景---弹性伸缩、负载均衡、流量管控、限流降低等策略）</span><br><span class="line">答：</span><br><span class="line">平均吞吐量（QPS/TPS）： 平时业务大约在 500 - 2,000 QPS。</span><br><span class="line">平时在线流量： 日活跃用户 (DAU) 约 10万 - 50万，峰值带宽占用约 200Mbps - 500Mbps。</span><br><span class="line">高并发时期（如大促、活动）： 流量会激增 5 - 10 倍，QPS 达到 10,000 - 20,000+。</span><br><span class="line"><span class="comment"># Nginx 如何配置应对高并发？</span></span><br><span class="line">Nginx 的优化通常分为系统层优化、性能参数调优和高可用策略。</span><br><span class="line">A. 性能参数调优（榨干硬件性能）</span><br><span class="line">worker_processes  auto;      <span class="comment"># 自动根据 CPU 核数启动进程</span></span><br><span class="line">worker_cpu_affinity auto;    <span class="comment"># 将进程绑定到特定 CPU 核，减少上下文切换</span></span><br><span class="line">worker_rlimit_nofile 65535;  <span class="comment"># 突破系统文件描述符限制</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  10240; <span class="comment"># 单个进程允许的最大连接数</span></span><br><span class="line">    use epoll;                 <span class="comment"># 使用 epoll 事件模型（Linux 下最高效）</span></span><br><span class="line">    multi_accept on;           <span class="comment"># 允许一次性接受多个新连接</span></span><br><span class="line">&#125;</span><br><span class="line">配置效果： 确保 Nginx 能够充分利用多核 CPU，且在高并发连接涌入时，不会因为“文件句柄不足”或“排队严重”导致丢包。</span><br><span class="line"></span><br><span class="line">B. 开启长连接（Keepalive）</span><br><span class="line">http &#123;</span><br><span class="line">    keepalive_timeout 65;       <span class="comment"># 客户端长连接超时时间</span></span><br><span class="line">    keepalive_requests 1000;    <span class="comment"># 一个长连接最多允许的请求数</span></span><br><span class="line">    </span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 192.168.1.10:8080;</span><br><span class="line">        keepalive 32;           <span class="comment"># Nginx 与后端服务器保持的长连接数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">配置效果： 减少 TCP 三次握手和四次挥手的频率，显著降低 CPU 消耗和响应延迟。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应对流量正常与激增的策略</span></span><br><span class="line">1. 负载均衡策略（平时流量分配）</span><br><span class="line">轮询/加权轮询： 平时最常用，按比例分配给后端。</span><br><span class="line">Least_conn： 优先发给连接数最少的服务器，适合后端处理能力不一的情况。</span><br><span class="line">Ip_hash： 解决 Session 保持问题。</span><br><span class="line">2. 限流降级（激增流量管控）</span><br><span class="line">当流量超过后端承载能力时，必须在 Nginx 层“挡住”多余请求，防止后端数据库宕机。</span><br><span class="line"><span class="comment"># 定义限流区域，每秒只允许 10 个请求</span></span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=mylimit:10m rate=10r/s;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        <span class="comment"># 允许突发 5 个请求，不延迟处理</span></span><br><span class="line">        limit_req zone=mylimit burst=5 nodelay; </span><br><span class="line">        error_page 503 = @fallback; <span class="comment"># 触发限流后降级处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">配置效果： 即使受到恶意刷票或流量瞬间暴涨，系统也能以预设的速度处理请求，超出的部分直接返回 503 或跳转到静态降级页面。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动静分离与缓存</span></span><br><span class="line">策略： 所有的图片、JS、CSS 静态资源由 Nginx 直接读取磁盘或推送到 CDN。</span><br><span class="line">效果： 减少 70% 以上的请求到达后端 Tomcat/PHP，极大地释放了计算资源。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合 K8S 的弹性伸缩 (HPA)</span></span><br><span class="line">话术： “单纯靠 Nginx 调优是有上限的。在实际生产中，我们会配合 K8S 的 HPA (Horizontal Pod Autoscaler)：</span><br><span class="line">监控触发： 当 Prometheus 监测到 Pod 的 CPU 使用率超过 60% 或并发连接数达到阈值。</span><br><span class="line">自动扩容： K8S 会自动启动更多副本。</span><br><span class="line">动态发现： Nginx (或 Ingress Controller) 会通过 Service 自动感知新加入的 Pod 节点，并将流量瞬间分摊出去。</span><br><span class="line">缩容： 流量高峰过后，自动回收资源节省成本。”</span><br><span class="line"></span><br><span class="line"><span class="comment">#####实际场景问题：</span></span><br><span class="line">1、客户反馈/监控观测到，页面报错了返回码是xxx，怎么处理(F12)</span><br><span class="line">2、客户反馈/监控观测到，能看到页面，但图片读不出来，怎么处理</span><br><span class="line">3、客户反馈/监控观测到，文件的下载渠道首先下载缓慢，然后直接失败，怎么处理</span><br><span class="line">4、客户反馈/监控观测到，页面账号的数据和实际的数据不一致，是什么情况，怎么处理</span><br><span class="line">5、我想在代理给后端时，显示真实IP怎么做？（小概率）</span><br><span class="line">问到的话，直接说：在匹配proxy_pass 跳转的时候，添加配置，把转发给后端地址池的源IP，改位客户IP就可以</span><br><span class="line">6、你们使用过Nginx的哪些模块？</span><br><span class="line">worker_processes （工作进程数）</span><br><span class="line">events： 事件（事件驱动模块）</span><br><span class="line">http/https </span><br><span class="line">ngx_http_charset_module: （字符集）</span><br><span class="line">gzip_module（gzip压缩模块）</span><br><span class="line">log_module（日志访问记录）</span><br><span class="line">proxy_module （反向代理模块）</span><br><span class="line">rewrite_module （rewrite模块）</span><br><span class="line">ssl_module （SSL证书加密模块）</span><br><span class="line">PS：注意：Server &#123;&#125; global全局配置 不是模块，它是区域</span><br></pre></td></tr></table></figure>

<h5 id="（2）Spring-cloud-boot-微服务"><a href="#（2）Spring-cloud-boot-微服务" class="headerlink" title="（2）Spring cloud&#x2F;boot 微服务"></a>（2）Spring cloud&#x2F;boot 微服务</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">走话术，nginx 反向代理给后端----》微服务gateway api 网关 ---》AUTH认证 ----》 找到nacos 注册中心 ---》运行的Jdk环境---》加载Serverlet 代码（动态任务处理的代码类型）---》根据动态请求,通过JDBC 驱动，调用后端的数据库API（redis / mysql 等等）</span><br><span class="line">简版框架如下：</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251211152901133.png" alt="image-20251211152901133"></p>
<h5 id="（3）中间件缓冲层"><a href="#（3）中间件缓冲层" class="headerlink" title="（3）中间件缓冲层"></a>（3）中间件缓冲层</h5><p><strong>中间件主要由</strong>：Redis 或者MQ（消息队列）组成</p>
<p><strong>Redis 内存缓存型数据库&#x2F;非关系型数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">运维的工作：</span><br><span class="line">1、搭建（短期）Redis 集群（集群模式有几种？你们用的哪个？原理是什么？）</span><br><span class="line">  ① 哨兵 </span><br><span class="line">  ② cluster </span><br><span class="line">  ③ 主从复制</span><br><span class="line">使用哪个??</span><br><span class="line">答： 可以说哨兵，或者说Cluster模式</span><br><span class="line">  哨兵模式：至少6台节点，原理：每个哨兵单独监控redis集群、通过hello频道同步信息，故障时，单个哨兵判断master故障了，会定义为主观下线、多个哨兵判断master故障则定义为客观下线，客观下线后，通过RAFT算法进行选举投票，选择出新master顶上来，然后其他redis集群同步新master位置</span><br><span class="line">  cluster集群模式：至少6个节点，原理:需要奇数数量的master，cluster集群模式让master相互进行健康检查、判断彼此存活性，同时每个master都会有至少1台自己的从服务器，并且实现<span class="string">&quot;主从复制&quot;</span>,当一个master 挂掉了，其他master 也会进行选举，选择出最适合成为新master的slave服务器，同时挂掉的Master也会指定一个自己的slave 服务器来继承slots(哈希槽)。保证集群的完整性。</span><br><span class="line">  PS： slots 哈希槽有16384个（0~16383），哈希槽会平均分配给cluster的每个master，数据通常，是以分布式的方式，存储在master的哈希槽中的。</span><br><span class="line"> </span><br><span class="line">2、Redis 持久化（怎么做？有什么区别？怎么触发的）</span><br><span class="line"> 答：AOF和 RDB</span><br><span class="line">区别？</span><br><span class="line"> AOF 记录写与删的语句</span><br><span class="line"> RDB 相当于快照</span><br><span class="line">Redis 优先会使用AOF 恢复数据，没有的话，使用RDB恢复数据</span><br><span class="line">怎么触发的？</span><br><span class="line"> </span><br><span class="line">3、Redis 常规优化(问的比较少)</span><br><span class="line">①、碎片清理</span><br><span class="line">监控碎片率，超过1.5时执行SHUTDOWN SAVE重启</span><br><span class="line"></span><br><span class="line">⭐②、持久化的压缩、合并、备份删除机制</span><br><span class="line">一、 RDB（快照模式）的机制</span><br><span class="line">RDB 是一次全量数据的二进制压缩备份。</span><br><span class="line">1. 压缩机制 (Compression)</span><br><span class="line">LZF 算法： 默认情况下，Redis 会对 RDB 文件进行 LZF 压缩。</span><br><span class="line">对象压缩： 对于字符串（String），如果长度超过一定阈值，Redis 会尝试将其压缩存储。</span><br><span class="line">配置项： rdbcompression <span class="built_in">yes</span>（建议开启，虽然消耗一点 CPU，但极大地节省磁盘 I/O 和空间）。</span><br><span class="line">2. 备份机制 (Backup)</span><br><span class="line">Copy-On-Write (COW)： 当触发 bgsave 时，Redis 调用 fork() 产生子进程。子进程拥有父进程的内存快照。</span><br><span class="line">写时复制： 只有在父进程修改内存数据时，才会复制物理内存页。这保证了快照的一致性，且不阻塞主线程。</span><br><span class="line">二、 AOF（日志追加模式）的机制</span><br><span class="line">AOF 记录的是每一条写命令。随着时间推移，文件会变得非常臃肿，因此需要“合并”机制，即 AOF 重写 (Rewrite)。</span><br><span class="line">1. 合并机制 (AOF Rewrite)</span><br><span class="line">原理： 重写并不读取旧的 AOF 文件，而是读取当前的内存数据库状态。</span><br><span class="line">示例： 如果你对一个计数器 INCR 了 100 次，旧 AOF 有 100 行记录，重写后的 AOF 只需一条 SET counter 100。</span><br><span class="line">触发条件：</span><br><span class="line">auto-aof-rewrite-percentage 100（当前文件比上次重写后增长了 100%）。</span><br><span class="line">auto-aof-rewrite-min-size 64mb（文件至少达到 64MB）。</span><br><span class="line">2. 压缩与混合持久化 (Hybrid Persistence)</span><br><span class="line">混合模式： 在 Redis 4.0 之后，通常开启 aof-use-rdb-preamble <span class="built_in">yes</span>。</span><br><span class="line">效果： AOF 文件的前半部分是 RDB 格式的二进制数据（压缩率极高），后半部分是重写期间产生的增量 AOF 命令（纯文本）。这兼顾了加载速度和数据完整性。</span><br><span class="line">三、 备份与删除策略 (Backup &amp; Deletion)</span><br><span class="line">Redis 自身不负责历史备份的管理和旧文件的自动删除，这通常需要运维配合脚本完成。</span><br><span class="line">1. 备份策略 (The Industry Standard)</span><br><span class="line">RDB 定期备份： * 每小时备份一次最近的 RDB，存放在本地不同目录。</span><br><span class="line">每天备份一次 RDB，同步到远端对象存储（如阿里云 OSS、AWS S3）。</span><br><span class="line">AOF 备份： 由于 AOF 实时增长，通常只在重写完成后备份最新的 AOF 副本。</span><br><span class="line">2. 删除机制 (Retention)</span><br><span class="line">由于 Redis 持久化文件（尤其是 AOF）可能撑爆磁盘，运维通常采用以下手段：</span><br><span class="line">定时清理： 使用 find 命令结合 cron 任务。</span><br><span class="line"><span class="comment"># 删除 7 天前的备份文件</span></span><br><span class="line">find /data/redis/backup/ -name <span class="string">&quot;*.rdb&quot;</span> -mtime +7 -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;</span><br><span class="line">磁盘空间报警： 配合监控（Prometheus/Zabbix）监控 /var/lib/redis 所在分区的 <span class="built_in">df</span> 使用率。</span><br><span class="line"></span><br><span class="line">⭐③、过期删除与淘汰策略</span><br><span class="line">根据场景选择合适的淘汰策略（缓存场景推荐allkeys-lru）</span><br><span class="line">当Redis内存达到`maxmemory`限制时，触发淘汰策略：</span><br><span class="line">noeviction      禁止删除，满时报错（**严格场景**）    </span><br><span class="line">allkeys-lru     删除最少使用的key（**缓存场景推荐**） </span><br><span class="line">volatile-lru    仅在设置TTL的key中删除最少使用        </span><br><span class="line">volatile-ttl    删除剩余生存时间最短的key             </span><br><span class="line">allkeys-random  随机删除任意key                       </span><br><span class="line">⭐④、为了减少缓存穿透、缓存击穿、雪崩的常见故障的发生概率，做的对应优化策略</span><br><span class="line">1.根据数据量合理规划实例大小：保证物理内存 &gt; Redis最大使用内存，一般建议不超过70-80%</span><br><span class="line">2.使用Hash结构存储：Redis对小Hash结构有优化（压缩存储）</span><br><span class="line">3.设置key的过期时间(TTL)</span><br><span class="line">4.合理设置maxmemory</span><br><span class="line">5.关闭或限制swap</span><br></pre></td></tr></table></figure>

<p><strong>MySQL 关系型数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">运维工作：</span><br><span class="line">1、搭建（短期）</span><br><span class="line">① 搭建单台</span><br><span class="line">② 搭建集群（主从复制、读写分离--一般由开发完成、高可用--MHA MM+keepalived ）</span><br><span class="line">  主从复制原理：2日志 3线程，原理如下：</span><br><span class="line"> 两日志：主-二进制日志</span><br><span class="line">      从-中继日志</span><br><span class="line"> 三线程：</span><br><span class="line">    ① 主-dump线程，把二进制日志中更新的部分推送给I/O线程</span><br><span class="line">    ② 从-I/O线程：</span><br><span class="line">      第一，负责监听主-二进制日志，一旦发生更新，I/O会通知dump线程，传输SQL语句到从服务器</span><br><span class="line">      第二：I/O 线程会负责把更新的二进制的内容，同步写入到自己（从服务器）的中继日志中 </span><br><span class="line">    ③ 从-SQL线程</span><br><span class="line">      负责把中继日志中的SQL语句，在自己数据库内跑一边</span><br><span class="line">简单话术:</span><br><span class="line">两日志三线程，主节点发数更新，从节点I/O会同步主节点二进制日志内容到本地中继日志中，然后SQL线程把中继日志中SQL语句，写入到自己数据库内部</span><br><span class="line">   追加面试题：MySQL 主从复制日志记录模式有几种？默认哪个？（基于SQL 基于row 基于mixed（混合）），主从复制的处理类型（异步、全同步、半同步）</span><br><span class="line">   ⭐可能会追加，怎么做的：</span><br><span class="line">       答：启动主库二进制日志，开启从库复制同步，设置serverid等</span><br><span class="line">       创建从库访问用户给予权限</span><br><span class="line">       启动从库的中继日志，设置serverid</span><br><span class="line">       从库连接主库并配置同步位置等</span><br><span class="line">       启动并验证</span><br><span class="line">  读写分离原理：主--》负责写任务 从--》读任务，客户端访问读写分离的代理，代理服务器，会根据后端数据库池，将读写任务交给后端的mysql服务器进行处理</span><br><span class="line">  </span><br><span class="line">  MHA 高可用原理：</span><br><span class="line">  MHA 自动监控Master，故障时找最新的Slave提升为Master，同时转移VIP，应用无感知自动转移，10-30秒完成。</span><br><span class="line">  MHA 怎么搭建的：  </span><br><span class="line">1. 基础配置 | 关闭防火墙，安装MySQL 5.7                                    </span><br><span class="line">2. 一主两从 | 配置主从复制（Master-Slave1-Slave2）（配置my.cnf⭐，grant给予slave，mha权限） </span><br><span class="line">3. 安装MHA  | 安装node和manager组件                                        </span><br><span class="line">4. SSH认证  | 配置各节点间无密码认证                                       </span><br><span class="line">5. MHA配置  | 复制管理脚本，配置failover脚本和app1.cnf，在配置文件中指定   </span><br><span class="line">6. 启动监控 | 启动MHA manager进程                                          </span><br><span class="line">7. 故障测试 | 模拟故障验证自动切换                                         </span><br><span class="line"></span><br><span class="line">③ 容灾备份</span><br><span class="line">  mysql集群，备份一套在其他的机房中（可用区），并持续进行数据同步</span><br><span class="line">  也可以使用DTS（云产品）将本地数据库同步给云上数据库</span><br><span class="line">2、SQL管理（增删改查）</span><br><span class="line"> ① 增：create、insert</span><br><span class="line"> ② 删：drop、delete、<span class="built_in">truncate</span></span><br><span class="line"> ③ 改：alter update </span><br><span class="line"> ④ 查：<span class="keyword">select</span> desc</span><br><span class="line">⭐⭐⭐SQL操作中的<span class="keyword">select</span> 查询语句</span><br><span class="line">① 查询指定库.表中xx字段等于xx值的表内容 </span><br><span class="line">② 子查询、內连查询语句、外连查询、左连接右连接查询语句、多表联合查询的语句（条件判断），会问具体的sql、也会问子查询和外连接有什么区别这类问题</span><br><span class="line">   查询语句的结构中，可以在多表相连的条件判断语句中，给每个表定义别名，然后再分组，order by 然后进行<span class="built_in">where</span> 条件判断查询，这个面试题主要是把查询语句的结构要整明白，可以使用以下方式表示结构关系：</span><br><span class="line"> （<span class="keyword">select</span> 字段名/* from a库名.a表 inner <span class="built_in">join</span> b库.b表 <span class="built_in">where</span> a表字段=b表字段）</span><br><span class="line"></span><br><span class="line">3、MySQL优化</span><br><span class="line"> ① SQL语句优化</span><br><span class="line">  可以先使用慢“⭐查询日志”筛选出需要进行优化的语句，explain 校对一下SQL语句有哪些部分可以进行优化（修改查询条件、添加索引、添加一些组合查询的方式等）</span><br><span class="line">  索引类型：主键、唯一、组合、全文、外键</span><br><span class="line">  创建索引依据：</span><br><span class="line">粗略的小结（主要用于给各位回答面试题时的过渡性介绍）</span><br><span class="line">一般情况：① 频繁使用且唯一性较高、更新频次较低的字段，适合添加索引 ② 唯一性弱、更新频繁的字段不要增加索引</span><br><span class="line"> ② 线程/线程池优化</span><br><span class="line"> ③ 日志管理优化，（异步、半同步、同步---对应场景）、日志轮转</span><br><span class="line"> ④ mysql服务器的系统资源优化</span><br><span class="line"> ⑤ 权限优化</span><br><span class="line">⭐⭐⑥ 系统内核优化</span><br><span class="line">⭐⭐⑦ 慢查询语句的优化</span><br><span class="line">⭐⭐⑧ 索引优化</span><br><span class="line">⭐explain 检测一个语句执行过程，索引、查看是否需要使用其他的存储引擎(优化sql语句),线程池的优化（具体的执行语句）</span><br><span class="line">4、定期备份和恢复 </span><br><span class="line">备份类型：物理/逻辑备份 --》备份的方式： 全备、增备、差备 --》备份工具：mysqldump 全量、日志备份mysqlbinlog 增备</span><br><span class="line">5、故障处理 </span><br><span class="line">至少准备2个（不要是搭建过程中的，要有排查过程，PS：各位可以使用我给的故障文档，然后让工具给各位输出5个生产故障）</span><br><span class="line">【故障1：查询超慢导致应用响应慢】</span><br><span class="line">现象：下单接口响应从100ms飙升到3s</span><br><span class="line">排查：</span><br><span class="line">  1. 确认是DB问题（processlist查看连接数)</span><br><span class="line">  2. 查慢查询日志找出具体SQL</span><br><span class="line">  3. EXPLAIN分析发现全表扫描</span><br><span class="line">  4. 发现缺少索引</span><br><span class="line">解决：</span><br><span class="line">  1. 立即杀死慢查询（缓解症状）</span><br><span class="line">  2. 创建索引idx_date_status(<span class="built_in">date</span>,status)</span><br><span class="line">  3. 修改应用逻辑只查需要的列</span><br><span class="line">学到：</span><br><span class="line">  - 新增查询字段必须同时创建索引</span><br><span class="line">  - 定期审查慢查询日志</span><br><span class="line">  - 建立SQL审查流程</span><br><span class="line"></span><br><span class="line">【故障2：主从复制中断】</span><br><span class="line">现象：Slave一直没在同步，Slave_IO_Running=No</span><br><span class="line">排查：</span><br><span class="line">  1. SHOW SLAVE STATUS查看错误</span><br><span class="line">  2. 发现复制用户认证失败</span><br><span class="line">  3. 检查Master上repl用户权限</span><br><span class="line">  4. 发现Master重启后权限未生效</span><br><span class="line">解决：</span><br><span class="line">  1. Master上执行FLUSH PRIVILEGES</span><br><span class="line">  2. Slave上STOP SLAVE、START SLAVE</span><br><span class="line">  3. 验证Slave_IO_Running和Slave_SQL_Running都=Yes</span><br><span class="line">优化：</span><br><span class="line">  - 启用GTID自动处理日志位置</span><br><span class="line">  - 添加复制延迟告警</span><br><span class="line">  - Master重启脚本中加入权限刷新步骤</span><br></pre></td></tr></table></figure>

<p><strong>MQ消息队列</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运维工作，主要在于怎么查询Kafka 的topic主题，pattition分区和数据以及如何监控</span><br><span class="line">面试题，会问：</span><br><span class="line"><span class="number">1</span>、你们用过消息队列中间件吗？怎么用的?（问消息队列部署在什么位置，干嘛用的？）--》一般来说使用消息队列的场景，都是数据量比较庞大的场景（看咱们自己的项目业务是否符合）</span><br><span class="line"><span class="number">2</span>、如果回答用过kafka，追问kafka的组件有哪些？？怎么查询topic主题，pattition？</span><br><span class="line"><span class="number">3</span>、你们kafka的生产者和消费者是谁?</span><br></pre></td></tr></table></figure>

<h4 id="3、支持、管理工具"><a href="#3、支持、管理工具" class="headerlink" title="3、支持、管理工具"></a>3、支持、管理工具</h4><p><strong>以下部分，是企业通用的项目架构(主要突出的是“支持、管理工具“ )</strong></p>
<p><img src="/./imgs/image-20251214145249600.png" alt="image-20251214145249600"></p>
<h5 id="1-ELK-体系"><a href="#1-ELK-体系" class="headerlink" title="(1) ELK 体系"></a>(1) ELK 体系</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ELK 日志分析管理系统</span><br><span class="line">采集日志------》处理日志数据----》存储、管理日志数据-----》展示日志数据</span><br><span class="line"></span><br><span class="line">运维工程师的工作：</span><br><span class="line"><span class="number">1</span>、日志分析管理系统的选型与部署</span><br><span class="line"><span class="number">2</span>、索引数据查询（mysql -》 数据库--二维表--记录行 ES -》索引--类型--文档） </span><br><span class="line">  索引怎么查询（test 索引数据）</span><br><span class="line"><span class="number">3</span>、明确采集哪些日志，有的时候，开发、测试、部分客户需要看日志，我们会需要把日志保存出来给到对方</span><br><span class="line"><span class="number">4</span>、kiabana 看一些报错日志，排查故障，包括--》用于写文档（故障文档）</span><br><span class="line">PS: ELK 可能会问到你们使用什么版本的（<span class="number">7.7</span>左右的版本）</span><br></pre></td></tr></table></figure>

<p><strong>ELK 基本架构：</strong></p>
<p><img src="/./imgs/image-20251214145313386.png" alt="image-20251214145313386"></p>
<p><strong>ELK架构选型</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ELK 采集日志---》对于文件日志的采集，主要还是会集成filebeat采集器---》Es + filebeat + logstash + kiabna/GRAFANA 日志采集与分析</span><br><span class="line">ELK 采集容器日志---》 EFK --》 ES + FLUENTED + LOGSTASH + KIBANA/GRAFANA </span><br><span class="line">ELK怎么部署的：</span><br><span class="line">   ① 传统：</span><br><span class="line">     源码安装（tar） </span><br><span class="line">   ② Docker容器：</span><br><span class="line">     容器跑采集器，kibana跑容器中，es放容器外</span><br><span class="line">     PS：业务容器可以选择和fluented 集成，采集和输出日志</span><br><span class="line">   ③ K8S：</span><br><span class="line">     可以选择跑在同一个Pod里面，使用fluented 采集（存储--》emptydir 共享业务容器的日志文件）</span><br><span class="line">   ④ 云：</span><br><span class="line">     例如阿里云：SLS 日志服务（如下图）</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145331322.png" alt="image-20251214145331322"></p>
<p><strong>ELK面试题：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">⭐⭐<span class="number">1</span>、你们用ELK采集哪些日志，怎么采集的？</span><br><span class="line">采集哪些日志？</span><br><span class="line">① 应用程序</span><br><span class="line">② 中间件日志</span><br><span class="line">③ 数据库日志</span><br><span class="line">⑤ 容器日志</span><br><span class="line">⑥ 业务日志 log4j（java）</span><br><span class="line">⑦ 系统日志 syslog</span><br><span class="line">以上，每个类型要说具体的服务具体的日志名称（<span class="number">1</span>-<span class="number">2</span>个）</span><br><span class="line">怎么采集的？一般使用以下方式采集日志</span><br><span class="line">logstash 通用，但不是所有场景都适用</span><br><span class="line">filebeat 采集文件系统的日志</span><br><span class="line">fluented 采集容器的日志</span><br><span class="line">提示：问具体采集哪些日志：可以直接看人家公司产品/阿里云的文档，来描述我们采集哪些日志</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ES 查询索引的语句是什么？</span><br><span class="line">提示：库（索引）、表（类型）、记录行（文档）</span><br><span class="line">索引(Index) = 数据库</span><br><span class="line">类型(Type)  = 表格</span><br><span class="line">文档(Doc)   = 记录行</span><br><span class="line">字段(Field) = 列</span><br><span class="line">常用查询：</span><br><span class="line">- 精确查询：term查询</span><br><span class="line">- 模糊查询：match查询</span><br><span class="line">- 范围查询：range（时间范围）</span><br><span class="line">- 组合查询：bool must/should</span><br><span class="line">- 聚合统计：aggs分组统计</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、一般是组合搭配来问，比如：你们简历项目工作中描述道：K8S日志收集管理---&gt;追问，怎么收集的?怎么管理的？一般看哪些啊？</span><br><span class="line">K8s日志采集</span><br><span class="line">采集：Filebeat DaemonSet（轻量推荐）</span><br><span class="line">存储：Elasticsearch（按日期分索引）</span><br><span class="line">管理：ILM生命周期（热温冷分层）</span><br><span class="line">查询：Kibana仪表板</span><br><span class="line">告警：ERROR日志 &gt; 阈值、存储 &gt; <span class="number">80%</span></span><br><span class="line">答：我们用Filebeat采集K8s日志 → 存到Elasticsearch → 用Kibana查询分析</span><br><span class="line">主要看：ERROR日志数量、各Pod日志分布、响应时间、存储容量。</span><br><span class="line">设置了ILM策略自动清理旧日志，ERROR日志超过阈值会触发告警。</span><br></pre></td></tr></table></figure>

<h5 id="2-监控服务"><a href="#2-监控服务" class="headerlink" title="(2) 监控服务"></a>(2) 监控服务</h5><p><strong>主要是了解：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">运维工程师做传统运维监控的工作：</span><br><span class="line"><span class="number">1</span>、选型监控产品与部署（传统业务-使用zabbix 更多 ）</span><br><span class="line"><span class="number">2</span>、监控哪些对象？指标数据有哪些（SRE <span class="number">4</span>个黄金指标）</span><br><span class="line">延迟(Latency)</span><br><span class="line">   - 处理请求花费的时间</span><br><span class="line">   - 例：API响应时间 &lt; <span class="number">200ms</span></span><br><span class="line">流量(Traffic)</span><br><span class="line">   - 系统处理的请求量</span><br><span class="line">   - 例：QPS、吞吐量(Throughput)</span><br><span class="line">错误率(Errors)</span><br><span class="line">   - 失败请求占比</span><br><span class="line">   - 例：<span class="number">5</span>xx错误率 &lt; <span class="number">0.1%</span></span><br><span class="line">饱和度(Saturation)</span><br><span class="line">   - 资源使用程度</span><br><span class="line">   - 例：CPU &lt; <span class="number">70%</span>、内存 &lt; <span class="number">85%</span></span><br><span class="line"><span class="number">3</span>、数据采集方法有哪些？？（代理插件、脚本、不同协议的相关工具采集--》SNMP TELNET）</span><br><span class="line">Agent（Push推送</span><br><span class="line">Server拉取（Pull）</span><br><span class="line">脚本采集</span><br><span class="line">SNMP</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、zabbix 内部的使用（不讲了）</span><br><span class="line"></span><br><span class="line">zabbix 的工作模式（Server端--<span class="attr">--agent</span>代理端）</span><br><span class="line">⭐ zabbix 和prometheus 区别？</span><br><span class="line">简略提示：zabbix 和prometheus 擅长采集的被监控对象数据是有一定区别的</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>维度</th>
<th>Zabbix</th>
<th>Prometheus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>采集模式</strong></td>
<td>Push推送</td>
<td>Pull拉取</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>传统IDC、混合云</td>
<td>云原生、K8s、微服务</td>
</tr>
<tr>
<td><strong>架构复杂度</strong></td>
<td>中等（Agent+Server+DB）</td>
<td>简单（只需Server）</td>
</tr>
<tr>
<td><strong>数据库</strong></td>
<td>MySQL&#x2F;PostgreSQL</td>
<td>内置时间序列DB</td>
</tr>
<tr>
<td><strong>部署难度</strong></td>
<td>中等（每台机器装Agent）</td>
<td>简单（只部署Server）</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>中等（多Agent管理复杂）</td>
<td>高（服务发现自动）</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>实时推送（秒级）</td>
<td>定时拉取（分钟级）</td>
</tr>
<tr>
<td><strong>历史数据</strong></td>
<td>保留完整</td>
<td>保留有限（需Thanos）</td>
</tr>
<tr>
<td><strong>告警机制</strong></td>
<td>内置强大</td>
<td>需Alertmanager</td>
</tr>
<tr>
<td><strong>学习成本</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>企业级</strong></td>
<td>支持（收费版）</td>
<td>开源（社区）</td>
</tr>
</tbody></table>
<h4 id="4、云原生基础环境"><a href="#4、云原生基础环境" class="headerlink" title="4、云原生基础环境"></a>4、云原生基础环境</h4><h5 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">云计算：用户可以通过网络，获取到需要的计算资源、网络资源、存储资源，特性是：按量计费、弹性伸缩、租赁行为(云平台)</span><br><span class="line"></span><br><span class="line">云计算有几种模式：IAAS、PASS、SAAS （FAAS、MAAS） 如下图<span class="number">1</span></span><br><span class="line">以上是云平台的<span class="number">3</span>种常规的商业模式（基础款）</span><br><span class="line"></span><br><span class="line">云平台部署、管理方式（<span class="number">3</span>种基础）：私有云、公有云、混合云</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145458163.png" alt="image-20251214145458163"></p>
<p><strong>公有云：</strong></p>
<p><img src="/./imgs/image-20251214145511456.png" alt="image-20251214145511456"></p>
<p><strong>私有云：</strong></p>
<p><img src="/./imgs/image-20251214145533875.png" alt="image-20251214145533875"></p>
<p><strong>混合云：</strong> </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种： 私有云+公有云混合</span><br><span class="line">第二种：多个不同的公有云混合（阿里云+华为云 一起使用）</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145550169.png" alt="image-20251214145550169"></p>
<h5 id="虚拟化-容器技术"><a href="#虚拟化-容器技术" class="headerlink" title="虚拟化&#x2F;容器技术"></a>虚拟化&#x2F;容器技术</h5><p>企业常规虚拟化产品（开源）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">虚拟化产品一般作为底座，基础底座技术：IBM公司的产品、XEN、EXSI、KVM、hyper-v</span><br><span class="line">虚拟化产品--》全虚拟化方案（纯使用软件模拟硬件的功能）</span><br><span class="line">            半虚拟化方案（软件+硬件结合实现虚拟化的效果）</span><br><span class="line">            硬件辅助虚拟化技术（主要使用硬件的性能+直接集成在硬件上的软件产品赖完成虚拟化功能）</span><br><span class="line">            轻量级虚拟化技术----》容器</span><br><span class="line">容器技术和虚拟化技术之间区别：</span><br><span class="line">⭐本质：容器是进程级别，共享宿主机内核的，虚拟机技术，完整OS(操作系统)级别，完整的操作系统内核。</span><br><span class="line">区别如图：       </span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145610564.png" alt="image-20251214145610564"></p>
<p><strong>容器技术</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">容器技术有多个不同的类型,市面上常用的类型有：</span><br><span class="line">Docker 、 POSTMAN 、Containerd</span><br><span class="line">这三种容器技术，只会Docker 也可以，但是需要理解容器、镜像的原理</span><br><span class="line"></span><br><span class="line">运维的工作：</span><br><span class="line"><span class="number">1</span>、镜像、容器、存储、监控、<span class="selector-tag">image</span>仓库、日志、网络、多容器编排、故障处理（大类）</span><br><span class="line"><span class="number">2</span>、镜像管理：</span><br><span class="line">   ⭐⭐① 镜像制作 写dockerfile</span><br><span class="line">   ② harbor使用，自动更新（Dockerfile 把镜像写好，推送harbor，然后可以使用ansible 批量更新多个不同的容器节点）</span><br><span class="line"><span class="number">3</span>、容器日志管理（定期清理容器日志--日志轮转） 主要是配置文件限制+ 日志定期清理</span><br><span class="line">  ##日志文件的数量与单个日志文件大小控制</span><br><span class="line">  &quot;log-driver&quot;: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    &quot;max-size&quot;: <span class="string">&quot;500m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;max-file&quot;</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ## 定期清理容器日志（借助Shell + crontab 定期清理日志）</span><br><span class="line"> ## 采集容器日志（EFK ES+FLUENTED+KIBANA）</span><br><span class="line">⭐⭐<span class="number">4</span>、容器的故障处理</span><br><span class="line">docker ps -<span class="selector-tag">a</span>  --》容器的状态是什么类型的异常 --》docker logs -f <span class="attr">--tail</span> <span class="number">1000</span></span><br><span class="line"><span class="number">5</span>、docker-compose 容器编排（Ruo-Yi 前后端分离的VUE项目）</span><br><span class="line">可以使用docker-compose管理多个容器组合的场景（创建并管理一套小型的系统）</span><br><span class="line"><span class="number">6</span>、容器的基本操作</span><br></pre></td></tr></table></figure>

<p><strong>容器面试题：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、docker 常用命令（增删改查）</span><br><span class="line"><span class="number">2</span>、docker -<span class="selector-tag">i</span> -t -d什么意思 </span><br><span class="line"><span class="number">3</span>、dockerfile 有哪些指令，dockerfile内容怎么写的，写过哪些dockerfile </span><br><span class="line"><span class="number">4</span>、dockerfile中cmd 和entrypoint 有什么区别 ，copy和add有什么区别 </span><br><span class="line"><span class="number">5</span>、容器和虚拟化的区别是什么，为什么要用容器？</span><br><span class="line"><span class="number">6</span>、docker的底层原理是什么 </span><br><span class="line"><span class="number">7</span>、docker的工作流程是什么？</span><br><span class="line"><span class="number">8</span>、docker 怎么发布容器到外面 ？引申：-<span class="selector-tag">p</span> -<span class="selector-tag">P</span>区别</span><br><span class="line"><span class="number">9</span>、docker 网络类型有哪些，有什么特性？</span><br><span class="line"><span class="number">10</span>、docker-compose会写么，有没有用过，在哪用的？</span><br><span class="line"><span class="number">11</span>、docker中 怎么把文件传到运行的容器中</span><br><span class="line"><span class="number">12</span>、dockerfile 怎么写，怎么做优化</span><br></pre></td></tr></table></figure>

<h4 id="5、资源管理器"><a href="#5、资源管理器" class="headerlink" title="5、资源管理器"></a>5、资源管理器</h4><p>**容器集群化管理工具：**Messos 、Docker Swarm 、Kubernetes</p>
<p><strong>kuberntes里面跑什么</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K8S 中可以运行所有微服务业务、应用服务、各类的管理系统，除了数据库、中间件（rabbitmq、kafka 等）以及其他极度吃资源的服务/环境，其他都可以跑在K8S中</span><br></pre></td></tr></table></figure>

<p><strong>Kunernets 运维工作</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、kubernetes 搭建:</span><br><span class="line">① 二进制（每个组件进行手工编译安装，然后申请ca证书，对接起来）</span><br><span class="line">② kubeadm （官方推荐的搭建方式）</span><br><span class="line">③ 工具安装：kubesphere 安装（kubesphere安装K8S --》 K9s） </span><br><span class="line">          rancher 安装 （rancher安装K8S--》K3S）</span><br><span class="line">④ 云平台安装：阿里云的ACK （托管版的K8S安装）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Kubernetes 管理</span><br><span class="line">① 围绕 Pod 进行管理（配置、发布、控制器、调度器、存储、L7网络、监控、日志）</span><br><span class="line">② 修改、优化YML文件配置</span><br><span class="line">③ 使用web界面管理K8S平台（rancher）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、平时业务更新、发布、回滚，需要用到K8S，主要的流程是 docker（运行jenkins + gitlab/gitee）+ harbor + K8S +管理平台（rancher、云控制台、kubesphere）完成CI/CD的持续集成持续发布的任务</span><br><span class="line">以及集成其他应用来完成其他综合性的工作，包括：</span><br><span class="line">EFK、prometheus、nacos、持久化层、对接大数据流域的数据仓库、数据分析等、配合使用包含gpu处理的worker节点跑模型类的业务。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、故障处理和日志管理</span><br><span class="line">K8S 故障处理流程：</span><br><span class="line">① kubectl get po -n namespace ---&gt; 查看 pod的status 状态（Pod生命周期状态 -》<span class="number">10</span>几个--》清楚异常状态是怎么导致的，怎么处理）</span><br><span class="line">② kubectl describe [资源类型] [资源对象] -n namespace 查看events 事件 --》根据事件反馈的内容模糊定位问题的方向</span><br><span class="line">③ kubectl logs -f --tail <span class="number">1000</span>  查看日志（或者直接搜索kibana 的信息）</span><br><span class="line">④ 根据具体的业务，当前故障的时间节点，从业务场景角度、系统资源角度、报错的Pod中服务类型的角度，以及从报错现象与提示维度来排查错误</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、prometheus 和efk 监控与日志工作</span><br><span class="line">① 整理、优化监控指标项，日志采集输出的内容合理性，调整监控、日志的输出与展示内容</span><br><span class="line">② 优化维护prometheus 的监控资源文档</span><br><span class="line">③ 优化grafana 图标展示与其他日常工作</span><br><span class="line">④ 根据其他不同部门的需求与业务的实际情况，优化prometheus 监控内容</span><br><span class="line">以上工作是持续完成的</span><br></pre></td></tr></table></figure>

<p><strong>K8S 面试题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">① K8S 核心组件有哪些？每个组件是干嘛的？</span><br><span class="line">② K8S 工作流程是什么？</span><br><span class="line">XXXXX③ K8S 搭建用的是什么方式，你们CNI用的是什么？</span><br><span class="line">④ 你们K8S集群规模大概多大 （1、节点数量-包括master数量和worker数量 2、Pod数量）</span><br><span class="line">⑤ 你们K8S中跑的是什么？</span><br><span class="line">⑥ K8S 云上还是自建（看你们业务）</span><br><span class="line">私有云（） 公有云 混合云 （社区云）</span><br><span class="line">它是一种商业模式</span><br><span class="line">核心：1） 服务器资源归属于哪</span><br><span class="line">     2） 服务方是谁</span><br><span class="line">3个角色： </span><br><span class="line">1） 客户：购买产品的</span><br><span class="line">2） 解决方案提供商：你在的公司（给产品方案的）</span><br><span class="line">3）云厂商：</span><br><span class="line">改一下：私有云、公有云、混合云分别是什么</span><br><span class="line">⑦ K8S 常用命令（简单问）</span><br><span class="line">⑧ 有哪些控制器</span><br><span class="line">⑨ 你们项目中的产品/业务是怎么更新的</span><br><span class="line">答：一套流程（我们拿到开发代码开始，到发布完成整个过程）</span><br><span class="line">10 容器的重启策略、镜像下载策略</span><br><span class="line">11 Pod内有几种容器，分别是做什么的</span><br><span class="line">12 Pod类型有哪些，有什么区别</span><br><span class="line">13、Pod 删除的工作流程是什么</span><br><span class="line">① 参与的组件</span><br><span class="line">② 起始的位置 </span><br><span class="line">③ 过程中相互协作的组件</span><br><span class="line">④ 方向 </span><br><span class="line">⑤ 机制</span><br><span class="line">14、pod 增删改查命令是什么，以Nginx 为例</span><br><span class="line">① 增：创建Ng 、副本集3、暴露80 创建在abc namespace中 控制器的名字为ng-deploy</span><br><span class="line">kubectl create deployment ng-deploy --replicas=3 --image=nginx --port=80 -n abc </span><br><span class="line">② 修改镜像nginx 为1.20 </span><br><span class="line">kubectl set deployment ng-deploy --image=nginx:1.20 -n abc </span><br><span class="line">③ 查询label标签为nginx的所有资源</span><br><span class="line">kubectl get po app=nginx -n abc </span><br><span class="line">④ kubectl delete deployment ng-deploy -n abc </span><br><span class="line">Pod 如何发布的（过程描述）以service 的NodePort 模式为例</span><br><span class="line">16、K8S 更新Pod 方法（滚动、蓝绿、金丝雀/灰度）分别是怎么发布的</span><br><span class="line">关键点：</span><br><span class="line">蓝绿：一半/一半 以更新后正常使用为标准</span><br><span class="line">滚动：定义步长（百分比）以更新成功正常使用为标准</span><br><span class="line">金丝雀：百分比更新，以接入流量后的反馈为标准，持续、谨慎更新</span><br><span class="line"></span><br><span class="line">蓝绿：50%   正常使用标准</span><br><span class="line">滚动：步长 正常使用标准</span><br><span class="line">金丝雀：百分比更新，流量接入，观测反馈，更新</span><br><span class="line">17、K8S Pod资源限制怎么做的，参数是什么？</span><br><span class="line">18、K8S集群的默认驱逐机制中，各个资源的驱逐阈值是多少？</span><br><span class="line">19、Pod 健康检查机制是什么，有哪些（探针）类型，有什么区别</span><br><span class="line">20、Pod 探针的检查方式有哪些</span><br><span class="line">21、钩子的使用作为加分项，在容器创建后，启动前，想插入一端指令或准备一个环境，应该怎么做</span><br><span class="line">22、第一层面试题：直接问调度策略有哪些，怎么做的</span><br><span class="line">23、第二层面试题：给需求，然后让你使用对应的调度策略完成（需求中往往会结合其他的资源对象特性）</span><br><span class="line">24、第三层面试题：实际业务报错场景下，如何排查错误发生的可能性（调度策略相关）</span><br><span class="line">    2个情况：① 面试官给你场景，你来描述排查思路</span><br><span class="line">                   ② 面试官问你，你遇到什么印象深刻的报错情况，如何解决的/你遇到过印象最深刻/严重的故障是什么</span><br><span class="line">25、调度器的默认调度规则/策略是什么？</span><br><span class="line">26、污点和容忍的作用是什么，什么时候会使用污点机制？</span><br><span class="line">PS（调度器相关的组合题）</span><br><span class="line">27、存储类型有哪些，你们用的是什么存储，什么场景使用？</span><br><span class="line">28、Pod的生命周期有哪些（指的是Pod的状态及对应场景）</span><br><span class="line">29、新建污点的命令</span><br><span class="line">30、PV PVC SC 有没有用过，用在哪些场景/业务（极少部分会问怎么做的）？</span><br><span class="line">31、你们的PV PVC用的是什么？ NFS Ceph 云存储</span><br><span class="line">32、控制器有哪些，分别是干嘛的？</span><br><span class="line">32、控制器+调度器的需求场景，例如我有20个节点，每个几点都需要跑一个pod副本，我要怎么做？</span><br><span class="line">33、以32题为基础，增加一个需求，新增的Pod需要和拥有app=a标签的Pod 跑在一起，我要怎么做？</span><br><span class="line">34、K8S 控制组合题，比如daemonset 搭配调度器的需求场景 </span><br><span class="line">35、你们业务/应用，会使用哪些控制器，或者32题介绍后，追问，statefulset和deployment控制器分别用于什么场景/业务</span><br><span class="line">36、你们配置文件是怎么管理的/或者直接问configmap和secret分别用在什么场景</span><br><span class="line">37、你们是怎么暴露服务的？</span><br><span class="line">38、你们用的是哪个ingress（含义：ingress-controller-nginx 控制器，还是云上的ingress）？</span><br><span class="line">39、ingress的工作原理是什么？有可能会问 ingress 组件有哪些</span><br><span class="line">40、ingress怎么做https转发？</span><br><span class="line">申请tls/ca证书，申请域名，将证书与密钥文件创建为secret资源，然后写ingress-api对象的yaml文件时，在spec字段下定义域名参数和tls参数，指向secret证书资源。然后在rules 规则中，定义443访问端口即可 </span><br><span class="line">41、我K8S节点资源充足的，但是为什么我在创建pod的时候，一直创建失败呢，有哪些可能性？</span><br><span class="line">前提：没有调度问题，没有配置问题，没有镜像问题，没有控制器问题、没有网络问题、没有探针问题，没有钩子问题。</span><br><span class="line">我们可能给namespace 配置了limit（这个limits 可能是pod 数量上限，可能是可用资源上限）</span><br><span class="line">42、怎么将http的流量转到https下？</span><br><span class="line">做301重定向</span><br><span class="line">具体怎么做呢？ 在ingress文件（ingress-api对象的文件）的注释信息中，写明：</span><br><span class="line">annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">43、你们平时是怎么管理K8S集群的？</span><br><span class="line">rancher 平台、promtheus 监控辅助 日志管理efk+ grafana监控、日志数据可视化 helm 资源管理</span><br><span class="line">或者云平台管理</span><br><span class="line"></span><br><span class="line">44、你们的K8S安全管理是什么？？？</span><br><span class="line">RBAC：认证、鉴权、准入控制</span><br><span class="line">管理方法如下：</span><br><span class="line">权限申明</span><br><span class="line">role  指定ns</span><br><span class="line">clusterole 所有ns</span><br><span class="line">权限认证：</span><br><span class="line">rolebinding 指定ns认证</span><br><span class="line">clusterrolebinding 指定所有ns</span><br><span class="line">绑定subject 角色</span><br><span class="line">sa    Pod资源对象</span><br><span class="line">user  用户</span><br><span class="line">group 组-组成员</span><br><span class="line"></span><br><span class="line">45、低概率问到helm组件、怎么用的?</span><br><span class="line">helm 包含了几个元素：</span><br><span class="line">① chart 包，这是一个&quot;tgz压缩文件&quot;  helm包的扩展名 </span><br><span class="line">② repostry ： helm包的仓库，存放着各类tgz软件包（需要安装好helm之后进行同步仓库位置）</span><br><span class="line">③ release（实例）： helm根据chart包发布/部署的资源对象</span><br><span class="line"></span><br><span class="line">helm 包的内部文件组成：</span><br><span class="line">以nginx为例， nginx-v1.0.1.tgz的chart 包 ，可以解压为一个nginx-chart工作目录</span><br><span class="line">在nginx-chart工作目录中会包含以下几个核心文件：</span><br><span class="line">① Chart.yaml ： nginx-chart包的基本概览，包括api版本，镜像，chart版本，keyworkd关键词等内容</span><br><span class="line">② template目录：这是创建Nginx-chart的release的相关资源模板，例如deployment.yaml svc.yaml ingress.yaml configmap.yaml等资源的配置模板，且模板中包含的都是基本配置+参数&quot;变量&quot;，参数&quot;变量&quot;的值，来源于nginx工作目录下，values.yaml 申明的值</span><br><span class="line">③ values.yaml：定义具体资源参数的文件，修改的内容，会在创建release时，传递给template目录下的各类资源的</span><br><span class="line">参数变量中使用。</span><br><span class="line"></span><br><span class="line">helm install nginx ./nginx -n namespace 创建release</span><br><span class="line"></span><br><span class="line">helm 的使用场景：</span><br><span class="line">在devops工作流程中使用，同时在应用发布更新、或比较复杂的应用资源管理，会使用helm</span><br><span class="line"></span><br><span class="line">46、你们采集K8S日志是怎么做的？？</span><br><span class="line"></span><br><span class="line">47、K8S内的Pod 怎么抓包？？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Felix</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8C%81%E7%BB%AD%E7%A7%AF%E7%B4%AF%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/">学习过程中持续积累的面试题</a></div><div class="post-share"><div class="social-share" data-image="/imgs/adater.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/15/Git/" title="Git的学习与使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Git的学习与使用</div></div><div class="info-2"><div class="info-item-1">Git一、初识Git它允许您保存不同版本的作品，而无需创建多个文件。您可以轻松地回到任何以前的版本，或创建备用时间线（我们称之为“分支”）来尝试不同的想法。 1.1 git初始化初始化Git储存库 1git init   1.2 git的不同状态查看git状态 1git status     “分支主”：将分支想象成时间线。“主”是项目的主要时间线。 “尚未提交”：提交就像视频游戏中的保存点。我们还没有做出任何保存点。 “nothing to commit”：Git 没有要记录的更改，因为我们还没有创建任何文件。     添加文件后会显示文件未跟踪  使用add命令后告诉git我需要保存这个文件时间点，即git开始跟踪文件 1git add message.txt   执行提交commit后，git暂存区清空，文件传输到git仓库中 1git commit -m &quot;send a message to the future&quot;   1.3 查看git日志1git log    展示的几条信息：  提交的唯一标识符（一长串字母和数字） 谁提交了 提交时间 我们编写的...</div></div></div></a><a class="pagination-related" href="/2025/10/14/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" title="Linux常见命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Linux常见命令</div></div><div class="info-2"><div class="info-item-1">Linux的目录结构与常见命令一、引言了解Linux命令前，首先要知道输入命令的工具shell是什么，命令有哪些命令? Shellshell是Linux系统中后台运行的一种特殊程序也可以理解成一种特殊的软件，提供了用户与内核进行交互操作的一种接口。通俗讲，用户使用应用程序发布命令（比如使用浏览器访问网页），Shell去通知操作系统需要进行什么操作（相当于解释层）。 命令种类shell 分为内部命令和外部命令 内部命令：在系统启动时就调入内存中，是常驻内存的，执行效率非常高。 外部命令：是系统软件的功能，用户需要时才从硬盘读取到内存中。 一般先执行内部命令再执行外部命令（别名最大）。 二、目录结构了解完使用命令的工具，其次就需要了解Linux系统中，什么目录是做什么的，存放什么内容。 Linux的目录结构如下图：  1)    &#x2F; (根目录)  ⭐ 整个文件系统的起点 2)    &#x2F;bin ⭐ 存放基本的系统命令，如ls, cp, mv 3)    &#x2F;boot 包含引导加载程序文件和内核 4)    &#x2F;dev ⭐ 设备文件目录，如硬盘、键盘等...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/imgs/adater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Felix</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/falsezxy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text">docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s"><span class="toc-number">2.</span> <span class="toc-text">k8s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ansible-prometheus-elk"><span class="toc-number">3.</span> <span class="toc-text">ansible prometheus elk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ansible-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">ansible 面试题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prometheus"><span class="toc-number">3.2.</span> <span class="toc-text">prometheus:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.</span> <span class="toc-text">日志分析系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CI-CD"><span class="toc-number">4.</span> <span class="toc-text">CI&#x2F;CD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88"><span class="toc-number"></span> <span class="toc-text">云计算相关知识整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">0.1.</span> <span class="toc-text">一、整体框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">0.2.</span> <span class="toc-text">二、技术栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Linux"><span class="toc-number">0.2.1.</span> <span class="toc-text">1、Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">0.2.1.1.</span> <span class="toc-text">（1）基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%96%87%E4%BB%B6%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C-The-Basics"><span class="toc-number">0.2.1.1.1.</span> <span class="toc-text">基础文件与命令操作 (The Basics)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B5%84%E6%BA%90-System-Resource-Status"><span class="toc-number">0.2.1.1.2.</span> <span class="toc-text">系统状态与性能资源 (System &amp; Resource Status)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E6%97%A5%E5%BF%97-Process-Logs"><span class="toc-number">0.2.1.1.3.</span> <span class="toc-text">进程管理与日志 (Process &amp; Logs)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C-Storage-Network"><span class="toc-number">0.2.1.1.4.</span> <span class="toc-text">存储与网络 (Storage &amp; Network)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E9%AB%98%E8%B4%9F%E8%BD%BD%E4%B8%8E%E6%85%A2%E5%93%8D%E5%BA%94-High-Load-Slow-Response"><span class="toc-number">0.2.1.1.5.</span> <span class="toc-text">场景一：高负载与慢响应 (High Load &amp; Slow Response)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E9%87%8D%E5%A4%A7%E6%95%85%E9%9A%9C%EF%BC%9AOOMKilled-Out-of-Memory-Killed"><span class="toc-number">0.2.1.1.6.</span> <span class="toc-text">场景二：重大故障：OOMKilled (Out of Memory Killed)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E6%BB%A1-Disk-Full"><span class="toc-number">0.2.1.1.7.</span> <span class="toc-text">场景三：磁盘空间爆满 (Disk Full)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#tcpdump"><span class="toc-number">0.2.1.1.8.</span> <span class="toc-text">tcpdump</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#telnet%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%B9%B3%E6%97%B6%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-number">0.2.1.1.9.</span> <span class="toc-text">telnet的作用？平时怎么抓取网络的监控数据的?</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Shell-%E8%84%9A%E6%9C%AC"><span class="toc-number">0.2.1.2.</span> <span class="toc-text">（2）Shell 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9Ashell%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">0.2.1.2.1.</span> <span class="toc-text">案例：shell构建系统监视器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">0.2.1.3.</span> <span class="toc-text">（3）核心的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#OOM-KILL"><span class="toc-number">0.2.1.3.1.</span> <span class="toc-text">OOM KILL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8E%8B%E5%8A%9B%E8%BF%87%E5%A4%A7"><span class="toc-number">0.2.1.3.2.</span> <span class="toc-text">网络压力过大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.2.2.</span> <span class="toc-text">2、应用服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89LVS-keepalived-Nginx-%E4%BD%93%E7%B3%BB"><span class="toc-number">0.2.2.1.</span> <span class="toc-text">（1）LVS + keepalived + Nginx 体系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Spring-cloud-boot-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.2.2.2.</span> <span class="toc-text">（2）Spring cloud&#x2F;boot 微服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BC%93%E5%86%B2%E5%B1%82"><span class="toc-number">0.2.2.3.</span> <span class="toc-text">（3）中间件缓冲层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%94%AF%E6%8C%81%E3%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">0.2.3.</span> <span class="toc-text">3、支持、管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ELK-%E4%BD%93%E7%B3%BB"><span class="toc-number">0.2.3.1.</span> <span class="toc-text">(1) ELK 体系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.2.3.2.</span> <span class="toc-text">(2) 监控服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83"><span class="toc-number">0.2.4.</span> <span class="toc-text">4、云原生基础环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E7%AF%87"><span class="toc-number">0.2.4.1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">0.2.4.2.</span> <span class="toc-text">虚拟化&#x2F;容器技术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">0.2.5.</span> <span class="toc-text">5、资源管理器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/18/CI%20CD%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90Ruo-Yi%E9%A1%B9%E7%9B%AE/" title="CI/CD持续集成Ruo-Yi项目">CI/CD持续集成Ruo-Yi项目</a><time datetime="2025-12-18T11:27:44.000Z" title="Created 2025-12-18 19:27:44">2025-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/17/Kubernets-network_rbac_hpa/" title="Kubernetes 网络、RBAC 和 HPA 相关知识">Kubernetes 网络、RBAC 和 HPA 相关知识</a><time datetime="2025-12-17T10:34:40.000Z" title="Created 2025-12-17 18:34:40">2025-12-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/16/Kubernetes-Ingress%E6%9C%8D%E5%8A%A1/" title="Kubernetes-Ingress服务">Kubernetes-Ingress服务</a><time datetime="2025-12-16T10:12:58.000Z" title="Created 2025-12-16 18:12:58">2025-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/16/Kubernetes%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="Kubernetes存储管理">Kubernetes存储管理</a><time datetime="2025-12-16T01:35:04.000Z" title="Created 2025-12-16 09:35:04">2025-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/15/Kubernetes%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" title="Kubernetes 配置资源管理">Kubernetes 配置资源管理</a><time datetime="2025-12-15T02:54:40.000Z" title="Created 2025-12-15 10:54:40">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/imgs/background_footer.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Felix</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>