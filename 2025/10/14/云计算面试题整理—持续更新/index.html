<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>云计算面试题整理—持续更新 | Felix的个人博客</title><meta name="author" content="Felix"><meta name="copyright" content="Felix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.查看资源占用 题目： 1、当前系统很卡，cpu占用很高，我应该如何排查具体哪个进程占用资源最多  2、接上一题，如何定位这个进程的哪个子进程占用CPU资源更大。  3、接上一题，遇到以上问题，如何处理。 整理为故障文档 2.三握四挥 3.检查Linux版本号 4.配置yum本地仓库 5.LVM扩容 6.RAID和RAID创建 7.平时shell干什么 8.内网服务器下很慢 借其他电脑windo">
<meta property="og:type" content="article">
<meta property="og:title" content="云计算面试题整理—持续更新">
<meta property="og:url" content="http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html">
<meta property="og:site_name" content="Felix的个人博客">
<meta property="og:description" content="1.查看资源占用 题目： 1、当前系统很卡，cpu占用很高，我应该如何排查具体哪个进程占用资源最多  2、接上一题，如何定位这个进程的哪个子进程占用CPU资源更大。  3、接上一题，遇到以上问题，如何处理。 整理为故障文档 2.三握四挥 3.检查Linux版本号 4.配置yum本地仓库 5.LVM扩容 6.RAID和RAID创建 7.平时shell干什么 8.内网服务器下很慢 借其他电脑windo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/imgs/adater.jpg">
<meta property="article:published_time" content="2025-10-14T05:41:59.000Z">
<meta property="article:modified_time" content="2025-12-24T12:31:58.141Z">
<meta property="article:author" content="Felix">
<meta property="article:tag" content="学习过程中持续积累的面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/adater.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "云计算面试题整理—持续更新",
  "url": "http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/",
  "image": "http://example.com/imgs/adater.jpg",
  "datePublished": "2025-10-14T05:41:59.000Z",
  "dateModified": "2025-12-24T12:31:58.141Z",
  "author": [
    {
      "@type": "Person",
      "name": "Felix",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '云计算面试题整理—持续更新',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/imgs/background_header.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Felix的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">云计算面试题整理—持续更新</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">云计算面试题整理—持续更新</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-10-14T05:41:59.000Z" title="Created 2025-10-14 13:41:59">2025-10-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-12-24T12:31:58.141Z" title="Updated 2025-12-24 20:31:58">2025-12-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>1.查看资源占用</p>
<p>题目：</p>
<p>1、当前系统很卡，cpu占用很高，我应该如何排查具体哪个进程占用资源最多 </p>
<p>2、接上一题，如何定位这个进程的哪个子进程占用CPU资源更大。 </p>
<p>3、接上一题，遇到以上问题，如何处理。</p>
<p>整理为故障文档</p>
<p>2.三握四挥</p>
<p>3.检查Linux版本号</p>
<p>4.配置yum本地仓库</p>
<p>5.LVM扩容</p>
<p>6.RAID和RAID创建</p>
<p>7.平时shell干什么</p>
<p>8.内网服务器下很慢</p>
<p>借其他电脑windows下载，再传过去比如堡垒机</p>
<p>scp 文件 用户@IP：路径  （ssh copy）用法和cp一样</p>
<p>9.DNS: 主机A记录  域名解析为IP</p>
<p>​	主机P记录 反向解析记录，IP转换为域名</p>
<p>10.内存OOM怎么处理</p>
<p>OOM 是 Out Of Memory 的缩写，表示系统内存不足。当系统物理内存和虚拟内存（Swap）都不足时，会触发 OOM Killer 机制，强制杀死占用内存最多的进程来释放内存。</p>
<p>后果主要有：</p>
<ol>
<li>进程被强制杀死，导致服务中断</li>
<li>数据丢失，业务受损</li>
<li>系统不稳定，严重时会导致宕机</li>
</ol>
<p>诊断：</p>
<p><img src="/./imgs/image-20251103092337592.png" alt="image-20251103092337592"></p>
<p><img src="/./imgs/image-20251103092400284.png" alt="image-20251103092400284"></p>
<p>处理：</p>
<p><img src="/./imgs/image-20251103092556237.png" alt="image-20251103092556237"></p>
<p><img src="/./imgs/image-20251103092620631.png" alt="image-20251103092620631"></p>
<p>11.grep awk sed的处理逻辑是什么？</p>
<p>行处理grep：输出的是符合条件的文本内容的行”输出行”</p>
<p>列处理awk：匹配符合条件的列</p>
<p>修改sed：主要做修改&#x2F;或者打印指定条件的行</p>
<p>shell相关</p>
<p>12、提取日志中，访问次数最多的IP地址</p>
<p>查找access 访问日志中，来访最多的IP地址，统计次数并排序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk &#x27;&#123;print $1&#125;&#x27; | egrep -v &quot;^$&quot; | sort -n | uniq -c | sort -rk 1</span><br></pre></td></tr></table></figure>

<p>13、提取本机指定网卡的IP地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 | grep &quot;broadcast&quot; | awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>14、提取、计算内存&#x2F;cpu使用率(awk精确到$几，具体的命令)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存使用率</span></span><br><span class="line">mem_rate=$(free -m | grep &quot;Mem:&quot; | awk &#x27;&#123;print ($3/$2)*100&#125;&#x27;</span><br><span class="line">echo &quot;内存使用率为$&#123;mem_rate&#125;%&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cpu使用率⭐</span></span><br><span class="line">grep &#x27;^cpu &#x27; /proc/stat | awk &#x27;&#123;usage=($2+$3+$4)*100/($2+$3+$4+$5)&#125; END &#123;printf &quot;CPU Usage: %.2f%\n&quot;, usage&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>15、组合:怎么周期备份指定目录下的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * 7 * * /usr/bin/cp /etc/passwd /opt/bak</span><br></pre></td></tr></table></figure>

<p>16、怎么周期删除7天前的日志文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">* * 7 * * /usr/bin/rm -rf `find /var/log -mtime +7 -name &quot;*.log&quot;`</span><br></pre></td></tr></table></figure>

<p>17、过滤出当前目录下所有普通文件中包含xxxx字符串的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rl &quot;xxxx&quot; ./ | find -type f</span><br></pre></td></tr></table></figure>

<p>18、如何反向过滤出以空格开头与#号注释为开头的行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -v &quot;^#|^[[:space:]]|^$&quot;</span><br></pre></td></tr></table></figure>

<p>19、怎么校对2个文件中不同的部分(shell工具可以直接完成这个任务)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff</span><br></pre></td></tr></table></figure>

<p>20、其他的应用场景，比如筛选出当前目录下占用磁盘最高的前10个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah ./ | sort -nr  | sed -n &#x27;2,11p&#x27;</span><br></pre></td></tr></table></figure>

<p>21、我要筛选出1.txt 文件中第10~20行内，包含abc字符串的行，并修改为def</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;NR&gt;=10,NR&lt;=20&#123;print&#125;&#x27; 1.txt | sed &#x27;s/abc/def/&#x27;</span><br></pre></td></tr></table></figure>

<p>22、变量有哪些类型? $? $# $0 $1 $* 分别代表什么意思?</p>
<p>Shell变量主要有：<strong>字符串、数字、数组、环境变量、只读变量、特殊变量和本地变量</strong>这几种类型。</p>
<p>$?:上一个表达式的返回值</p>
<p>$#:位置参数的个数</p>
<p>$0:命令本身</p>
<p>$1:第一个参数</p>
<p>$*:所有位置参数，作为一个字符串</p>
<p>23、cpu压力值过大怎么处理？</p>
<p>排查框架</p>
<p>0、怎么接收到异常信息</p>
<p>1、观测</p>
<p>观测到异常以及更准确的信息(初步的定位范围–》定位到关键点&#x2F;参数)</p>
<p>top htop “ps” “aux&#x2F;elf | grep” “uptime”</p>
<p>2、初步的处理方案</p>
<p>① 先判断（描述动作）占资源前十的进程中，是什么类型的任务（系统任务、业务任务、异常任务）</p>
<p>②考虑解决方案</p>
<p>​	判断可以关闭–》直接关闭</p>
<p>​	主进程、子进程都存在–》其他指令来查看这个进程任务的大致情况（htop–》F5）</p>
<p>3、处理后观测效果</p>
<ol start="24">
<li></li>
</ol>
<p><img src="/./imgs/image-20251103190637524.png" alt="image-20251103190637524"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -r &#x27;s/.*-(.*).jar/\1/&#x27; banben</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251103191159382.png" alt="image-20251103191159382"></p>
<p>25.shell脚本编写规范，shell脚本怎么写的？写过什么脚本</p>
<p>声明解释器，注释说明</p>
<p>按常量、函数、主程序的顺序组织代码</p>
<p>#!&#x2F;bin&#x2F;bash	先写解释器</p>
<p>① 定义变量</p>
<p>重复使用且书写比加长的适合作为变量</p>
<p>IP地址、路径，适合作为变量</p>
<p>（自定义变量）</p>
<p>② 写环境判断</p>
<p>③ 定义函数</p>
<p>④ 有交互写交互，无交互写判断执行逻辑（if、for&#x2F;while循环）</p>
<p>在执行的过程中调用对应的函数名字</p>
<p>⑤ 最好有输出，或者有观测结果的提示</p>
<p>建议准备脚本案例，以防面试官问举例子</p>
<p>写过哪些脚本</p>
<p>① 重复任务 –》备份(tar cp rsync差异备份)、清理、批量创建管理(低频)</p>
<p>② 巡检（）</p>
<p>③ 服务的安装、管理</p>
<p>26.状态码404 403 301 302 503</p>
<p>27.503可能是哪些原因，怎么判断怎么做？</p>
<p>28.nginx反向代理与负载均衡</p>
<p>29.LVS的优势，与nignx的区别</p>
<p>30.nginx配置文件</p>
<ol start="31">
<li></li>
</ol>
<p><img src="/./imgs/image-20251113093357151.png" alt="image-20251113093357151"></p>
<p>32.keepalived（脑裂）双VIP</p>
<ol start="33">
<li></li>
</ol>
<p><img src="/./imgs/image-20251113093426419.png" alt="image-20251113093426419"></p>
<p>34.索引是什么？怎么做的？怎么知道该不该创建索引？</p>
<p><img src="/./imgs/image-20251120113033686.png" alt="image-20251120113033686"></p>
<p><img src="/./imgs/image-20251120113254798.png" alt="image-20251120113254798"></p>
<p>35.索引的种类？有什么区别？</p>
<p>36.mysql的优化（包含创建合适的索引）</p>
<p>面试题</p>
<p><a target="_blank" rel="noopener" href="https://share.note.youdao.com/s/IGStx687">https://share.note.youdao.com/s/IGStx687</a></p>
<p>云计算面试题</p>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p><strong>1、docker 常用命令（增删改查）</strong></p>
<p>增：docker run&#x2F;create 删：docker rm&#x2F;rmi 改：docker commit、docker build 查：docker ps&#x2F;images&#x2F;inspect</p>
<p><strong>2、docker -i -t -d什么意思</strong></p>
<p><code>-i</code> (interactive)：交互模式，保持标准输入开放。</p>
<p><code>-t</code> (tty)：分配一个伪终端。</p>
<p><code>-d</code> (detach)：后台运行容器。</p>
<p><strong>3、dockerfile 有哪些指令，dockerfile内容怎么写的，写过哪些dockerfile</strong></p>
<p><strong>常见指令：</strong> <code>FROM</code> (基础镜像), <code>RUN</code> (执行命令), <code>COPY/ADD</code> (拷贝文件), <code>WORKDIR</code> (工作目录), <code>CMD/ENTRYPOINT</code> (启动命令), <code>ENV</code> (环境变量), <code>EXPOSE</code> (暴露端口)。</p>
<p><strong>写法：</strong> 从基础镜像开始，逐层添加配置和依赖，最后定义启动命令。</p>
<p><strong>示例：</strong> 编写过 Java (Jar包启动)、Nginx (修改配置)、Python 项目的 Dockerfile。</p>
<p>1、首先写一个基础镜像<br>FROM 基础镜像 as builder<br>2、使用RUN 执行command 命令，准备依赖环境、执行命令操作<br>3、使用COPY ADD 传入文件<br>4、EXPOSE 暴露端口<br>5、ENV 申明环境变量<br>6、FROM 基础镜像 as runtime<br>7、准备启动环境 CMD ENTRYPOINT </p>
<p><strong>4、dockerfile中cmd 和entrypoint 有什么区别，copy和add有什么区别</strong></p>
<p>CMD：可被覆盖；ENTRYPOINT：容器入口点，难以覆盖 COPY：只复制；ADD：复制+解压+拉取</p>
<p><strong>CMD vs ENTRYPOINT：</strong></p>
<ul>
<li><code>CMD</code>：容器启动时的默认参数，<strong>可以</strong>被 <code>docker run</code> 后面的参数覆盖。</li>
<li><code>ENTRYPOINT</code>：容器启动时执行的命令，<strong>不可</strong>被直接覆盖（参数会追加到后面）。</li>
</ul>
<p><strong>COPY vs ADD：</strong></p>
<ul>
<li><code>COPY</code>：仅支持本地文件拷贝。</li>
<li><code>ADD</code>：支持本地文件，<strong>还支持URL下载</strong>，且会自动<strong>解压</strong> tar 包。</li>
</ul>
<p><strong>5、容器和虚拟化的区别是什么，为什么要用容器？</strong></p>
<p>容器共享宿主机内核，秒级启动、轻量级、镜像小；虚拟化每个OS独立，启动慢、资源占用大</p>
<p><strong>区别：</strong> 虚拟机是<strong>硬件模拟</strong>，有完整OS，重；容器是<strong>共享内核</strong>，进程级隔离，轻。</p>
<p><strong>为什么用：</strong> 启动快（秒级）、占用资源少、移植性强（一次构建，到处运行）、易于交付和扩缩容。<br>⭐本质：容器是<strong>进程级</strong>别，<strong>共享宿主机内核</strong>的，虚拟机技术，完整<strong>OS(操作系统)级别</strong>，<strong>完整的操作系统内核</strong>。</p>
<p><strong>6、docker的底层原理是什么（cgroup namespace）</strong></p>
<p>cgroup控制资源；namespace隔离(网络、进程、文件系统、用户、ipc等)</p>
<p>gemini:</p>
<p><strong>Cgroup：</strong> 资源限制（限制 CPU、内存使用量）。</p>
<p><strong>Namespace：</strong> 资源隔离（隔离 PID、网络、挂载点等，也就是通常说的”沙盒”）。</p>
<p><strong>UnionFS (联合文件系统)：</strong> 镜像分层存储。</p>
<p><strong>7、docker的工作流程是什么？</strong></p>
<p>client → docker daemon → 检查镜像 → 不存在下载 → 创建容器 → 运行</p>
<p><strong>8、docker 怎么发布容器到外面？引申：-p -P区别</strong></p>
<p>使用-p&#x2F;-P映射端口 </p>
<p>-p指定映射(宿主机:容器)、-P随机映射所有EXPOSE端口</p>
<p><strong>9、docker 网络有哪些，有什么特性？</strong></p>
<p>bridge(默认)、host(共享宿主机网络)、overlay(跨主机)、none(无网络) bridge隔离性好、overhead开销低</p>
<p><strong>Bridge (默认)：</strong> 桥接模式，容器有独立IP，通过 docker0 网桥通信。</p>
<p><strong>Host：</strong> 共享宿主机网络栈，无隔离，性能好但端口易冲突。</p>
<p><strong>None：</strong> 无网络，需手动配置。</p>
<p><strong>Container：</strong> 与另一个容器共享网络。</p>
<p><strong>Overlay：</strong> 跨主机通信（Swarm&#x2F;K8S常用）。</p>
<p><strong>10、docker-compose会写么，有没有用过，在哪用的？</strong></p>
<p>会；用于多容器编排(如Web+MySQL)，一个yml定义多个服务</p>
<p><strong>会写：</strong> YAML 格式，定义 services, networks, volumes。</p>
<p><strong>场景：</strong> 开发环境、测试环境、单机部署多容器应用（如 Nginx+App+MySQL 组合）。</p>
<p>比如单机部署前后端服务ruoyi，Promethus等</p>
<p><strong>11、除了docker 有没有用过其他容器？</strong></p>
<p>containerd；去除了docker engine和server，直接与CRI接口交互，K8S高版本标准</p>
<p><strong>12、docker中 怎么把文件传到运行的容器中</strong></p>
<p>docker cp 本地文件 容器id:容器路径</p>
<p><strong>13、dockerfile 怎么写</strong>——与3类似</p>
<p>核心原则：选择最小基础镜像(Alpine)、合并 RUN 指令减少层数、清理缓存减小体积。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./app /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p><strong>①  K8S 核心组件有哪些？每个组件是干嘛的？</strong></p>
<p>Master：</p>
<ul>
<li>apiserver(API接口，集群管理调度任务分配，etcd数据库交互)</li>
<li>scheduler(调度器，选择最合适创建Pod的节点)</li>
<li>controller-manager(控制器，管理各类控制器，管理pod生命周期)</li>
<li>etcd(存储，集群核心库)</li>
<li>kubectl(管理集群的命令)</li>
<li>auth(认证鉴权)</li>
</ul>
<p>Node：</p>
<ul>
<li>kubelet(节点代理，管理监控节点中k8s资源与任务的核心组件，将节点信息返回给api-server给etcd保存)</li>
<li>kube-proxy(网络代理，把pod暴露到集群外，给用户访问)</li>
<li>pod(资源调度的最小单位，分装了多个容器，业务运行在容器中)</li>
</ul>
<p><strong>②  K8S 工作流程是什么？</strong><br>简版：</p>
<p>用户kubct→auth认证鉴权→apiserver→etcd(存储)→list清单给apiserver</p>
<p>scheduler与scheduler监听apiserver中list（获取需要干的事情）</p>
<p>scheduler选择合适的节点 controller准备对应的资源 </p>
<p>apiserver通知调度器选择节点的kubelet执行<br>详细：</p>
<p>① kubectl 创建一个Pod 资源（指令&#x2F;yml文件）<br>② 通过auth 认证鉴权后，到达api-server<br>③ api-server将信息记录在etcd中，etcd 会创建一个ADD的事件，并返回给api-server一个<br>list清单（清单中，会申明需要哪些资源）<br>④ Scheduler 监听到Api-server上的ADD事件后，会触发default-scheduler 规则，选择出<br>最适合创建Pod的节点（如worker02），并提交到api-server的list清单中<br>⑤ worker02 的kubelet组件监听到Api-server上的List清单的调度结果后，会触发连接容器<br>运行时的动作，从而pull image 、create container、start container<br>（主要管理的是容器，比如pause 容器、init容器、主应用容器）<br>⑥ controller-manager 控制器管理中心，也会监听到api-server上的List 清单add事件<br>此时，controller-manager会创建deployment–》创建RS—》RS创建Pod 管理kubelet<br>创建的容器<br>⑦ 后续pod的状态，容器的探针等均由kubelet来监控、管理与汇报给api-server<br>⑧ api-server会持续记录在etcd中</p>
<p><strong>③  K8S 搭建用的是什么方式，你们CNI（容器网络接口）用的是什么？</strong></p>
<p><strong>搭建：</strong> <code>kubeadm</code> (常用)、二进制 (高难度，方便排错)、云厂商托管 (ACK&#x2F;EKS)。</p>
<p><strong>CNI (网络插件)：</strong> <code>Calico</code> (性能好，支持BGP&#x2F;IPIP，支持网络策略) 或 <code>Flannel</code> (简单，Overlay模式)。</p>
<p><strong>④  你们K8S集群规模大概多大（1、节点数量-包括master数量和worker数量 2、Pod数量）</strong></p>
<p>(参考话术) 测试环境：3 Master + 5 Worker。生产环境：3 Master + 20~50 Worker。Pod 数量：几百上千个。</p>
<p><strong>⑤  你们K8S中跑的是什么？</strong></p>
<p>K8S 中可以运行所有微服务业务、应用服务、各类的管理系统，除了数据库、中间件（rabbitmq、kafka 等）以及其他极度吃资源的服务&#x2F;环境，其他都可以跑在K8S中</p>
<p>无状态服务 (SpringBoot&#x2F;Go 微服务)、Nginx、前端应用。</p>
<p>⭐1、微服务（前后端项目）<br>⭐2、配置文件、加密文件<br>⭐3、挂载存储<br>4、管理网络通讯<br>⭐5、管理系统 （OA CRM REPORT 财务系统）<br>6、微服务Pod的调度、控制器<br>7、权限管理<br>⭐8、监控<br>⭐9、注册中心<br>⭐10、网关服务</p>
<p>PS:除了数据库、部分中间件也不会跑在里面，对资源使用要求特别高的项目&#x2F;技术</p>
<p>比如：Ruo-Yi ： 前端项目  后端项目 注册中心 网关服务 认证鉴权服务<br>spring cloud&#x2F;spring boot 数据库集群</p>
<p><strong>⑥  K8S 云上还是自建（看你们业务）；什么是私有云、公有云、混合云？</strong></p>
<p><strong>私有云：</strong> 自建机房，数据安全，成本高。</p>
<p><strong>公有云：</strong> 阿里云&#x2F;AWS，弹性伸缩，按需付费。</p>
<p><strong>混合云：</strong> 核心数据在私有云，业务突发在公有云。</p>
<p><strong>⑦  K8S 常用命令（简单问）详细参考50</strong></p>
<p>kubectl get&#x2F;describe&#x2F;create&#x2F;delete&#x2F;apply&#x2F;edit kubectl logs&#x2F;exec&#x2F;port-forward</p>
<p><strong>⑧  有哪些控制器</strong></p>
<p><strong>Deployment：</strong> 无状态应用 (Web服务)。</p>
<p><strong>StatefulSet：</strong> 有状态应用 (DB、Redis，有顺序和固定ID)。</p>
<p><strong>DaemonSet：</strong> 每个节点跑一个 (日志采集、监控Agent)。</p>
<p><strong>Job&#x2F;CronJob：</strong> 一次性任务&#x2F;定时任务。</p>
<p><img src="/./imgs/image-20251217125544956.png" alt="image-20251217125544956"></p>
<p><strong>⑨  你们项目中的产品&#x2F;业务是怎么更新的</strong></p>
<p>一套完整流程：①开发→git commit(提交代码)→CI(jenkins)→镜像构建push→CD(kubectl apply更新)→验证</p>
<p>②开发提交代码 -&gt; GitLab -&gt; Jenkins (CI) 构建镜像 -&gt; 推送 Harbor -&gt; 触发 K8S 修改 Deployment 镜像版本 -&gt; 滚动更新。</p>
<p><strong>10  容器的重启策略、镜像下载策略</strong></p>
<p><strong>重启策略：</strong> <code>Always</code> (总是重启，默认), <code>OnFailure</code> (失败&#x2F;非正常退出才重启), <code>Never</code>。</p>
<p><strong>镜像策略：</strong> <code>Always</code> (总是拉), <code>IfNotPresent</code> (本地没有才拉), <code>Never</code>。</p>
<p><strong>11  Pod内有几种容器，分别是做什么的</strong></p>
<p>app 主容器：业务逻辑 </p>
<p>init 容器：进行初始化操作，为后续容器准备初始化环境(挂载、权限设置等) </p>
<p>pause容器：为其他容器准备网络和挂载命名空间等 </p>
<p>补充（主要是上面三个）：Sidecar容器： 辅助功能（如日志搜集filebeat等、ServiceMesh代理）。</p>
<p><strong>12  Pod类型有哪些，有什么区别</strong></p>
<p>自主式：直接由用户创建的独立Pod，没有任何控制器管理，Pod被删除后不会自动重建</p>
<p>动态（声明式）&#x2F;控制器管理的pod：<strong>声明式创建</strong> - 通过YAML文件描述期望状态，由控制器（Deployment、StatefulSet、DaemonSet等）管理，Pod被删除后，控制器会自动重建以维持期望副本数，支持自动扩缩容、滚动更新、自愈能力</p>
<p>静态式：由kubelet直接管理，不需要API Server，不受控制器管理，Kubelet 会自动根据该目录中的 YAML 文件创建静态 Pod</p>
<p><strong>13、Pod 删除的工作流程是什么</strong>参考工作流程详细版</p>
<p>claude:</p>
<p>① 参与组件：apiserver、etcd、controller-manager、kubelet ② 起始位置：kubectl delete → apiserver ③ 过程：apiserver更新etcd → controller-manager监听删除事件 → 通知kubelet → kubelet删除容器 → 从etcd移除 ④ 方向：单向下行(apiserver→kubelet) ⑤ 机制：grace period(优雅关闭，默认30s) </p>
<p>gemini:</p>
<p>① User 发删请求 -&gt; ② Pod 状态变 Terminating -&gt; ③ <strong>同时进行</strong>：从 Service 端点移除流量 + 容器内执行 <code>preStop</code> 钩子 + 发送 <code>SIGTERM</code> 信号 -&gt; ④ 等待 <code>terminationGracePeriodSeconds</code> (默认30s) -&gt; ⑤ 强制发送 <code>SIGKILL</code> 删除。<br><strong>参考工作流程详细版本，上面两个AI版本都比较简略</strong></p>
<p>比如scheduler会停止调度</p>
<p><strong>14、pod 增删改查命令是什么，以Nginx 为例</strong></p>
<p>① 增：<code>kubectl create deployment ng-deploy --replicas=3 --image=nginx:latest --port=80 -n abc</code> </p>
<p>② 修改镜像：<code>kubectl set image deployment/ng-deploy nginx=nginx:1.20 -n abc</code> </p>
<p>③ 查询：<code>kubectl get po -l app=nginx -n abc</code></p>
<p>④ 删除：<code>kubectl delete deployment ng-deploy -n abc</code></p>
<p><strong>15、Pod 如何发布的（过程描述）以service 的NodePort 模式为例</strong></p>
<p>claude:</p>
<p>创建deployment→生成Pod→创建service(NodePort)→分配31xxx端口→外部通过NodeIP:31xxx访问→kube-proxy转发到Pod:80</p>
<p>gemini:</p>
<p>Pod 启动并拥有 IP -&gt; Service 选择 Pod 标签 -&gt; Service 创建 ClusterIP 和 Endpoints -&gt; NodePort 在每台宿主机开端口 -&gt; 外部访问 NodeIP:NodePort -&gt; 转发给 Service -&gt; 负载均衡到 Pod。</p>
<p><strong>T15需要重新组织</strong></p>
<p><strong>16、K8S 更新Pod 方法（滚动、蓝绿、金丝雀&#x2F;灰度）分别是怎么发布的</strong></p>
<p><strong>滚动更新 (Rolling Update)：</strong> K8S 默认。启动一个新版，杀一个旧版，平滑过渡。</p>
<p><strong>蓝绿发布 (Blue&#x2F;Green)：</strong> 新旧版本并存，测试通过后，Service 流量一次性切到新版。</p>
<p><strong>金丝雀&#x2F;灰度 (Canary)：</strong> 先发极少量新版（如10%流量），观察无误后，逐步扩大比例直至全量。</p>
<p><strong>17、K8S Pod资源限制怎么做的，参数是什么？</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="attr">requests:</span> &#123;<span class="attr">cpu:</span> <span class="string">100m</span>, <span class="attr">memory:</span> <span class="string">128Mi</span>&#125;  <span class="comment"># 最低保证</span></span><br><span class="line">  <span class="attr">limits:</span> &#123;<span class="attr">cpu:</span> <span class="string">500m</span>, <span class="attr">memory:</span> <span class="string">512Mi</span>&#125;    <span class="comment"># 上限</span></span><br></pre></td></tr></table></figure>

<p><strong>18、K8S集群的默认驱逐机制中，各个资源的驱逐阈值是多少？</strong></p>
<p><strong>memory.available &lt; 100Mi</strong> - 可用内存少于 100M</p>
<p><strong>nodefs.available &lt; 10%</strong> - 节点文件系统可用空间少于 10%</p>
<p><strong>nodefs.inodesFree &lt; 5%</strong> - 节点文件系统可用 inode 少于 5%</p>
<p><strong>imagefs.available &lt; 15%</strong> - 镜像文件系统可用空间少于 15%（如果镜像存储单独分区）</p>
<p><strong>pid.available &lt; 4%</strong> - 可用 PID 少于 4%</p>
<p>NodeCondition 为 NotReady等 </p>
<p>kubelet触发驱逐</p>
<p><strong>驱逐优先级</strong></p>
<p>kubelet 驱逐 Pod 时会按照优先级顺序选择：</p>
<ol>
<li><strong>Best Effort 类 Pod</strong>（优先驱逐）- 没有 requests&#x2F;limits 定义</li>
<li><strong>Burstable 类 Pod</strong> - 有 requests 但 limits 高于 requests</li>
<li><strong>Guaranteed 类 Pod</strong>（最后驱逐）- requests &#x3D; limits</li>
</ol>
<p><strong>19、Pod 健康检查机制是什么，有哪些（探针）类型，有什么区别</strong></p>
<p>健康检查通过探针（Probe）来实现，kubelet 定期执行这些检查来判断容器的健康状态。</p>
<p><strong>liveness探针</strong>：检测Pod是否存活，失败重启 </p>
<p><strong>readiness探针</strong>：检测是否就绪，失败则从service的endpoint移除 </p>
<p><strong>startup探针</strong>：专为启动慢的应用设计，成功前不执行其他探针。</p>
<p><strong>20、Pod 探针的检查方式有哪些</strong></p>
<p>exec(执行命令)、httpGet(http请求，状态码200-399)、tcpSocket(端口连接)</p>
<p><strong>21、钩子的使用作为加分项，在容器创建后，启动前，想插入一段指令或准备一个环境，应该怎么做</strong></p>
<p><strong>PreStop：</strong> 容器终止前执行（如：平滑关闭连接、注册中心下线）。</p>
<p><strong>PostStart：</strong> 容器启动后执行（极少用）。</p>
<p>使用lifecycle钩子PostStart(启动后)或PreStop(停止前)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line">  <span class="attr">postStart:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>22、第一层面试题：直接问调度策略有哪些，怎么做的</strong></p>
<p>nodeSelector、affinity(亲和性)、taints&#x2F;tolerations(污点容忍)、priorityClass(优先级)</p>
<p><strong>默认调度流程：</strong> 预选 (Predicates, 过滤节点) -&gt; 优选 (Priorities, 打分)-&gt;打分。</p>
<p><strong>NodeSelector：</strong> 简单的节点选择 (key&#x3D;value)。</p>
<p><strong>Affinity (亲和性)：</strong></p>
<ul>
<li><code>NodeAffinity</code>：喜欢调度到哪些节点 (软策略&#x2F;硬策略)。</li>
<li><code>PodAffinity</code>：喜欢和哪些 Pod 在一起 (如 App 和 Redis)。</li>
<li><code>PodAntiAffinity</code>：反亲和，<strong>不</strong>和哪些 Pod 在一起 (如高可用部署，两副本不在同一节点)。</li>
</ul>
<p><strong>Taints (污点) &amp; Tolerations (容忍)：</strong></p>
<ul>
<li><p>污点是打在<strong>节点</strong>上的 (拒绝 Pod)。</p>
</li>
<li><p>容忍是打在<strong>Pod</strong>上的 (允许进入污点节点)。</p>
</li>
<li><p><strong>场景：</strong> Master 节点默认有污点不跑业务；专用 GPU 节点打污点，只让 AI 业务跑。</p>
<p>三种污点机制：NoSchedule,PreferNoSchedule,NoExcute</p>
</li>
</ul>
<p><strong>23、第二层面试题：给需求，然后让你使用对应的调度策略完成</strong></p>
<p>例如需求”Pod与app&#x3D;web标签Pod同节点”→用nodeAffinity或podAffinity实现</p>
<p><strong>24、第三层面试题：实际业务报错场景下，如何排查错误发生的可能性</strong></p>
<p>查Pod日志→describe Pod查events→检查节点资源→检查污点→检查调度器日志→验证selector匹配</p>
<p><strong>25、调度器的默认调度规则&#x2F;策略是什么？</strong></p>
<p>predicates(节点过滤)+ priority(优先级评分) 默认按资源、端口、label筛选</p>
<p><strong>26、污点和容忍的作用是什么，什么时候会使用污点机制？</strong></p>
<p>污点：标记节点不可用 </p>
<p>容忍：Pod可在污点节点运行 </p>
<p>用于隔离特殊节点(GPU节点、专用集群)</p>
<p><strong>27、存储类型有哪些，你们用的是什么存储，什么场景使用？</strong></p>
<p>EmptyDir(临时)、HostPath(主机路径)、PV&#x2F;PVC(持久化)、ConfigMap&#x2F;Secret(配置) NFS用于共享存储、Ceph用于块存储、云存储用于云平台</p>
<p><code>EmptyDir</code>：临时存储，Pod 删数据丢 (缓存)。</p>
<p><code>HostPath</code>：挂载宿主机路径 (日志采集)。</p>
<p><code>NFS/Ceph/GlusterFS</code>：网络存储，数据持久化 (数据库、文件服务)。</p>
<p><strong>28、Pod的生命周期有哪些（指的是Pod的状态及对应场景）</strong></p>
<p><strong>1. Pending（待处理）</strong> Pod 已被创建并存储在 etcd 中，但还未被调度到任何节点上。这个阶段可能是因为集群资源不足、节点选择器不匹配或其他调度限制。</p>
<p><strong>2. ContainerCreating（容器创建中）</strong> Pod 已被调度到某个节点，kubelet 正在为 Pod 中的容器拉取镜像并启动容器。</p>
<p><strong>3. Running（运行中）</strong> Pod 中至少有一个容器正在运行。如果 Pod 中有多个容器，这个阶段表示至少一个已经启动。在这个阶段，容器可能会出现失败或重启的情况。</p>
<p><strong>4. Succeeded（成功）</strong> Pod 中的所有容器都已成功退出，且不会重启。通常用于 Job 和 CronJob 这类一次性任务。</p>
<p><strong>5. Failed（失败）</strong> Pod 中至少有一个容器异常终止（退出码非零）。此时 Pod 不会自动重启（除非配置了重启策略）。</p>
<p><strong>6. Unknown（未知）</strong> 由于某种原因，无法获取 Pod 的状态。通常表示 kubelet 与 API 服务器之间的通信出现问题。</p>
<p><strong>7. CrashLoopBackOff（崩溃回退）</strong> 容器不断崩溃并尝试重启，但重启失败，进入指数级的等待后重试。这通常表示应用程序存在问题。</p>
<p><strong>8.ImagePullBackOff（镜像拉取回退）</strong> kubelet 尝试拉取容器镜像失败，然后进入指数级退避重试。常见原因包括镜像不存在、镜像仓库网络不可达、镜像仓库认证失败或镜像tag错误。这个状态会持续重试，直到镜像拉取成功或 Pod 被删除。</p>
<p><strong>9.Terminating（终止中）</strong> Pod 正在被删除。当收到删除请求后，Pod 会进入这个状态。在这个阶段，kubelet 会给容器一个优雅关闭的机会（由 terminationGracePeriodSeconds 指定，默认30秒），超时后会强制杀死容器。</p>
<p><strong>10.Error（错误）</strong> Pod 处于错误状态，通常表示发生了某种异常。比如 API 对象配置错误、资源不足导致 Pod 无法调度、或者节点状态异常等情况。</p>
<p><strong>其他补充的常见状态：</strong></p>
<p><strong>Evicted（驱逐）</strong> 当节点资源不足时（如内存、磁盘），kubelet 会驱逐 Pod 以释放资源。被驱逐的 Pod 会显示这个状态。</p>
<p><strong>init 0&#x2F;2（初始化）</strong> 初始化容器 –》pause创建之后，主容器之前；表示未初始化完成，正在进行初始化环境</p>
<p><strong>OOMKILL（内存溢出）</strong> OOM内存溢出，</p>
<p><strong>29、新建污点的命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes node1 key=value:NoSchedule</span><br></pre></td></tr></table></figure>

<p><strong>30、PV PVC SC 有没有用过，用在哪些场景&#x2F;业务？</strong></p>
<p>有；PV(持久卷)→PVC(持久卷申请)→SC(存储类自动配置) 用于数据库、文件存储、日志等</p>
<p><strong>PV (持久卷)：</strong> 运维人员定义的存储资源。</p>
<p><strong>PVC (卷申明)：</strong> 开发人员申请存储的请求。</p>
<p><strong>SC (StorageClass)：</strong> 动态创建 PV 的模板 (自动化)。</p>
<p><strong>关系：</strong> Pod 绑定 PVC，PVC 绑定 PV。</p>
<p><strong>31、你们的PV PVC用的是什么？ NFS Ceph 云存储</strong></p>
<p>NFS(共享存储)或Ceph(分布式)或阿里云NAS 根据业务选择</p>
<p><strong>32、控制器有哪些，分别是干嘛的？</strong></p>
<p>Deployment(无状态) </p>
<p>StatefulSet(有状态) </p>
<p>DaemonSet(每节点一个)</p>
<p> Job(一次性) </p>
<p>CronJob(定时)</p>
<p><strong>33、控制器+调度器的需求场景，例如我有20个节点，每个节点都需要跑一个pod副本，怎么做？</strong></p>
<p>使用DaemonSet，自动在每个节点运行一个Pod副本(如日志收集agent)</p>
<p><strong>34、以33题为基础，增加一个需求，新增的Pod需要和拥有app&#x3D;a标签的Pod 跑在一起</strong></p>
<p>使用DaemonSet+podAffinity(requiredDuringScheduling)指定与app&#x3D;a同节点</p>
<p><strong>35、K8S 控制组合题，比如daemonset 搭配调度器的需求场景</strong></p>
<p>DaemonSet部署监控agent→配合nodeSelector选择特定节点(如GPU节点)+污点容忍</p>
<p><strong>36、你们业务&#x2F;应用会使用哪些控制器</strong></p>
<p>Deployment(Web应用) </p>
<p>StatefulSet(数据库) </p>
<p>DaemonSet(监控&#x2F;日志)</p>
<p>CronJob(定时任务)</p>
<p><strong>37、你们配置文件是怎么管理的&#x2F;或者直接问configmap和secret分别用在什么场景</strong></p>
<p>ConfigMap(非敏感配置)、Secret(敏感信息如密码) git&#x2F;Helm管理yaml</p>
<p><strong>ConfigMap：</strong> 存明文配置 (nginx.conf, application.yml)。</p>
<p><strong>Secret：</strong> 存敏感信息，base64 编码 (密码, 证书, Token)。</p>
<p><strong>使用：</strong> 环境变量注入，或挂载为文件。</p>
<p><strong>38、你们是怎么暴露服务的？</strong></p>
<p>ClusterIP(内部) </p>
<p>NodePort(节点暴露)</p>
<p>LoadBalancer(负载均衡) </p>
<p>Ingress(七层路由)</p>
<p><strong>39、你们用的是哪个ingress？</strong></p>
<p>nginx-ingress-controller(开源)</p>
<p>或云平台自带(如阿里云SLB)</p>
<p><strong>40、ingress的工作原理是什么？</strong></p>
<p>ingress-controller监听ingress资源→更新nginx配置→nginx根据规则路由到后端service→转发到Pod</p>
<p><strong>41、ingress怎么做https转发？</strong></p>
<p>申请tls证书→创建Secret资源→ingress spec.tls字段指定证书Secret→rules定义443端口</p>
<p><strong>42、我K8S节点资源充足的，但是为什么我在创建pod的时候一直创建失败呢</strong></p>
<p>排查：namespace资源限制(ResourceQuota)—是否限制了 Pod 数量或 CPU&#x2F;内存总量、亲和性冲突、污点无容忍、镜像拉取失败</p>
<p>LimitRange</p>
<p><strong>43、怎么将http的流量转到https下？</strong></p>
<p>ingress annotations添加<code>nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;</code></p>
<p><strong>44、你们平时是怎么管理K8S集群的？</strong></p>
<p>Rancher&#x2F;KubeSphere(管理平台) </p>
<p>Prometheus(监控) </p>
<p>EFK(日志)ELK </p>
<p>Helm(资源管理)</p>
<p><strong>45、你们的K8S安全管理是什么？</strong></p>
<p>RBAC(认证→role&#x2F;clusterrole、鉴权→rolebinding&#x2F;clusterrolebinding、准入控制) 绑定user&#x2F;group&#x2F;sa</p>
<p><strong>RBAC (基于角色的访问控制)：</strong></p>
<ul>
<li><code>Role/ClusterRole</code>：定义权限 (能干什么)。</li>
<li><code>RoleBinding/ClusterRoleBinding</code>：绑定 (把权限给谁)。</li>
<li><code>ServiceAccount</code>：Pod 的身份。</li>
</ul>
<p><strong>46、低概率问到helm组件、怎么用的?</strong></p>
<p><strong>Helm：</strong> K8S 的包管理工具 (类似 Yum&#x2F;Apt)。</p>
<p><strong>概念：</strong> <code>Chart</code> (包模板), <code>Values</code> (参数配置), <code>Release</code> (运行实例)。</p>
<p><strong>优势：</strong> 统一管理复杂应用的一堆 YAML，一键部署&#x2F;回滚。</p>
<p>chart(tgz包)、repository(仓库)、release(实例)</p>
<p>文件：Chart.yaml(信息)、values.yaml(参数)、template目录(资源模板)</p>
<p>用法：<code>helm install release-name ./chart-dir -n namespace</code></p>
<p>场景：CI&#x2F;CD中复杂应用发布</p>
<p><strong>47、你们采集K8S日志是怎么做的？</strong></p>
<p><strong>方案1 (Sidecar)：</strong> Pod 里多跑一个 Filebeat 容器搜集日志 (资源消耗大)。</p>
<p><strong>方案2 (DaemonSet)：</strong> 每个 Node 跑一个 Logstash&#x2F;Fluentd，挂载宿主机日志目录 (推荐)。</p>
<p><strong>架构：</strong> Pod -&gt; Console&#x2F;File -&gt; Fluentd -&gt; ElasticSearch -&gt; Kibana (EFK)。</p>
<p>EFK(Elasticsearch+Filebeat+Kibana)或ELK+ Logstash Pod日志→Filebeat采集→Elasticsearch存储→Kibana展示</p>
<p><strong>48、K8S内的Pod 怎么抓包？</strong></p>
<p><code>kubectl exec -it pod-name -- tcpdump -i any -w /tmp/capture.pcap</code> 或在Pod内安装tcpdump</p>
<p>gemini:</p>
<p><code>kubectl exec</code> 进入容器安装 tcpdump。</p>
<p>或者进入宿主机，找到容器网卡 (veth pair) 进行抓包。</p>
<p>使用 <code>ksniff</code> 插件。</p>
<p><strong>49、怎么排查k8s故障的？</strong></p>
<p>kubectl get：查看状态</p>
<p>descibe 资源对象 查看event事件</p>
<p>logs 查看日志</p>
<p>详细讲，比如crashloopbackoff，什么环境，怎么做？</p>
<p>业务问题：观测容器日志</p>
<p><strong>50、K8S 常用命令</strong></p>
<p>查看资源</p>
<p>get - 查看资源列表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods              <span class="comment"># 查看 Pod 列表</span></span><br><span class="line">kubectl get svc               <span class="comment"># 查看 Service 列表</span></span><br><span class="line">kubectl get nodes             <span class="comment"># 查看集群节点</span></span><br><span class="line">kubectl get deployment        <span class="comment"># 查看 Deployment</span></span><br><span class="line">kubectl get all               <span class="comment"># 查看所有资源</span></span><br><span class="line">kubectl get pods -n kube-system  <span class="comment"># 查看指定命名空间的 Pod</span></span><br><span class="line">kubectl get [资源类型] [资源对象] [-n namespace] [--show-labels] <span class="comment">#查看标签</span></span><br><span class="line">kubectl get [资源类型] [资源对象] [-n namespace] [- 标签名=标签值] <span class="comment">#查看指定标签名/标签名=标签值</span></span><br></pre></td></tr></table></figure>

<p>kubectl get [资源类型] [资源对象] [-n namespace]</p>
<p>详细查看资源</p>
<p>describe - 查看资源详细信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;      <span class="comment"># 查看 Pod 详细信息</span></span><br><span class="line">kubectl describe svc &lt;service-name&gt;  <span class="comment"># 查看 Service 详细信息</span></span><br><span class="line">kubectl describe node &lt;node-name&gt;    <span class="comment"># 查看节点详细信息</span></span><br></pre></td></tr></table></figure>

<p>创建和删除资源</p>
<p>create、delete、apply</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f &lt;file.yaml&gt;    <span class="comment"># 创建资源</span></span><br><span class="line">kubectl delete pod &lt;pod-name&gt;    <span class="comment"># 删除 Pod</span></span><br><span class="line">kubectl delete svc &lt;svc-name&gt;    <span class="comment"># 删除 Service</span></span><br><span class="line">kubectl delete -f &lt;file.yaml&gt;    <span class="comment"># 删除 YAML 文件中定义的资源</span></span><br><span class="line">kubectl apply -f &lt;file.yaml&gt;     <span class="comment"># 创建或更新资源</span></span><br></pre></td></tr></table></figure>

<p>Pod 操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod-name&gt;                    <span class="comment"># 查看 Pod 日志</span></span><br><span class="line">kubectl logs -f &lt;pod-name&gt;                 <span class="comment"># 实时查看 Pod 日志</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod-name&gt; -- /bin/bash   <span class="comment"># 进入 Pod 容器</span></span><br></pre></td></tr></table></figure>

<p>Deployment 操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment &lt;deployment-name&gt; --replicas=3          <span class="comment"># 扩缩容</span></span><br><span class="line">kubectl rollout status deployment/&lt;deployment-name&gt;             <span class="comment"># 查看更新状态</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment/&lt;deployment-name&gt;            <span class="comment"># 查看版本历史</span></span><br><span class="line">kubectl rollout undo deployment/&lt;deployment-name&gt;               <span class="comment"># 回滚到上一版本</span></span><br><span class="line">kubectl expose deployment &lt;deployment-name&gt; --target-port=&lt;port&gt; --port=&lt;port&gt; -n &lt;namespace&gt;  <span class="comment"># 创建 Service 暴露服务</span></span><br></pre></td></tr></table></figure>

<p>标签操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">kubectl label [资源类型] [资源对象] [-n namespace] [标签名=标签值]</span><br><span class="line"><span class="comment"># 修改标签</span></span><br><span class="line">kubectl label [资源类型] [资源对象] [-n namespace] [标签名=标签值] --overwrite</span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">kubectl label [资源类型] [资源对象] [-n namespace] [标签名=标签值]-</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ansible-prometheus-elk"><a href="#ansible-prometheus-elk" class="headerlink" title="ansible prometheus elk"></a>ansible prometheus elk</h2><h3 id="ansible-面试题："><a href="#ansible-面试题：" class="headerlink" title="ansible 面试题："></a>ansible 面试题：</h3><p><strong>1、自动化工具你们用过哪些？</strong></p>
<p>ansible：批管理&#x2F;配置管理 </p>
<p>git&#x2F;gitlab：代码管理 </p>
<p>jenkins：CI&#x2F;CD </p>
<p>Docker&#x2F;K8S：容器编排</p>
<p><strong>2、ansible 你用过哪些模块？</strong></p>
<p><strong>模块：</strong> <code>shell/command</code> (执行命令), <code>copy</code> (发文件), <code>file</code> (文件属性), <code>yum/apt</code> (装包), <code>service/systemd</code> (服务管理)。</p>
<p>shell、command、copy、file、yum&#x2F;apt、service、template、script、user等</p>
<p><strong>3、ansible-playbook是怎么写的？</strong></p>
<p>剧本，YAML 格式，定义任务编排。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=nginx</span> <span class="string">state=present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=nginx</span> <span class="string">state=started</span> <span class="string">enabled=yes</span></span><br></pre></td></tr></table></figure>

<p><strong>4、ansible 管理多少台服务器，怎么管理的，用ansible 批量处理什么工作？</strong></p>
<p>管理100+台 </p>
<p>通过inventory分组 </p>
<p>批量处理：系统更新、应用部署、配置管理、巡检等</p>
<h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus:"></a>prometheus:</h3><p><strong>1、工作流程是什么</strong></p>
<p>exporter暴露指标→prometheus定时(15s)抓取→TSDB时序库存储→alertmanager告警→grafana展示</p>
<p><strong>2、prometheus 是用什么部署的，怎么监控的项目？</strong></p>
<p>docker部署或K8S部署 </p>
<p>通过exporter(node-exporter、mysql-exporter)</p>
<p>或内建metrics(cadvisor、metrics-server)</p>
<p><strong>3、prometheus 监控哪些对象？怎么监控的？</strong></p>
<p>系统层：CPU、内存、磁盘、网络 </p>
<p>应用层：QPS、RT、错误率、连接数 </p>
<p>业务层：订单、用户、交易量 </p>
<p>方式：exporter、push gateway、内建指标</p>
<p><strong>4、prometheus 监控了哪些具体指标？</strong></p>
<p>node_cpu_seconds_total(CPU) </p>
<p>node_memory_MemAvailable(内存) </p>
<p>http_request_duration_seconds(响应时间) </p>
<p>http_requests_total(请求数) </p>
<p>container_cpu_usage_seconds(容器CPU)等</p>
<p><strong>5、PromQL怎么写？用过哪些聚合函数？</strong></p>
<p>sum(rate(http_requests_total[5m]))：5分钟请求速率求和 avg(container_memory_usage_bytes)：平均内存 </p>
<p>topk(5, rate(…))：排序取top5 分组：<code>sum(rate(...)) by (instance, job)</code></p>
<p><strong>6、PromQL 的数据类型有哪些？</strong></p>
<p>Instant Vector(瞬时向量) </p>
<p>Range Vector(范围向量) </p>
<p>Scalar(标量) </p>
<p>String(字符串)</p>
<p><strong>7、你们的pro用的时序数据库是哪个?</strong></p>
<p>InfluxDB(通用)或OpenTSDB(大规模数据) </p>
<p>一般用prometheus内置TSDB</p>
<p><strong>8、prometheus 监控多少台服务器？prometheus 架构是什么？</strong></p>
<p>监控100+台 架构：多个exporter→prometheus server(单点或高可用)→alertmanager→notification→grafana</p>
<h3 id="日志分析系统"><a href="#日志分析系统" class="headerlink" title="日志分析系统"></a>日志分析系统</h3><p><strong>1、你们采集哪些日志？</strong></p>
<p>应用日志(tomcat&#x2F;nginx) </p>
<p>系统日志(syslog) </p>
<p>容器日志(stdout) </p>
<p>数据库日志(慢查询)</p>
<p><strong>2、你们怎么部署的日志分析系统？</strong></p>
<p>Docker部署或K8S部署ELK(Elasticsearch (存储+搜索) + Logstash (收集+过滤) + Kibana (展示))改进后EFK，如下</p>
<p>EFK Stack(Elasticsearch+Filebeat&#x2F;Fluentd+Kibana)</p>
<p><strong>3、你们使用什么方法采集的日志？</strong></p>
<p>Filebeat(轻量级)采集→Logstash&#x2F;Fluentd处理→Elasticsearch存储→Kibana展示</p>
<p><strong>4、elasticsearch 查询语句是什么？怎么查看索引</strong></p>
<p>查询：GET &#x2F;index&#x2F;_search {“query”:{“match”:{“field”:”value”}}} 查看索引：GET &#x2F;_cat&#x2F;indices</p>
<hr>
<h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><p><strong>1、git 工具用过么，git是干嘛的？你是怎么用的？哪些命令?</strong></p>
<p>版本控制工具；常用命令：</p>
<ul>
<li>git init&#x2F;clone：初始化&#x2F;克隆</li>
<li>git add&#x2F;commit：暂存&#x2F;提交</li>
<li>git push&#x2F;pull：推送&#x2F;拉取</li>
<li>git branch&#x2F;checkout&#x2F;merge：分支操作</li>
<li>git tag：版本标签</li>
<li>git reset&#x2F;reflog：版本回退</li>
</ul>
<p><strong>冲突解决：</strong> 手动修改冲突文件 -&gt; 重新 add&#x2F;commit。</p>
<p><strong>2、代码管理的流程是什么？工作原理？</strong></p>
<p>流程：开发分支→commit→push→code review→merge到main→触发CI </p>
<p>工作原理：git分布式存储，本地仓库→远程仓库，通过commit记录完整历史</p>
<p><strong>CI (持续集成)：</strong> 代码提交 -&gt; 自动构建 (Maven&#x2F;Go build) -&gt; 单元测试 -&gt; 制作 Docker 镜像。</p>
<p><strong>CD (持续部署)：</strong> 镜像推送到仓库 -&gt; 自动更新 K8S YAML -&gt; 应用滚动更新。</p>
<p><strong>工具：</strong> Jenkins, GitLab CI, ArgoCD (GitOps)。</p>
<p><strong>3、你们的代码仓库是什么？怎么使用？</strong></p>
<p>gitlab&#x2F;gitee&#x2F;github </p>
<p>创建项目→clone到本地→开发→push→merge request→review→merge</p>
<p>云计算面试题</p>
<p><a target="_blank" rel="noopener" href="https://share.note.youdao.com/s/IGStx687">https://share.note.youdao.com/s/IGStx687</a></p>
<h1 id="云计算相关知识整合"><a href="#云计算相关知识整合" class="headerlink" title="云计算相关知识整合"></a>云计算相关知识整合</h1><h3 id="一、整体框架"><a href="#一、整体框架" class="headerlink" title="一、整体框架"></a>一、整体框架</h3><p><img src="/./imgs/image-20251211152752810.png" alt="image-20251211152752810"></p>
<h3 id="二、技术栈"><a href="#二、技术栈" class="headerlink" title="二、技术栈"></a>二、技术栈</h3><h4 id="1、Linux"><a href="#1、Linux" class="headerlink" title="1、Linux"></a>1、Linux</h4><p>**核心：**增删改查，排查故障的思路与使用的核心命令</p>
<h5 id="（1）基础命令"><a href="#（1）基础命令" class="headerlink" title="（1）基础命令"></a>（1）基础命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下·运维工作（初级）</span><br><span class="line"><span class="comment">#######新增：</span></span><br><span class="line">基本新增指令：<span class="built_in">mkdir</span> <span class="built_in">touch</span> <span class="built_in">cp</span> <span class="built_in">mv</span> tar vim/vi   <span class="built_in">echo</span> <span class="string">&quot;xxxx&quot;</span> &gt;&gt; xx useradd groupadd yum 等等</span><br><span class="line"></span><br><span class="line"><span class="comment">#######删除：</span></span><br><span class="line">基础指令：<span class="built_in">rm</span></span><br><span class="line">组合删除指令： &gt; /var/log/access.log (删除)  rsync（同步文件内容，达到一致，可以跨节点同步，可以用于删除与数据同步操作）</span><br><span class="line"></span><br><span class="line"><span class="comment">######修改：</span></span><br><span class="line">基础指令: vi/vim sed -i </span><br><span class="line"></span><br><span class="line"><span class="comment">######查询：</span></span><br><span class="line">基础指令：<span class="built_in">ls</span> <span class="built_in">cat</span>  <span class="built_in">which</span>(查询<span class="variable">$PATH</span>中包含的系统可识别的命令是否存在以及绝对路径) rpm find(条件匹配查询)  journalctl（-u指定服务 -f 持续查看） <span class="built_in">tail</span> <span class="built_in">head</span></span><br><span class="line"><span class="comment">#围绕基础资源的查询指令(CPU 内存 I/O)</span></span><br><span class="line"><span class="built_in">du</span> free top/htop <span class="built_in">uptime</span> ifconfig vmstate vmtop lsof <span class="built_in">df</span>  netstat/ss  lsblk iostat iotop fdisk  <span class="built_in">cat</span> /proc/cpuinfo（查看CPU信息）  <span class="built_in">cat</span> /etc/redhat-release（查看操作系统与内核版本） ps （elf|aux） pstree pgrep tcpdump</span><br></pre></td></tr></table></figure>

<p><strong>命令用途分类</strong></p>
<h6 id="基础文件与命令操作-The-Basics"><a href="#基础文件与命令操作-The-Basics" class="headerlink" title="基础文件与命令操作 (The Basics)"></a>基础文件与命令操作 (The Basics)</h6><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录内容。</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>查看文件内容 (适用于小文件)。</td>
</tr>
<tr>
<td><code>head</code></td>
<td>查看文件<strong>头部</strong>内容 (默认为前 10 行)。</td>
</tr>
<tr>
<td><code>tail</code></td>
<td>查看文件<strong>尾部</strong>内容 (默认为后 10 行)，常用于实时日志查看 (<code>tail -f</code>)。</td>
</tr>
<tr>
<td><code>find</code></td>
<td>在文件系统中按条件 (名称、时间、大小等) 查找文件。</td>
</tr>
<tr>
<td><code>which</code></td>
<td>查找命令的<strong>绝对路径</strong>（$PATH），确认系统是否能识别该命令。</td>
</tr>
<tr>
<td><code>rpm</code></td>
<td>Red Hat 系系统 (如 CentOS&#x2F;RHEL) 的软件包管理工具，用于查询、安装、卸载软件包。</td>
</tr>
</tbody></table>
<h6 id="系统状态与性能资源-System-Resource-Status"><a href="#系统状态与性能资源-System-Resource-Status" class="headerlink" title="系统状态与性能资源 (System &amp; Resource Status)"></a>系统状态与性能资源 (System &amp; Resource Status)</h6><table>
<thead>
<tr>
<th><strong>资源类别</strong></th>
<th><strong>关键指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPU&#x2F;内存</strong></td>
<td><code>top</code>&#x2F;<code>htop</code></td>
<td>实时查看系统整体性能 (CPU, 内存, 负载) 和进程资源占用情况。</td>
</tr>
<tr>
<td><strong>CPU</strong></td>
<td><code>cat /proc/cpuinfo</code></td>
<td>查看 CPU 硬件详细信息 (核数、型号等)。</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td><code>free</code></td>
<td>查看系统内存 (物理内存和 Swap) 的使用情况。</td>
</tr>
<tr>
<td><strong>系统</strong></td>
<td><code>uptime</code></td>
<td>查看系统已运行时间、登录用户数和<strong>平均负载 (Load Average)</strong>。</td>
</tr>
<tr>
<td><strong>操作系统</strong></td>
<td><code>cat /etc/redhat-release</code></td>
<td>查看操作系统版本信息。</td>
</tr>
<tr>
<td><strong>其他状态</strong></td>
<td><code>vmstat</code></td>
<td>报告虚拟内存统计信息 (包括 I&#x2F;O 块、CPU 活动等)。</td>
</tr>
</tbody></table>
<h6 id="进程管理与日志-Process-Logs"><a href="#进程管理与日志-Process-Logs" class="headerlink" title="进程管理与日志 (Process &amp; Logs)"></a>进程管理与日志 (Process &amp; Logs)</h6><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ps</code> (<code>elf</code>&#x2F;<code>aux</code>)</td>
<td>查看当前运行的进程状态。<code>aux</code> (BSD 风格) 或 <code>elf</code> (System V 风格) 提供详细信息。</td>
</tr>
<tr>
<td><code>pstree</code></td>
<td>以树状图显示进程之间的关系。</td>
</tr>
<tr>
<td><code>pgrep</code></td>
<td>按名称或其他属性查找进程 ID (PID)。</td>
</tr>
<tr>
<td><code>journalctl</code></td>
<td>查看 <code>systemd</code> 服务的日志。<code>-u</code> 指定服务，<code>-f</code> 实时跟踪。</td>
</tr>
</tbody></table>
<h6 id="存储与网络-Storage-Network"><a href="#存储与网络-Storage-Network" class="headerlink" title="存储与网络 (Storage &amp; Network)"></a>存储与网络 (Storage &amp; Network)</h6><table>
<thead>
<tr>
<th><strong>资源类别</strong></th>
<th><strong>关键指令</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>磁盘空间</strong></td>
<td><code>df</code></td>
<td>查看文件系统 (分区) 的<strong>磁盘空间</strong>使用情况。</td>
</tr>
<tr>
<td><strong>目录大小</strong></td>
<td><code>du</code></td>
<td>查看文件或目录的<strong>磁盘使用量</strong>。</td>
</tr>
<tr>
<td><strong>磁盘 I&#x2F;O</strong></td>
<td><code>iostat</code></td>
<td>报告 CPU 统计信息和设备的输入&#x2F;输出统计信息。</td>
</tr>
<tr>
<td><strong>磁盘 I&#x2F;O</strong></td>
<td><code>iotop</code></td>
<td>实时查看进程级别的磁盘 I&#x2F;O 活动 (类似于 <code>top</code> 看 I&#x2F;O)。</td>
</tr>
<tr>
<td><strong>块设备</strong></td>
<td><code>lsblk</code></td>
<td>列出所有<strong>块设备</strong> (磁盘、分区等)。</td>
</tr>
<tr>
<td><strong>网络配置</strong></td>
<td><code>ifconfig</code>&#x2F;<code>ip a</code></td>
<td>查看或配置网络接口信息 (IP 地址、MAC 地址等)。</td>
</tr>
<tr>
<td><strong>网络连接</strong></td>
<td><code>netstat</code>&#x2F;<code>ss</code></td>
<td>查看网络连接、路由表、接口统计等。<code>ss</code> 是更高效的替代者。</td>
</tr>
<tr>
<td><strong>网络抓包</strong></td>
<td><code>tcpdump</code></td>
<td>抓取和分析网络数据包。</td>
</tr>
<tr>
<td><strong>文件&#x2F;端口</strong></td>
<td><code>lsof</code></td>
<td><strong>列出打开的文件</strong>。常用于查询进程占用的文件或端口。</td>
</tr>
</tbody></table>
<hr>
<h6 id="场景一：高负载与慢响应-High-Load-Slow-Response"><a href="#场景一：高负载与慢响应-High-Load-Slow-Response" class="headerlink" title="场景一：高负载与慢响应 (High Load &amp; Slow Response)"></a>场景一：高负载与慢响应 (High Load &amp; Slow Response)</h6><p>这是最常见的生产环境问题，通常表现为服务响应变慢甚至连接超时。</p>
<p><strong>故障描述</strong></p>
<ul>
<li><strong>现象：</strong> 应用程序响应时间急剧增加，甚至无法访问。</li>
<li><strong>目标：</strong> 确定是 <strong>CPU 瓶颈</strong>、<strong>内存不足</strong>、还是 <strong>I&#x2F;O 瓶颈</strong>导致的。</li>
</ul>
<p>**排查步骤 **</p>
<ol>
<li><strong>快速检查系统整体状态和负载：</strong><ul>
<li><code> uptime</code> → <strong>关键：</strong> 观察 <strong>Load Average</strong> (平均负载)。如果远高于 CPU 核数，说明系统严重过载。</li>
<li><code> free -h</code> → 检查内存是否基本耗尽 (used 接近 total) 或 Swap 是否被大量使用。</li>
</ul>
</li>
<li><strong>定位资源瓶颈和具体进程：</strong><ul>
<li><code>top</code> 或 <code>htop</code> → <strong>关键：</strong><ul>
<li>查看 <strong>%CPU</strong> (哪个进程占用最高？)</li>
<li>查看 <strong>%MEM</strong> (哪个进程占用内存最高？)</li>
<li>查看 <strong>wa</strong> (iowait，如果很高，说明是 I&#x2F;O 瓶颈)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果是 I&#x2F;O 瓶颈 (wa 很高)：</strong><ul>
<li><code>iostat -x 1 5</code> → <strong>关键：</strong> 观察 <code>await</code> (平均 I&#x2F;O 等待时间) 和 <code>%util</code> (磁盘利用率)。</li>
<li><code>iotop</code> → 找到是哪个进程正在执行高强度的磁盘读写。</li>
</ul>
</li>
<li><strong>定位进程路径和日志：</strong><ul>
<li>假设 <code>top</code> 发现 PID 为 <strong>12345</strong> 的进程 CPU 异常：</li>
<li><code>ps -fp 12345</code> → 查看该进程的完整命令和启动路径。</li>
<li><code>lsof -p 12345</code> → 检查该进程打开了哪些文件和网络连接。</li>
<li><code>journalctl -u &lt;服务名&gt; -f</code> → 查看应用服务的实时日志，是否有大量错误或异常请求。</li>
</ul>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>CPU 瓶颈：</strong> 优化代码逻辑，增加缓存，升级硬件或水平扩展。</li>
<li><strong>I&#x2F;O 瓶颈：</strong> 优化磁盘读写，减少日志量，升级 SSD 或使用更专业的存储服务。</li>
</ul>
<hr>
<h6 id="场景二：重大故障：OOMKilled-Out-of-Memory-Killed"><a href="#场景二：重大故障：OOMKilled-Out-of-Memory-Killed" class="headerlink" title="场景二：重大故障：OOMKilled (Out of Memory Killed)"></a>场景二：重大故障：OOMKilled (Out of Memory Killed)</h6><p>这是实际工作中非常重要的故障，系统内核会杀掉占用内存过高的进程以保护自身。</p>
<p><strong>故障描述</strong></p>
<ul>
<li><strong>现象：</strong> 某个关键进程突然消失 (没有正常退出日志)，过了一段时间后又自动重启 (如果配置了自启动)，或者直接宕机。</li>
<li><strong>目标：</strong> 确认进程是被 <strong>OOM Killer</strong> 杀死的，并找到导致内存泄漏&#x2F;溢出的元凶。</li>
</ul>
<p><strong>排查步骤</strong></p>
<ol>
<li><strong>确认 OOMKilled 事件：</strong><ul>
<li><code>journalctl -k -r | grep -i oom</code> → <strong>关键：</strong> 搜索内核日志 ( <code>-k</code> )，查找 <code>Out of memory</code> 或 <code>oom-killer</code> 相关的记录。</li>
<li><strong>或</strong> <code>dmesg | grep -i oom</code> → 确认 OOM killer 杀死了哪个进程 (通常会显示<strong>被杀进程的 PID 和 OOM Score</strong>)。</li>
</ul>
</li>
<li><strong>查看内存使用情况：</strong><ul>
<li><code>free -h</code> → 确认事件发生前内存是否已基本耗尽。</li>
</ul>
</li>
<li><strong>定位被杀进程的详细信息：</strong><ul>
<li>假设被杀进程名为 <code>java</code> 或 <code>nginx</code>：</li>
<li><code>which &lt;进程名&gt;</code> → 确认进程的绝对路径。</li>
<li><code>find / -name &lt;进程名&gt;.log</code> → 查找应用自身日志，看是否有内存溢出 (OOM Exception) 相关的错误。</li>
</ul>
</li>
<li><strong>查看系统的内存配置：</strong><ul>
<li><code>cat /proc/sys/vm/overcommit_memory</code> → 了解内核允许内存超额分配的策略。</li>
</ul>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>根本原因：</strong> 应用程序存在<strong>内存泄漏</strong>或启动时设置的<strong>内存上限过高</strong>。</li>
<li><strong>解决：</strong><ul>
<li><strong>临时：</strong> 增加 Swap 空间，或降低进程的 OOM Score (不推荐，治标不治本)。</li>
<li><strong>治本：</strong> 优化程序代码，设置合理的内存上限 (如 JVM 的 <code>-Xmx</code>)，或升级服务器内存。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="场景三：磁盘空间爆满-Disk-Full"><a href="#场景三：磁盘空间爆满-Disk-Full" class="headerlink" title="场景三：磁盘空间爆满 (Disk Full)"></a>场景三：磁盘空间爆满 (Disk Full)</h6><p>磁盘空间满会导致日志无法写入、应用崩溃、数据库锁死等一系列问题。</p>
<p><strong>故障描述</strong></p>
<ul>
<li><strong>现象：</strong> 应用报错 “No space left on device” 或 “&#x2F;var&#x2F;log” 目录下的日志文件不再更新。</li>
<li><strong>目标：</strong> 确定哪个分区已满，以及是哪个文件&#x2F;目录占用了最大的空间。</li>
</ul>
<p><strong>排查步骤</strong></p>
<ol>
<li><strong>确认哪个分区已满：</strong><ul>
<li><code>df -h</code> → <strong>关键：</strong> 查看 <strong>Use%</strong> 最高的挂载点 (Mounted on)，确定是 <code>/</code> 根目录还是 <code>/home</code> 或 <code>/var/log</code> 等分区。</li>
</ul>
</li>
<li><strong>查找占用空间最大的目录：</strong><ul>
<li>假设 <code>/opt</code> 分区已满：</li>
<li><code>du -sh /opt/*</code> → 逐级查看 <code>/opt</code> 下的一级子目录大小。</li>
<li><code>du -sch /opt/appdata | sort -hr | head -n 10</code> → 深入到目标目录 (<code>/opt/appdata</code>)，列出占用空间最大的前 10 个文件&#x2F;目录。</li>
</ul>
</li>
<li><strong>处理大文件：</strong><ul>
<li><code>find /opt/appdata -type f -size +1G</code> → 查找大于 1GB 的文件 (通常是大日志文件或备份文件)。</li>
</ul>
</li>
<li><strong>处理被删除但仍被占用的文件 (重点，面试高频)：</strong><ul>
<li>如果你删除了一个大文件，但 <code>df -h</code> 空间没有释放，说明该文件仍然被某个进程占用。</li>
<li><code>lsof | grep deleted</code> → 找到那些被标记为 <code>(deleted)</code> 的大文件，以及占用它们的进程 PID。</li>
<li><code>kill -HUP &lt;PID&gt;</code> → <strong>优雅重启</strong> (发 SIGHUP 信号) 占用该文件的进程，或直接 <code>kill &lt;PID&gt;</code> 强制停止，让系统释放文件句柄。</li>
</ul>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>删除：</strong> 清理日志文件 (<code>truncate</code> 或 <code>rm</code>)、旧备份、大缓存文件。</li>
<li><strong>配置：</strong> 配置日志轮转 (<code>logrotate</code>)，防止日志文件无限制增长。</li>
<li><strong>扩容：</strong> 如果是业务数据增长，则需要申请扩容磁盘空间。</li>
</ul>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######常用的指令 </span></span><br><span class="line">ssh （指定密钥文件登录的场景） </span><br><span class="line">⭐⭐tcpdump （网络抓包的指令，可以用于检测网络故障 + 抓取IP 数据包信息---》案例，跑一个nginx，然后使用tcpdump 抓取ens33网卡的网络流量，观测数据。案例2：怎么使用tcpdump 抓取K8S里 Pod 内的流量，命令是什么）</span><br><span class="line">网络检测指令，</span><br><span class="line">telnet （可以检测网络连通性，也可以用于网络监控数据的抓取（使用SNMP简单网络管理协议抓取网络数据，有的时候，面试官会问：你们怎么抓取网络的监控数据的））</span><br><span class="line"></span><br><span class="line">系统资源不足时的排查方法：（Linux阶段）</span><br><span class="line">排查框架：</span><br><span class="line">0、接收到异常信息的</span><br><span class="line">1、观测</span><br><span class="line">如果观测到这个异常，以及更准确的信息（初步的定位范围--》定位到关键点/参数）</span><br><span class="line"><span class="string">&quot;top&quot;</span> <span class="string">&quot;htop&quot;</span> <span class="string">&quot;ps&quot;</span>  <span class="string">&quot;aux/elf | grep &quot;</span>  <span class="string">&quot;uptime&quot;</span></span><br><span class="line"></span><br><span class="line">2、初步的处理方案</span><br><span class="line">① 先判断（描述动作）占资源前10进程中，是什么类型的任务（系统任务、业务任务、异常任务）</span><br><span class="line">② 考虑解决方案</span><br><span class="line">   判断可以关闭--》可以直接关闭</span><br><span class="line">   主进程、子进程都存在---》其他指令来查看这个进程任务的大致情况（htop--》F5）</span><br><span class="line"></span><br><span class="line">3、处理后观测效果</span><br><span class="line">4、持续记录、编写文档（故障文档）</span><br></pre></td></tr></table></figure>

<h6 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h6><p><code>tcpdump</code> 是命令行下的强大网络抓包工具，用于实时监听和分析网络接口上的数据包流量。</p>
<p><strong>核心指令结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i &lt;interface&gt; [options] [filter]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>-i &lt;interface&gt;</code>：</strong> 指定要监听的网络接口 (如 <code>eth0</code>, <code>ens33</code> 等)。</li>
<li><strong><code>-n</code>：</strong> 不进行主机名和端口名解析，直接显示 IP 和端口号 (加快速度)。</li>
<li><strong><code>-nn</code>：</strong> 不解析主机名和端口名。</li>
<li><strong><code>-X</code>：</strong> 以十六进制和 ASCII 码显示数据包内容。</li>
<li><strong><code>-s 0</code>：</strong> 抓取完整的数据包内容 (snaplen 设为 0)。</li>
<li><strong><code>-w &lt;file&gt;</code>：</strong> 将抓包结果写入文件，常用于后续使用 <strong>Wireshark</strong> 分析。</li>
</ul>
<p><strong>案例一：nginx流量观测</strong></p>
<p><strong>目标：</strong> 抓取 <code>ens33</code> 网卡上，与 Nginx 服务（默认 80 端口）相关的网络流量。</p>
<ol>
<li><p><strong>启动抓包：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取 ens33 网卡上所有目标端口或来源端口为 80 的流量，并显示 IP 和端口</span></span><br><span class="line">tcpdump -i ens33 -nn port 80</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行操作：</strong> 在另一终端或本机浏览器访问 Nginx 服务 IP。</p>
</li>
<li><p><strong>观测数据：</strong> 你会看到类似以下格式的数据流，清晰展示了 <strong>TCP 三次握手</strong> (<code>[S]</code>, <code>[.]</code>, <code>[S.]</code>) 和 <strong>HTTP 请求</strong>。</p>
</li>
</ol>
<p><img src="/./imgs/image-20251214175002268.png" alt="image-20251214175002268"></p>
<p><strong>案例二：抓取 K8S Pod 内的流量</strong> </p>
<p>在 Kubernetes 环境中，<code>tcpdump</code> 不能直接在宿主机上通过 <code>docker/crictl</code> 进程名去抓取 <strong>Pod 内部</strong> 的流量。正确的做法是进入 Pod 容器内部执行抓包。</p>
<p><strong>K8S 抓包命令</strong></p>
<ol>
<li><p><strong>找到 Pod 名称：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入 Pod 内部并执行 <code>tcpdump</code>：</strong></p>
<ul>
<li><p>首先，确保目标 Pod 内已安装 <code>tcpdump</code> 工具。</p>
</li>
<li><p>使用 <code>kubectl exec</code> 命令进入 Pod 的 Shell (如果容器内有 Shell)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 Pod 名为 my-app-pod，容器名也为 my-app-container</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-app-pod -c my-app-container -- /bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Pod 内部执行抓包：</strong> K8S&#x2F;Docker 容器内部的网络接口通常是 <strong><code>eth0</code></strong> 或 <strong><code>lo</code></strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取 eth0 接口上所有 TCP 流量</span></span><br><span class="line"><span class="comment"># 注意：这里已经是 Pod 内部了，不需要 sudo</span></span><br><span class="line">tcpdump -i eth0 -nn tcp</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>简化抓包 (更常用，无需进入 Shell)：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在宿主机上执行 Pod 内部的 tcpdump 命令，并抓取 8080 端口的流量</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-app-pod -- tcpdump -i eth0 -nn port 8080 -c 10</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>重点：</strong> Pod 内部的抓包关注的是 <strong>Pod 自身的网络命名空间</strong> 发生的流量，这对于排查 <strong>应用间通信</strong> 或 <strong>Service Mesh</strong> 的问题至关重要。</p>
</blockquote>
<h6 id="telnet的作用？平时怎么抓取网络的监控数据的"><a href="#telnet的作用？平时怎么抓取网络的监控数据的" class="headerlink" title="telnet的作用？平时怎么抓取网络的监控数据的?"></a>telnet的作用？平时怎么抓取网络的监控数据的?</h6><p><code>telnet</code> 通常用于测试特定主机和端口的<strong>连通性</strong>。虽然它本身不再作为安全的远程管理工具使用，但在网络排查中仍然高效。</p>
<p><img src="/./imgs/image-20251214175041366.png" alt="image-20251214175041366"></p>
<p><strong>场景：测试应用端口连通性</strong></p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>目的&#x2F;说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>$ telnet remote_host 80</code></td>
<td>测试远程主机的 80 端口是否开放并可连接。</td>
</tr>
<tr>
<td><code>$ telnet 192.168.1.1 3306</code></td>
<td>测试数据库服务 (MySQL) 的端口连通性。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>排查要点：</strong></p>
<ul>
<li>如果连接成功，显示 <code>Connected to remote_host</code>，说明网络通畅，防火墙也允许该端口流量。</li>
<li>如果连接失败，可能是<strong>防火墙 (iptables&#x2F;firewalld)</strong>、<strong>安全组</strong>或<strong>路由</strong>问题。</li>
</ul>
</blockquote>
<p><strong>平时怎么抓取网络的监控数据的?</strong></p>
<p><strong>第一层：实时、深度的故障排查 (Ad-hoc Analysis)</strong></p>
<p>“在遇到突发网络报错或性能抖动时，我会直接登录服务器，使用命令行工具进行<strong>包级别的抓取</strong>。”</p>
<ul>
<li><strong>流量分析：</strong> 使用 <code>tcpdump</code> 抓取原始数据包（IP、端口、TCP 标志位等）。<ul>
<li><em>示例：</em> “我会用 <code>tcpdump -i eth0 -nn port 80 -w traffic.pcap</code> 抓包，然后导出到 Wireshark 分析是否存在大量重传或延迟。”</li>
</ul>
</li>
<li><strong>连接状态：</strong> 使用 <code>ss</code> 或 <code>netstat</code> 查看当前的 TCP 连接状态（ESTABLISHED、TIME_WAIT 等）。</li>
<li><strong>连通性探测：</strong> 使用 <code>telnet</code> 或 <code>nc (netcat)</code> 验证特定端口的开启情况，使用 <code>ping</code> 或 <code>mtr</code> 观察网络链路的丢包率。</li>
</ul>
<hr>
<p><strong>第二层：自动化的周期性监控 (Automated Monitoring)</strong></p>
<p>“为了实现长期的趋势分析和告警，我们会使用<strong>监控代理 (Agent)</strong> 自动采集数据。”</p>
<ul>
<li><strong>SNMP 采集：</strong> “对于交换机、路由器等硬件网络设备，我们通常开启 <strong>SNMP (简单网络管理协议)</strong>。通过监控软件（如 Zabbix）定时下发 <code>snmpwalk</code> 或 <code>snmpget</code> 命令，采集设备的带宽利用率、接口丢包率、CPU 温度等指标。”<ul>
<li><em>技术细节：</em> “我们会关注 <strong>OID (对象标识符)</strong>，针对不同的硬件厂商配置对应的 MIB 库。”</li>
</ul>
</li>
<li><strong>内建采集器：</strong> “对于 Linux 服务器，我们会部署 <strong>Prometheus 的 Node Exporter</strong>。它会自动读取 <code>/proc/net/dev</code> 文件，抓取网卡的每秒收发包数 (pps) 和吞吐量 (bytes)。”</li>
</ul>
<hr>
<p><strong>第三层：业务层面的网络质量探测 (Application Performance)</strong></p>
<p>“除了基础流量，我们还会监控<strong>业务的端到端网络质量</strong>。”</p>
<ul>
<li><strong>黑盒监控：</strong> “使用 Prometheus 的 <strong>Blackbox Exporter</strong>。它会模拟客户端定期发送 HTTP&#x2F;TCP 请求，监控响应时间、SSL 证书到期时间以及 HTTP 状态码。”</li>
<li><strong>日志分析：</strong> “通过采集 Nginx&#x2F;Envoy 的访问日志（Access Log），分析请求的 Upstream 响应时间，从而判断是网络延迟还是后端应用变慢。”</li>
</ul>
<hr>
<h5 id="（2）Shell-脚本"><a href="#（2）Shell-脚本" class="headerlink" title="（2）Shell 脚本"></a>（2）Shell 脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##写脚本的好习惯</span></span><br><span class="line">初学脚本时，确认环境是干净，然后确定命令可以正确执行。前一条完成后再写脚本</span><br><span class="line">① 要养成生产环境中写脚本的习惯--》路径位置，最好都是用绝对路径来表示</span><br><span class="line">② 变量，在脚本开头先定义好</span><br><span class="line">③ 变量定义的规则： ① 路径比较长的，且多次反复使用的，建议做自定义变量</span><br><span class="line">                  ② 经常需要修改的（IP、路径、文件名字），建议做变量</span><br><span class="line">④ 建议每个执行的操作，写注释</span><br><span class="line">⑤ 脚本使用场景可以更宽阔一些，（加入交互功能）</span><br><span class="line"></span><br><span class="line">Shell脚本用在哪些运维工作</span><br><span class="line">1、重复任务(定期备份、删除、数据同步、巡检、更新发布-》借助ansible 或者 jenkins )</span><br><span class="line">2、用于监控指标数据，管理日志（分割、压缩、归档）</span><br><span class="line">3、复杂任务标准化</span><br><span class="line">4、服务器环境初始化（防火墙 核心防护 系统内核优化 安装常用工具）</span><br></pre></td></tr></table></figure>

<h6 id="案例：shell构建系统监视器"><a href="#案例：shell构建系统监视器" class="headerlink" title="案例：shell构建系统监视器"></a>案例：shell构建系统监视器</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义阈值</span></span><br><span class="line">CPU_THRESHOLD=80</span><br><span class="line">MEMORY_THRESHOLD=80</span><br><span class="line">DISK_THRESHOLD=80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送警告的函数</span></span><br><span class="line"><span class="function"><span class="title">send_alert</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(tput setaf 1)</span>ALERT: <span class="variable">$1</span> usage exceeded threshold! Current value: <span class="variable">$2</span>%<span class="subst">$(tput sgr0)</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环执行监控</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Monitor CPU</span></span><br><span class="line">  cpu_usage=$(top -bn1 | grep <span class="string">&quot;Cpu(s)&quot;</span> | awk <span class="string">&#x27;&#123;print $2 + $4&#125;&#x27;</span>)</span><br><span class="line">  cpu_usage=<span class="variable">$&#123;cpu_usage%.*&#125;</span></span><br><span class="line">  <span class="keyword">if</span> ((cpu_usage &gt;= CPU_THRESHOLD)); <span class="keyword">then</span></span><br><span class="line">    send_alert <span class="string">&quot;CPU&quot;</span> <span class="string">&quot;<span class="variable">$cpu_usage</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Monitor memory</span></span><br><span class="line">  memory_usage=$(free | awk <span class="string">&#x27;/Mem/ &#123;printf(&quot;%3.1f&quot;, ($3/$2) * 100)&#125;&#x27;</span>)</span><br><span class="line">  memory_usage=<span class="variable">$&#123;memory_usage%.*&#125;</span></span><br><span class="line">  <span class="keyword">if</span> ((memory_usage &gt;= MEMORY_THRESHOLD)); <span class="keyword">then</span></span><br><span class="line">    send_alert <span class="string">&quot;Memory&quot;</span> <span class="string">&quot;<span class="variable">$memory_usage</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Monitor disk</span></span><br><span class="line">  disk_usage=$(<span class="built_in">df</span> -h / | awk <span class="string">&#x27;/\// &#123;print $(NF-1)&#125;&#x27;</span>)</span><br><span class="line">  disk_usage=<span class="variable">$&#123;disk_usage%?&#125;</span></span><br><span class="line">  <span class="keyword">if</span> ((disk_usage &gt;= DISK_THRESHOLD)); <span class="keyword">then</span></span><br><span class="line">    send_alert <span class="string">&quot;Disk&quot;</span> <span class="string">&quot;<span class="variable">$disk_usage</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Display current stats</span></span><br><span class="line">  clear</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Resource Usage:&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;-------------------------&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;CPU: <span class="variable">$cpu_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Memory: <span class="variable">$memory_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Disk: <span class="variable">$disk_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">sleep</span> 2</span><br><span class="line">  <span class="comment"># 添加日志</span></span><br><span class="line">  log_entry=<span class="string">&quot;<span class="subst">$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)</span> CPU: <span class="variable">$cpu_usage</span>% Memory: <span class="variable">$memory_usage</span>% Disk: <span class="variable">$disk_usage</span>%&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$log_entry</span>&quot;</span> &gt;&gt; /home/labex/project/resource_usage.log</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214170022336.png" alt="image-20251214170022336"></p>
<h5 id="（3）核心的内容"><a href="#（3）核心的内容" class="headerlink" title="（3）核心的内容"></a>（3）核心的内容</h5><p><strong>面试题</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########常规面试题</span></span><br><span class="line">1、如何查看磁盘空间并排序/并筛选出占用最多的空间的文件？</span><br><span class="line">先选择命令工具用哪个，然后管道符，筛选排序</span><br><span class="line">答：</span><br><span class="line">①<span class="built_in">df</span> -h查看磁盘使用情况</span><br><span class="line">②<span class="built_in">du</span> -sh * | <span class="built_in">sort</span> -hr查看当前目录下文件大小，降序排序</span><br><span class="line">③find 路径 -<span class="built_in">type</span> f <span class="built_in">exec</span> <span class="built_in">ls</span> -<span class="built_in">ln</span> &#123;&#125; \; | <span class="built_in">sort</span> -k5 -hr | <span class="built_in">head</span> -10查看指定目录下最大的10个文件</span><br><span class="line">④<span class="built_in">du</span> -sh */ | <span class="built_in">sort</span> -hr查看指定目录下各子目录占用空间，排序</span><br><span class="line"></span><br><span class="line">⭐⭐2、查看内存、查看cpu、查看网络、查看进程等命令/也会问：你进行日常Linux运维会使用哪些工具？</span><br><span class="line">常用的查询命令：不止是free -m top ps ifconfig netstat（企业中ss用的比较多）</span><br><span class="line">查看文件的：<span class="built_in">cat</span> /proc/cpuinfo(面试问法：查看当前系统CPU核心数量及相关信息的命令)，查看内存的<span class="built_in">cat</span> /proc/meminfo,查看进程类的⭐⭐lsof （查看进程名、查看pid、查看端口号），iotop vmstat ，网络的tcpdump ⭐nload ，tree ，pstree、egrep等等</span><br><span class="line">grep sed awk 视为工具</span><br><span class="line">以上仅表达的是使用Linux的工具作日常运维，可以从写巡检脚本的方向进行介绍对于管理各类资源的工具使用，但是还会涉及以下的内容，这部分也是需要讲的：</span><br><span class="line">例如：git（代码管理）工具、pxe-server工具、wireshark工具，navicat 、protainer 、rancher 、gitlab 、maven、ansible（批量管理） 、grafana（可视化） 等等</span><br><span class="line">查看磁盘I/O的指令</span><br><span class="line">查看网络流量数据的指令</span><br><span class="line"><span class="comment"># 内存</span></span><br><span class="line">free -m              <span class="comment"># 查看内存使用情况</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo    <span class="comment"># 详细内存信息</span></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">top                  <span class="comment"># 实时查看CPU、内存使用情况</span></span><br><span class="line">htop                 <span class="comment"># 更友好的top界面</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo    <span class="comment"># 查看CPU核心数及详细信息</span></span><br><span class="line">lscpu                <span class="comment"># 查看CPU架构信息</span></span><br><span class="line"><span class="comment"># 进程</span></span><br><span class="line">ps aux               <span class="comment"># 查看所有进程</span></span><br><span class="line">ps -ef | grep xxx    <span class="comment"># 查看特定进程</span></span><br><span class="line">pstree               <span class="comment"># 进程树形显示</span></span><br><span class="line">lsof -p [pid]        <span class="comment"># 查看进程打开的文件和端口</span></span><br><span class="line">lsof -i :8080        <span class="comment"># 查看指定端口的进程</span></span><br><span class="line"><span class="comment"># 网络</span></span><br><span class="line">ifconfig / ip addr   <span class="comment"># 查看网络接口</span></span><br><span class="line">netstat -tulnp       <span class="comment"># 查看网络连接和监听端口</span></span><br><span class="line">ss -tulnp            <span class="comment"># netstat的替代品（更推荐）</span></span><br><span class="line">nload                <span class="comment"># 实时查看网络流量</span></span><br><span class="line">tcpdump              <span class="comment"># 抓包分析网络流量</span></span><br><span class="line">iftop                <span class="comment"># 显示网络接口流量</span></span><br><span class="line"><span class="comment"># 磁盘I/O</span></span><br><span class="line">iostat -x 1 5        <span class="comment"># 查看磁盘I/O统计</span></span><br><span class="line">iotop                <span class="comment"># 实时查看磁盘I/O</span></span><br><span class="line">vmstat 1 5           <span class="comment"># 查看虚拟内存统计</span></span><br><span class="line"><span class="comment"># 文件查看</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version    <span class="comment"># 查看内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -a             <span class="comment"># 查看系统信息</span></span><br><span class="line"></span><br><span class="line">⭐⭐3、你们是怎么抓包判断网络问题的，在哪抓，命令+选项是什么？</span><br><span class="line">Linux的抓包工具，提示：包括但不限于tcpdump  wireshark工具。提示:K8S环境如何抓Pod/container的包</span><br><span class="line">答：命令行常用tcpdump 图形化wireshark</span><br><span class="line">抓包位置：①客户端/服务端网卡： 判断请求是否发出或到达</span><br><span class="line">②网关/负载均衡（LVS/Nginx）： 判断中转是否存在丢包或延迟</span><br><span class="line">③K8S 环境： 抓取 Pod 对应的 veth 设备或直接进入 Pod 网络命名空间</span><br><span class="line">tcpdump -i eth0 -nn -s 0 -v port 80 -w /tmp/server.pcap</span><br><span class="line">-i：指定网卡 -nn：不解析主机名和端口（显示数字，提高效率且防DNS阻塞） -s 0：抓取完整包内容（不截断数据部分） -w：将原始包写入文件，方便后续分析。</span><br><span class="line">常用过滤： host &lt;IP&gt;（查指定主机）、tcp port 80（查特定服务）、icmp（查Ping包）。</span><br><span class="line"><span class="comment"># K8S 环境如何抓 Pod 的包</span></span><br><span class="line">方法 A（最快）： 若容器内有工具，直接 kubectl <span class="built_in">exec</span> &lt;pod-name&gt; -- tcpdump -i eth0 -nn。</span><br><span class="line">方法 B（推荐）： 容器内无工具时，使用 kubectl debug 启动一个工具齐全的临时容器共享网络栈。</span><br><span class="line">kubectl debug -it &lt;pod-name&gt; --image=nicolaka/netshoot</span><br><span class="line">方法 C（宿主机级）： 在宿主机找到该 Pod 容器的 PID，进入其网络命名空间抓取。</span><br><span class="line">nsenter -t &lt;PID&gt; -n tcpdump -i eth0</span><br><span class="line"></span><br><span class="line">4、查询命令类的面试题？一般会配合通配符或正则表达式使用</span><br><span class="line">find  <span class="built_in">which</span>  whereis </span><br><span class="line"></span><br><span class="line">5、符号链接中，<span class="built_in">ln</span>的软链接与硬链接命令是什么，有什么区别</span><br><span class="line"><span class="comment"># 软链接（符号链接）:快捷方式，存储源文件路径(删除原文件链接失效)</span></span><br><span class="line"><span class="built_in">ln</span> -s /path/to/original /path/to/link</span><br><span class="line"><span class="comment"># 硬链接:多个指向同一inode的目录项(删除原文件链接任可用)</span></span><br><span class="line"><span class="built_in">ln</span> /path/to/original /path/to/link</span><br><span class="line"></span><br><span class="line">6、Raid 有哪些级别，特性是什么？命令是什么（可能会问）</span><br><span class="line">RAID级别 特性 优势劣势 最小磁盘数</span><br><span class="line">RAID0 条纹化 高性能、容量全利用 无容错，一块坏全损 2</span><br><span class="line">RAID1 镜像 高可靠性、读性能好 磁盘利用率50% 2</span><br><span class="line">RAID5 条纹+奇偶校验 容错+性能+容量平衡 重建速度慢 3</span><br><span class="line">RAID6 双奇偶校验 可容纳2块磁盘故障 写性能降低 4</span><br><span class="line">RAID10 RAID1+RAID0 性能好、可靠性 高磁盘利用率50% 4</span><br><span class="line"></span><br><span class="line">7、组合其他命令的通配符使用，例如：我批量创建10个以demo+[1—10]数字的普通文件，命令是什么？find 查询名称以xxx为开头。大于xxx大小 类型xxx 等条件的文件</span><br><span class="line"><span class="comment"># 批量创建</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span> <span class="built_in">touch</span> demo<span class="variable">$i</span>; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># find查询</span></span><br><span class="line">find /path -name <span class="string">&quot;demo*&quot;</span> -<span class="built_in">type</span> f                    <span class="comment"># 按名称开头</span></span><br><span class="line">find /path -name <span class="string">&quot;*.log&quot;</span> -size +100M                <span class="comment"># 按大小</span></span><br><span class="line">find /path -<span class="built_in">type</span> f -name <span class="string">&quot;test*&quot;</span>                    <span class="comment"># 按类型</span></span><br><span class="line">find /path -<span class="built_in">type</span> f -mtime -7                        <span class="comment"># 7天内修改的文件</span></span><br><span class="line">find /path -<span class="built_in">type</span> f -name <span class="string">&quot;*.bak&quot;</span> -delete            <span class="comment"># 删除符合条件的文件</span></span><br><span class="line"></span><br><span class="line">8、小概率问：yum仓库怎么配？</span><br><span class="line">答：</span><br><span class="line"><span class="comment"># 查看yum仓库配置</span></span><br><span class="line"><span class="built_in">cat</span> /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"><span class="comment"># 备份原配置</span></span><br><span class="line"><span class="built_in">cp</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line"><span class="comment"># 配置yum仓库（以阿里源为例）</span></span><br><span class="line">vi /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"><span class="comment"># 清理缓存并重建缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line">9、<span class="built_in">ls</span> -l 查看到的结果中，每一列代表什么意思？</span><br><span class="line">-rw-r--r-- 1 root root 1024 Dec 14 10:30 filename</span><br><span class="line">第1位：- （文件类型）</span><br><span class="line">第2-4位：rw- （所有者权限：读写）</span><br><span class="line">第5-7位：r-- （所属组权限：只读）</span><br><span class="line">第8-10位：r-- （其他人权限：只读）</span><br><span class="line">第1列文件类型和权限首字符：- 普通文件, d 目录, l 链接</span><br><span class="line">第2列硬链接数指向该inode的目录项数量</span><br><span class="line">第3列所有者文件的拥有者用户名</span><br><span class="line">第4列所有组文件的所属组名</span><br><span class="line">第5列文件大小字节数</span><br><span class="line">第6-8列时间戳修改日期和时间</span><br><span class="line">第9列文件名文件或目录名称</span><br><span class="line"></span><br><span class="line">⭐10、top 中有哪些信息，load avarage 代表什么？ 你一般用top哪些快捷键看用户、cpu、内存资源的？</span><br><span class="line">top - 10:30:45 up 10 days, 3:25, 2 <span class="built_in">users</span>, load average: 0.5, 0.8, 0.9</span><br><span class="line">Tasks: 150 total, 2 running, 148 sleeping, 0 stopped, 0 zombie</span><br><span class="line">%Cpu(s): 20.0 us, 5.0 sy, 0.0 ni, 75.0 <span class="built_in">id</span>, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br><span class="line">KiB Mem: 8167452 total, 5234567 used, 2932885 free, 123456 buffers</span><br><span class="line">KiB Swap: 2097152 total, 0 used, 2097152 free, 4567890 cached</span><br><span class="line"></span><br><span class="line">  PID USER  PR  NI  VIRT  RES  SHR  S %CPU %MEM TIME+ COMMAND</span><br><span class="line"></span><br><span class="line">load average：平均负载，三个数字分别表示1分钟、5分钟、15分钟的平均负载。数值 = 当前运行进程数+等待队列中的进程数，理想值为CPU核心数。</span><br><span class="line">四核CPU：load &lt; 4 正常，&gt; 4 开始拥塞</span><br><span class="line">%CPU：该进程占用的CPU百分比</span><br><span class="line">%MEM：该进程占用的内存百分比</span><br><span class="line">VIRT：进程虚拟内存大小</span><br><span class="line">RES：进程实际占用物理内存</span><br><span class="line">常用快捷键：</span><br><span class="line">P     <span class="comment"># 按CPU使用率排序（默认）</span></span><br><span class="line">M     <span class="comment"># 按内存使用率排序</span></span><br><span class="line">T     <span class="comment"># 按运行时间排序</span></span><br><span class="line">u     <span class="comment"># 按指定用户过滤</span></span><br><span class="line">k     <span class="comment"># 杀死指定PID进程</span></span><br><span class="line">1     <span class="comment"># 显示各CPU核心使用情况</span></span><br><span class="line">H     <span class="comment"># 显示线程</span></span><br><span class="line">c     <span class="comment"># 显示完整命令行</span></span><br><span class="line">q     <span class="comment"># 退出</span></span><br><span class="line"></span><br><span class="line">11、开机启动顺序</span><br><span class="line">答：BIOS POST → Bootloader(GRUB) → Kernel → Init进程 → 运行级别 → 启动服务</span><br><span class="line">BIOS自检：检查硬件</span><br><span class="line">Bootloader：GRUB加载内核到内存</span><br><span class="line">Kernel：Linux内核初始化</span><br><span class="line">Init进程：PID=1，init读取/etc/inittab或systemd</span><br><span class="line">运行级别（SysVinit）或目标单元（systemd）</span><br><span class="line">启动服务：执行相应的启动脚本</span><br><span class="line"></span><br><span class="line">12、syslog 有哪些日志类型？syslog你怎么管理维护的</span><br><span class="line">答：</span><br><span class="line">syslog 的核心逻辑是基于 “来源 (Facility)” 和 “级别 (Severity)” 进行分类的。</span><br><span class="line">常见的日志来源 (Facilities)</span><br><span class="line">用来标识产生日志的子系统：</span><br><span class="line">auth / authpriv： 安全和认证相关信息（如 ssh 登录）。</span><br><span class="line">cron： 定时任务相关日志。</span><br><span class="line">kern： 内核产生的日志（如驱动报错、OOM）。</span><br><span class="line">mail： 邮件系统日志。</span><br><span class="line">syslog： syslog 服务自身产生的日志。</span><br><span class="line">user： 用户级程序产生的日志（默认分类）。</span><br><span class="line">local0 - local7： 预留给用户自定义的类别（常用于 Nginx、Haproxy 等应用）。</span><br><span class="line">日志级别 (Severities)</span><br><span class="line">按严重程度排序（0最高，7最低）：</span><br><span class="line">0 (emerg)： 系统不可用（紧急）。</span><br><span class="line">1 (alert)： 必须立即采取措施。</span><br><span class="line">2 (crit)： 临界状态（严重错误）。</span><br><span class="line">3 (err)： 普通错误。</span><br><span class="line">4 (warning)： 警告。</span><br><span class="line">5 (notice)： 普通但重要的通知。</span><br><span class="line">6 (info)： 信息性消息。</span><br><span class="line">7 (debug)： 调试级信息。</span><br><span class="line"></span><br><span class="line"><span class="comment"># syslog 的管理与维护 (运维实践)</span></span><br><span class="line">在实际工作中，通常使用 rsyslog 或 syslog-ng。维护工作主要围绕：配置分流、日志轮转、集中存储。</span><br><span class="line">A. 配置分流 (Configuration)</span><br><span class="line">修改 /etc/rsyslog.conf，将不同类型的日志发送到指定位置：</span><br><span class="line"><span class="comment"># 规则：来源.级别   存储路径</span></span><br><span class="line">authpriv.* /var/log/secure       <span class="comment"># 登录信息存这里</span></span><br><span class="line">mail.* -/var/log/maillog     <span class="comment"># 邮件信息异步写入</span></span><br><span class="line">cron.* /var/log/cron</span><br><span class="line">local7.* /var/log/boot.log     <span class="comment"># 自定义应用日志</span></span><br><span class="line">B. 日志轮转 (Logrotate)</span><br><span class="line">为防止单个日志文件无限增大撑爆磁盘，必须配置 logrotate。</span><br><span class="line">位置： /etc/logrotate.d/syslog</span><br><span class="line">策略： 按天（daily）或按大小（size）切割，并进行压缩（compress）和保留天数设置（rotate 7）。</span><br><span class="line">C. 远程集中管理 (Centralization)</span><br><span class="line">在大型生产环境，单机日志不便于查询且不安全。</span><br><span class="line">转发： 将所有服务器日志实时转发到远端日志服务器。</span><br><span class="line"><span class="comment"># 在客户端配置转发到远程服务器</span></span><br><span class="line">*.* @192.168.1.100:514    <span class="comment"># 使用 UDP 转发</span></span><br><span class="line">*.* @@192.168.1.100:514   <span class="comment"># 使用 TCP 转发</span></span><br><span class="line">收集： 现代架构通常采用 ELK (Elasticsearch, Logstash, Kibana) 或 Loki。rsyslog 作为数据源，通过采集器发往 Elasticsearch，实现全文检索和可视化监控。</span><br><span class="line">D. 实时维护指令</span><br><span class="line">查看服务状态： systemctl status rsyslog</span><br><span class="line">实时观察： <span class="built_in">tail</span> -f /var/log/messages</span><br><span class="line">查看系统日志（systemd）： journalctl -xe</span><br><span class="line"></span><br><span class="line">⭐13、iptables/firewalld 会不会用，四表五链有哪些，分别是干什么的？</span><br><span class="line">四表：</span><br><span class="line">filter表：数据过滤（默认）</span><br><span class="line">nat表：网络地址转换</span><br><span class="line">mangle表：修改数据包</span><br><span class="line">raw表：跟踪数据包状态</span><br><span class="line">五链：</span><br><span class="line">INPUT：入站流量</span><br><span class="line">OUTPUT：出站流量</span><br><span class="line">FORWARD：转发流量</span><br><span class="line">PREROUTING：路由前处理（nat表）</span><br><span class="line">POSTROUTING：路由后处理（nat表）</span><br><span class="line"><span class="comment"># 查看规则</span></span><br><span class="line">iptables -L -n</span><br><span class="line">iptables -t nat -L -n</span><br><span class="line">iptables -L -n -v</span><br><span class="line"><span class="comment"># 添加规则</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line"><span class="comment"># 删除规则</span></span><br><span class="line">iptables -D INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">⭐14、firewalld 怎么拒绝xxx网段 xxx端口的访问,具体的命令是什么？</span><br><span class="line"><span class="comment"># 拒绝指定网段访问指定端口</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.0/24&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; reject&#x27;</span></span><br><span class="line"><span class="comment"># 拒绝指定IP访问</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;10.0.0.5&quot; reject&#x27;</span></span><br><span class="line"><span class="comment"># 拒绝指定网段的所有流量</span></span><br><span class="line">firewall-cmd --permanent --add-source=192.168.1.0/24 --zone=drop</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看规则</span></span><br><span class="line">firewall-cmd --list-rich-rules</span><br><span class="line"></span><br><span class="line">⭐15、firewalld 怎么放通xxx网络 xxx端口的访问,具体的命令是什么？</span><br><span class="line"><span class="comment"># 放通指定网段的指定端口</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.0/24&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&#x27;</span></span><br><span class="line"><span class="comment"># 简单放通端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line"><span class="comment"># 放通指定IP访问指定端口</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;10.0.0.5&quot; port protocol=&quot;tcp&quot; port=&quot;3306&quot; accept&#x27;</span></span><br><span class="line"><span class="comment"># 放通服务</span></span><br><span class="line">firewall-cmd --permanent --add-service=http</span><br><span class="line">firewall-cmd --permanent --add-service=https</span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 查看允许的端口</span></span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line">firewall-cmd --list-services</span><br><span class="line"></span><br><span class="line">⭐16、firewalld 怎么对内网数据包进行NAT映射（SNAT DNAT）,具体的命令是什么</span><br><span class="line"><span class="comment"># 启用IP转发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"><span class="comment"># SNAT：内网访问外网时修改源IP</span></span><br><span class="line">firewall-cmd --permanent --add-masquerade</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 或指定具体网段</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.0/24&quot; masquerade&#x27;</span></span><br><span class="line"><span class="comment"># DNAT：外网访问内网某服务时，修改目标IP和端口</span></span><br><span class="line"><span class="comment"># 访问本机8080端口转发到内网192.168.1.10:3306</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; destination address=&quot;192.168.1.1&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; forward-port to-addr=&quot;192.168.1.10&quot; to-port=&quot;3306&quot;&#x27;</span></span><br><span class="line"><span class="comment"># 或使用iptables</span></span><br><span class="line">iptables -t nat -A PREROUTING -d 192.168.1.1 -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.10:3306</span><br><span class="line">iptables -t nat -A POSTROUTING -d 192.168.1.10 -p tcp --dport 3306 -j MASQUERADE</span><br><span class="line"><span class="comment"># 保存iptables规则</span></span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line">17、你有没有做过内核优化？做的哪些？</span><br><span class="line">① 网络类的内核优化</span><br><span class="line">② 线程池的内核优化</span><br><span class="line">③ cpu 、内存 、io的资源优化</span><br><span class="line">④ 文件描述符，队列等策略上的优化</span><br><span class="line"></span><br><span class="line">18、DNS类：问主机的Cname P记录A记录是什么</span><br><span class="line">A 记录 (Address Record)</span><br><span class="line">定义： 最基本的 DNS 记录，用于将域名直接映射到一个 IPv4 地址。</span><br><span class="line">作用： 告诉浏览器，访问 www.example.com 时应该去哪个物理服务器 IP。</span><br><span class="line"><span class="comment">#补充AAAA 记录是什么？ 答：类似于 A 记录，但它是指向 IPv6 地址 的。</span></span><br><span class="line"></span><br><span class="line">CNAME 记录 (Canonical Name Record)</span><br><span class="line">定义： 别名记录，用于将一个域名指向另一个域名，而不是 IP 地址。</span><br><span class="line">作用： 当一个服务器有多个业务域名，或者使用 CDN（内容分发网络）时非常有用。如果目标 IP 变了，你只需要修改那个“最终域名”的 A 记录，所有指向它的 CNAME 都会自动同步。</span><br><span class="line"></span><br><span class="line">PTR 记录（P记录） (Pointer Record)</span><br><span class="line">定义： 指针记录，也被称为反向 DNS 查询。</span><br><span class="line">作用： 与 A 记录相反，它是将 IP 地址 映射回 域名。</span><br><span class="line">常见场景：</span><br><span class="line">邮件过滤： 很多邮件服务器会检查发件 IP 是否有对应的 PTR 记录，如果没有，可能会被判定为垃圾邮件。</span><br><span class="line">排查工具： 执行 nslookup 或 dig -x 时使用的就是 PTR 记录。</span><br><span class="line"><span class="comment"># TTL 是什么意思？答：Time To Live（生存时间）。指的是 DNS 记录在缓存服务器中保留的时间（秒）。调低 TTL 可以加快 DNS 变更的生效速度，但会增加 DNS 查询压力。</span></span><br><span class="line"></span><br><span class="line">19、怎么输出本机的主机名、内核版本、cpu内核数量</span><br><span class="line"><span class="comment"># 主机名</span></span><br><span class="line">hostname</span><br><span class="line">hostnamectl status</span><br><span class="line"><span class="comment"># 内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"><span class="built_in">cat</span> /proc/version</span><br><span class="line"><span class="comment"># CPU核心数</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep processor | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="built_in">nproc</span></span><br><span class="line">lscpu | grep <span class="string">&quot;CPU(s)&quot;</span></span><br><span class="line"><span class="comment"># 综合信息</span></span><br><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">hostnamectl</span><br><span class="line"><span class="comment"># 补充操作系统信息cat /etc/redhat-release</span></span><br><span class="line"></span><br><span class="line">⭐20、怎么使用iptables 限制流量访问频次</span><br><span class="line"><span class="comment"># 限制单个IP每分钟最多10次请求</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/minute --limit-burst 20 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"><span class="comment"># 限制单个IP每秒最多3次连接</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/second --limit-burst 10 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"><span class="comment"># 使用recent模块限制（10分钟内最多10个连接）</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --<span class="built_in">set</span> --name http_limit</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --update --seconds 600 --hitcount 10 --name http_limit -j DROP</span><br><span class="line"><span class="comment"># 基于连接数限制</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 10 -j DROP</span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line"><span class="comment">############组合类</span></span><br><span class="line">⭐1、你们的巡检脚本怎么写的？？巡检了哪些资源，怎么做的</span><br><span class="line">答：巡检项目：CPU使用率、内存使用率、磁盘使用率、网络连接数、进程运行状态、系统负载、磁盘I/O、网络流量</span><br><span class="line">实例：</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 系统巡检脚本</span></span><br><span class="line">HOSTNAME=$(hostname)</span><br><span class="line">TIMESTAMP=$(<span class="built_in">date</span> +<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">LOG_FILE=<span class="string">&quot;/var/log/system_check.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;========== 系统巡检 [<span class="variable">$TIMESTAMP</span>] ==========&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># CPU检查</span></span><br><span class="line">CPU_USAGE=$(top -bn1 | grep <span class="string">&quot;Cpu(s)&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;%&#x27;</span> -f1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;CPU使用率: <span class="variable">$&#123;CPU_USAGE&#125;</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$CPU_USAGE</span> &gt; <span class="number">80</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;⚠️ CPU告警: 使用率过高&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 内存检查</span></span><br><span class="line">MEM_USAGE=$(free | grep Mem | awk <span class="string">&#x27;&#123;printf(&quot;%.2f&quot;, ($3/$2)*100)&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内存使用率: <span class="variable">$&#123;MEM_USAGE&#125;</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$MEM_USAGE</span> &gt; <span class="number">85</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;⚠️ 内存告警: 使用率过高&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 磁盘检查</span></span><br><span class="line"><span class="built_in">df</span> -h | grep -v <span class="string">&quot;^Filesystem&quot;</span> | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    USAGE=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;%&#x27;</span> -f1)</span><br><span class="line">    MOUNT=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;磁盘[<span class="variable">$MOUNT</span>]使用率: <span class="variable">$&#123;USAGE&#125;</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$USAGE</span> -gt 85 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;⚠️ 磁盘告警[<span class="variable">$MOUNT</span>]: 使用率过高&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 负载检查</span></span><br><span class="line">LOAD=$(<span class="built_in">uptime</span> | awk <span class="string">&#x27;&#123;print $(NF-2)&#125;&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;,&#x27;</span> -f1)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;系统负载(1min): <span class="variable">$LOAD</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># 进程检查</span></span><br><span class="line">PROCESS_COUNT=$(ps aux | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;运行进程数: <span class="variable">$PROCESS_COUNT</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># 网络连接数</span></span><br><span class="line">CONN_COUNT=$(ss -tan | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;网络连接数: <span class="variable">$CONN_COUNT</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment"># 磁盘I/O检查</span></span><br><span class="line">iostat -x 1 1 | <span class="built_in">tail</span> -n +4 | awk <span class="string">&#x27;&#123;print &quot;磁盘: &quot;$1&quot; I/O使用率: &quot;$4&quot;%&quot;&#125;&#x27;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;========== 巡检完成 ==========&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"></span><br><span class="line">⭐2、网络波动较大，你们是怎么排查故障和解决的？使用哪些工具？（一种类型，还包含磁盘、CPU负载、进程资源不够用的、OOM的）</span><br><span class="line">问题与思路：</span><br><span class="line">① 网络波动较大的话，如何判断是<span class="string">&quot;波动&quot;</span>大？而不是<span class="string">&quot;网络负载压力大&quot;</span>，工具是什么，如何观测到的</span><br><span class="line">② 排查顺序，例如：先ssh进入到服务器，或者直接使用工具观测到，和查看到波动异常的数据</span><br><span class="line">③ 然后通过pid、网络、内存、cpu进程等这类资源管理工具的使用，定位到具体是哪个区域出现了问题</span><br><span class="line">④ 逐个排查引起问题的原因，然后判断后续的解决方案是否影响业务线，然后尝试解决并记录</span><br><span class="line">⑤ 优化后续的运维方法与调整策略，尽量避免此类问题</span><br><span class="line">答：分5步：</span><br><span class="line">① 判断是波动还是压力大</span><br><span class="line">  用nload看流量min/max、ping看延迟stddev、netstat看错误统计</span><br><span class="line">② 排查顺序</span><br><span class="line">  top看系统全景 → nload/netstat看网络 → 找主要进程</span><br><span class="line">③ 定位问题区域</span><br><span class="line">  看CPU/内存/磁盘/网络各个资源，判断瓶颈所在</span><br><span class="line">④ 排查根本原因</span><br><span class="line">  DDoS → 限流</span><br><span class="line">  应用慢 → 优化或重启</span><br><span class="line">  网络不稳定 → 调参</span><br><span class="line">  磁盘IO高 → 优化</span><br><span class="line">⑤ 事后处理</span><br><span class="line">  分析日志 → 找规律 → 优化策略 → 建监控</span><br><span class="line"></span><br><span class="line"><span class="comment">###########场景类：</span></span><br><span class="line"><span class="comment">#给一个具体的案例现象，问你⭐思路与⭐具体命令（逻辑）</span></span><br><span class="line">第一类和上述组合面试题中第2题类似</span><br><span class="line">1、我磁盘明明有空间，但是为什么创建不了文件？</span><br><span class="line">现象</span><br><span class="line"><span class="comment"># 磁盘显示有空间，但touch新文件报错：No space left on device</span></span><br><span class="line"><span class="built_in">touch</span> /data/test.txt</span><br><span class="line"><span class="comment"># 报错！</span></span><br><span class="line">排查思路 + 命令：</span><br><span class="line">第一步：检查磁盘空间</span><br><span class="line">bashdf -h /data        <span class="comment"># 看使用率 &lt; 100% 确实有空间</span></span><br><span class="line">第二步：检查Inode（真正原因）</span><br><span class="line">bashdf -i /data        <span class="comment"># 看IUse% &gt;= 100% → Inode满了！</span></span><br><span class="line"><span class="comment"># 输出示例：IUse% 100% → 问题找到</span></span><br><span class="line">第三步：找出占用Inode最多的文件</span><br><span class="line">bashfind /data -<span class="built_in">type</span> f | <span class="built_in">wc</span> -l        <span class="comment"># 统计文件总数</span></span><br><span class="line">find /data -<span class="built_in">type</span> d | <span class="built_in">wc</span> -l        <span class="comment"># 统计目录总数</span></span><br><span class="line"><span class="comment"># 找占用最多的小文件</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -size -1k | <span class="built_in">wc</span> -l</span><br><span class="line">第四步：清理</span><br><span class="line">bash# 删除临时文件</span><br><span class="line">find /data -name <span class="string">&quot;*.tmp&quot;</span> -delete</span><br><span class="line">find /data -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">type</span> f -size +100M -delete</span><br><span class="line"><span class="comment"># 或清理很久没修改的文件</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -mtime +30 -delete</span><br><span class="line"></span><br><span class="line">2、我要筛选出指定目录下，占用磁盘空间最多的普通文件，怎么找到？（可以配合find + 通配符 找到符合条件的问及那）</span><br><span class="line"><span class="comment"># 最快最简单</span></span><br><span class="line"><span class="built_in">du</span> -sh /data/* | <span class="built_in">sort</span> -hr | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 如果要递归所有子目录</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -size +10M | xargs <span class="built_in">ls</span> -lh | <span class="built_in">sort</span> -k5 -hr</span><br><span class="line"></span><br><span class="line">⭐3、演进版的，某一个目录的磁盘空间满了，我要怎么处理？</span><br><span class="line">① 查看到这个目录占用最大的文件是什么？</span><br><span class="line">② 判断是否可以删除，还是需要先备份部分文件</span><br><span class="line">③ 有一种简单粗暴的解决方法发，如果该内容还需要继续使用，可以先备份、再删除</span><br><span class="line">④ 另一种可行性的方法：先删一部分不用的文件，然后临时创建一个存储卷/或者nfs共享存储，挂载给这个目录（空间就有了），最后再对这个目录内容进行调整优化。</span><br><span class="line">⑤ xxxx</span><br><span class="line">答：</span><br><span class="line">① 查看占用最大的文件</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> /data</span><br><span class="line"><span class="comment"># 查看大文件</span></span><br><span class="line"><span class="built_in">du</span> -sh * | <span class="built_in">sort</span> -hr | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 找出最大的单个文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \; | <span class="built_in">sort</span> -k5 -hr | <span class="built_in">head</span> -1</span><br><span class="line">② 判断是否可以删除</span><br><span class="line"><span class="comment"># 检查文件被使用情况</span></span><br><span class="line">lsof /data/large_file.log      <span class="comment"># 看有没有进程在使用</span></span><br><span class="line"><span class="comment"># 查看文件修改时间</span></span><br><span class="line"><span class="built_in">ls</span> -l /data/large_file.log     <span class="comment"># 很久没改的可以删</span></span><br><span class="line"><span class="comment"># 查看文件内容是否重要</span></span><br><span class="line">file /data/large_file</span><br><span class="line"><span class="built_in">head</span> -10 /data/large_file</span><br><span class="line">③ 简单粗暴方案：备份 + 删除</span><br><span class="line"><span class="comment"># 1. 备份</span></span><br><span class="line">tar -czf backup_$(<span class="built_in">date</span> +%Y%m%d).tar.gz /data/large_file</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">rsync -avz /data/large_file remote_server:/backup/</span><br><span class="line"><span class="comment"># 2. 删除</span></span><br><span class="line"><span class="built_in">rm</span> /data/large_file</span><br><span class="line"><span class="comment"># 3. 清空日志（如果是日志文件）</span></span><br><span class="line">&gt; /data/app.log</span><br><span class="line"><span class="comment"># 4. 重启应用（如果文件被占用）</span></span><br><span class="line">systemctl restart app</span><br><span class="line">④ 扩容方案：挂载新存储（更可靠）</span><br><span class="line"><span class="comment"># 1. 创建备份</span></span><br><span class="line"><span class="built_in">cp</span> -r /data /backup</span><br><span class="line"><span class="comment"># 2. 准备新磁盘（假设为/dev/sdb1）</span></span><br><span class="line">mkfs.ext4 /dev/sdb1</span><br><span class="line"><span class="comment"># 3. 挂载新磁盘</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /data_new</span><br><span class="line">mount /dev/sdb1 /data_new</span><br><span class="line"><span class="comment"># 4. 移动数据到新磁盘</span></span><br><span class="line"><span class="built_in">mv</span> /data/* /data_new/</span><br><span class="line"><span class="comment"># 5. 用bind mount把新磁盘挂到原目录</span></span><br><span class="line">umount /data_new</span><br><span class="line">mount --<span class="built_in">bind</span> /data_new /data</span><br><span class="line"><span class="comment"># 6. 永久配置（编辑/etc/fstab）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/sdb1  /data_new  ext4  defaults  0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/data_new  /data  none  bind  0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line"><span class="comment"># 7. 验证</span></span><br><span class="line"><span class="built_in">df</span> -h /data</span><br><span class="line">⑤ 日志轮转配置（预防措施）</span><br><span class="line"><span class="comment"># 编辑/etc/logrotate.d/app</span></span><br><span class="line">vi /etc/logrotate.d/app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置示例：</span></span><br><span class="line">/var/log/app.log &#123;</span><br><span class="line">    daily              <span class="comment"># 每天轮转</span></span><br><span class="line">    rotate 7           <span class="comment"># 保留7个备份</span></span><br><span class="line">    compress           <span class="comment"># 压缩旧日志</span></span><br><span class="line">    missingok          <span class="comment"># 文件不存在不报错</span></span><br><span class="line">    notifempty         <span class="comment"># 空文件不轮转</span></span><br><span class="line">    size 100M          <span class="comment"># 或按大小轮转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 手动执行</span></span><br><span class="line">logrotate -f /etc/logrotate.d/app</span><br><span class="line"><span class="comment"># 定时清理（编辑crontab）</span></span><br><span class="line">crontab -e</span><br><span class="line">0 1 * * * find /var/log -name <span class="string">&quot;*.log.*&quot;</span> -mtime +30 -delete</span><br><span class="line">答题框架：</span><br><span class="line">答：分4步</span><br><span class="line">① 诊断：用什么工具确认问题</span><br><span class="line">   磁盘: <span class="built_in">df</span> -h / <span class="built_in">du</span> -sh / <span class="built_in">df</span> -i</span><br><span class="line">   内存: ps aux / top / <span class="built_in">cat</span> /proc/status</span><br><span class="line">   网络: nload / netstat / ss</span><br><span class="line">② 定位：问题具体在哪儿</span><br><span class="line">   磁盘: inode满 / 某个文件太大 / 日志堆积</span><br><span class="line">   内存: 内存泄漏 / 缓存未清理</span><br><span class="line">   网络: DDoS / 应用慢 / 网络不稳定</span><br><span class="line">③ 解决：提供2-3个方案</span><br><span class="line">   快速方案（临时）</span><br><span class="line">   长期方案（根本）</span><br><span class="line">④ 事后：如何预防</span><br><span class="line">   建监控 / 调参数 / 优化代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">⭐⭐⭐4、报错--》内存泄漏(OOM KILL)，怎么办？（一般是可以做为故障案例来描述解决方法，也会出现在面试题中）</span><br><span class="line">⭐⭐5、网络现象导致的异常，怎么排查，例如网络压力过大，系统处理卡顿，怎么处理（iptables） </span><br><span class="line">查询：（目的是判断网络资源占用最大的进程是哪个）：使用哪些工具？nload 、日志、监控其他命令和可视化工具。先判断是异常还是激增流量带来的问题</span><br><span class="line">解决：</span><br><span class="line">    ① 使用iptables/firewalld工具做限流，例如10分钟内相同来源 不可以访问超过10次（示例），要有命令</span><br><span class="line">    ② 是否可以做服务临时优化？（nginx类、ACL访问控制类、访问策略类）</span><br><span class="line">    ③ 考虑是否有必要临时扩容？还是已经定义了弹性伸缩，可以自行进行伸缩处理，以面对高并发</span><br><span class="line">事后：总结记录，有必要的情况下要复盘，优化管控流程</span><br></pre></td></tr></table></figure>

<h6 id="OOM-KILL"><a href="#OOM-KILL" class="headerlink" title="OOM KILL"></a>OOM KILL</h6><p><strong>现象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用运行一段时间后，内存占用不断增加，最终被OOM杀死</span><br></pre></td></tr></table></figure>

<p><strong>排查思路 + 命令</strong></p>
<p><strong>第一步：确认是内存泄漏</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控进程内存</span></span><br><span class="line">watch -n 5 <span class="string">&#x27;ps aux | grep [app_name] | awk &quot;&#123;print \$6&#125;&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或持续监控</span></span><br><span class="line">top -p [pid] -b &gt; mem_trend.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析趋势</span></span><br><span class="line"><span class="built_in">tail</span> -20 mem_trend.log | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 如果数字持续增长 → 内存泄漏</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：查看内存详情</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的峰值内存</span></span><br><span class="line"><span class="built_in">cat</span> /proc/[pid]/status | grep -E <span class="string">&quot;VmPeak|VmHWM|VmRSS&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VmPeak: 进程用过的最大虚拟内存</span></span><br><span class="line"><span class="comment"># VmHWM:  进程用过的最大物理内存</span></span><br><span class="line"><span class="comment"># VmRSS:  当前实际物理内存</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：Java应用分析</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出堆转储</span></span><br><span class="line">jmap -dump:live,format=b,file=heap.dump [pid]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看大对象</span></span><br><span class="line">jcmd [pid] GC.class_histogram | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用</span></span><br><span class="line">jmap -heap [pid]</span><br></pre></td></tr></table></figure>

<p><strong>第四步：Python&#x2F;C应用</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">pip install memory_profiler</span><br><span class="line">python -m memory_profiler app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># C应用</span></span><br><span class="line">valgrind --leak-check=full ./app</span><br></pre></td></tr></table></figure>

<p><strong>临时解决方案</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 增加交换空间（临时缓冲）</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1G count=4</span><br><span class="line"><span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定时重启应用</span></span><br><span class="line">crontab -e</span><br><span class="line">0 2 * * * systemctl restart app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置内存限制</span></span><br><span class="line"><span class="comment"># 编辑systemd配置</span></span><br><span class="line">vi /etc/systemd/system/app.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">MemoryLimit=2G</span><br><span class="line">MemoryAccounting=<span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart app</span><br></pre></td></tr></table></figure>

<p><strong>长期解决方案</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 代码审查 - 找泄漏点</span></span><br><span class="line"><span class="comment"># Java常见问题：</span></span><br><span class="line"><span class="comment">#   - 静态集合未清空</span></span><br><span class="line"><span class="comment">#   - 监听器未移除</span></span><br><span class="line"><span class="comment">#   - ThreadLocal未释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启用GC日志</span></span><br><span class="line"><span class="built_in">export</span> JAVA_OPTS=<span class="string">&quot;-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/var/log/gc.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 堆内存参数优化</span></span><br><span class="line">-Xms1024m -Xmx2048m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 建立监控告警</span></span><br><span class="line"><span class="comment"># Prometheus + Grafana</span></span><br><span class="line"><span class="comment"># 当内存 &gt; 85% 时告警</span></span><br></pre></td></tr></table></figure>

<h6 id="网络压力过大"><a href="#网络压力过大" class="headerlink" title="网络压力过大"></a>网络压力过大</h6><p><strong>现象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络流量激增 → 应用响应慢 → 系统卡顿</span><br></pre></td></tr></table></figure>

<p><strong>排查思路 + 命令</strong></p>
<p><strong>第一步：确认网络异常</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时查看流量</span></span><br><span class="line">nload -u h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看连接数</span></span><br><span class="line">netstat -i | grep eth0</span><br><span class="line">ss -tan | grep ESTABLISHED | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看丢包</span></span><br><span class="line">netstat -s | grep -E <span class="string">&quot;dropped|errors&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：定位异常流量来源</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看客户端IP分布</span></span><br><span class="line">netstat -an | grep ESTABLISHED | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d: -f1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment">#   1000 192.168.1.1  ← 某个IP连接特别多 → DDoS迹象</span></span><br><span class="line"><span class="comment">#    500 10.0.0.5</span></span><br><span class="line"><span class="comment">#    300 203.0.113.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓包分析</span></span><br><span class="line">tcpdump -i eth0 -w traffic.pcap host 192.168.1.1 -c 100</span><br><span class="line">tcpdump -r traffic.pcap | <span class="built_in">head</span> -20</span><br><span class="line"><span class="comment"># 都是SYN包 → SYN flood</span></span><br><span class="line"><span class="comment"># 都是HTTP → 恶意爬虫</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：找出占用网络最多的进程</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的连接数</span></span><br><span class="line">netstat -tulnp | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="built_in">cut</span> -d/ -f2 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment">#   200 nginx       ← nginx占用最多</span></span><br><span class="line"><span class="comment">#   150 java</span></span><br><span class="line"><span class="comment">#    50 mysql</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<p><strong>① iptables限流</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制单个IP的并发连接数</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m connlimit --connlimit-above 50 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制请求频率（每秒10个请求）</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/second --limit-burst 20 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制特定网段（10分钟内最多100个连接）</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --<span class="built_in">set</span> --name http_limit</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m recent --update --seconds 600 --hitcount 100 --name http_limit -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拒绝特定IP</span></span><br><span class="line">iptables -A INPUT -s 192.168.1.1 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>

<p><strong>② firewalld限流</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拒绝恶意IP</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.1&quot; reject&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制特定网段访问频率</span></span><br><span class="line">firewall-cmd --permanent --add-rich-rule=<span class="string">&#x27;rule family=&quot;ipv4&quot; source address=&quot;0.0.0.0/0&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; limit value=&quot;10/m&quot; accept&#x27;</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-rich-rules</span><br></pre></td></tr></table></figure>

<p><strong>③ Nginx应用层限流</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=one burst=<span class="number">20</span> nodelay;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>④ TCP参数优化</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=8192</span><br><span class="line">sysctl -w net.core.somaxconn=32768</span><br><span class="line">sysctl -w net.ipv4.tcp_fin_timeout=30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久生效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_max_syn_backlog=8192&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<p><strong>⑤ 扩容&#x2F;弹性伸缩</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是合法流量激增：</span></span><br><span class="line"><span class="comment"># - 立即增加服务器（垂直扩展或水平扩展）</span></span><br><span class="line"><span class="comment"># - Kubernetes自动扩展：HPA (Horizontal Pod Autoscaler)</span></span><br><span class="line"><span class="comment"># - 云厂商自动扩展：Auto Scaling Group</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时扩容示例（Docker）</span></span><br><span class="line">docker run -d --name nginx2 -p 8081:80 nginx</span><br><span class="line"><span class="comment"># 更新负载均衡器指向两个实例</span></span><br></pre></td></tr></table></figure>

<p><strong>事后处理</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 分析日志找规律</span></span><br><span class="line"><span class="built_in">tail</span> -10000 /var/log/nginx/access.log | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 统计访问路径</span></span><br><span class="line"><span class="built_in">tail</span> -10000 /var/log/nginx/access.log | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 复盘总结</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;事件时间: 2024-12-14 14:00-15:30&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;表现: 流量激增10倍，应用响应慢&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;根因: IP 192.168.1.1 发起攻击&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;处理: 用iptables限流，10分钟恢复&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;预案: 建立自动化限流规则，提高告警阈值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 优化策略</span></span><br><span class="line"><span class="comment"># - 增加CDN缓存（减少源站压力）</span></span><br><span class="line"><span class="comment"># - 启用WAF（防火墙规则）</span></span><br><span class="line"><span class="comment"># - 优化应用性能（减少响应时间）</span></span><br><span class="line"><span class="comment"># - 建立自动扩展（应对突发流量）</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2、应用服务"><a href="#2、应用服务" class="headerlink" title="2、应用服务"></a>2、应用服务</h4><p><strong>企业通用架构如下：</strong></p>
<p><img src="/./imgs/image-20251211152818758.png" alt="image-20251211152818758"></p>
<h5 id="（1）LVS-keepalived-Nginx-体系"><a href="#（1）LVS-keepalived-Nginx-体系" class="headerlink" title="（1）LVS + keepalived + Nginx 体系"></a>（1）LVS + keepalived + Nginx 体系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#####从运维角度来看</span><br><span class="line">这部分属于&quot;前端&quot;，一般作为门户入口，提供外网---》内网 通讯，中间会进行内外网映射。</span><br><span class="line">从外网---》内网的区域，分为以下部分</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251211152831594.png" alt="image-20251211152831594"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">话术：</span><br><span class="line">用户访问到我们内网前，会先经过前端的一个<span class="string">&quot;缓存区域&quot;</span>,一般会使用CDN技术（内容分发网络），其实就是做了一个前端缓存服务器，这个是一套完整的系统，对于我们运维来说，只需要申请CDN的资源，需要校对缓存区需要存储的图片、文件，做好流量监控与流量的数据抓取分析。</span><br><span class="line">CDN的基本原理如下图</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251211152843532.png" alt="image-20251211152843532"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">运维的工作（CDN）：</span><br><span class="line">申请CDN 资源（云上），把数据与前端对接好，明确要对哪些数据进行CDN加速处理就可以了，后续要跟进监控（流量），抓取数据进行分析</span><br><span class="line">如果CDN没有命中数据，那么则会进入到企业内网，到达LVS+keepliaved（线下）或者到达SLB(云上)</span><br><span class="line">技术栈：</span><br><span class="line">CDN 加速 + LVS+keepalived（云上SLB） + Nginx（动静分离+反向代理）</span><br><span class="line">分解：</span><br><span class="line">LVS+keepalived : </span><br><span class="line">   ① LVS有哪些类型?（直接路由、NAT、⭐DR）</span><br><span class="line">   ② 为什么用LVS + keepalived ？（这里问了2个问题---第一个问题是 为什么使用LVS 做LB 第二个问题是为什么使用LVS + KEEPALIVED） </span><br><span class="line">   提示：这个时候各位需要想到: LVS NGINX haproxy SLB区别</span><br><span class="line">   答：因为但以负载均衡能力来看，LVS是远超于Nginx 的，Nginx（稳定抗高并发能力，大约为20W左右），而我们业务的“日活”量可能超过1 5w，并发流量大约会达到25~30w，甚至更多</span><br><span class="line">      lvs+keepalived ： 做主备容灾，避免单点故障，更重要的原因是，LVS 自己是L4层的代理无法很好的实现L7层代理，一般配合keepalived做L7层，并且keepalived 还有健康检查机制。</span><br><span class="line"></span><br><span class="line">keepalived 什么协议？怎么进行健康检查？怎么实现高可用的？</span><br><span class="line">   答：ICMP协议实现健康检查 VRRP协议实现高可用</span><br><span class="line">   高可用具体怎么实现的？基本原理是啥？</span><br><span class="line">   使用VIP作为外部访问的IP地址 优先级 VIP（虚拟IP。只会存在于优先级最高的节点） 热备组（主-备关系） VIP漂移机制 kp节点宕机，优先级下降，触发VIP漂移 </span><br><span class="line"></span><br><span class="line">Nginx（动静分离+反向代理）</span><br><span class="line"> Nginx 怎么实现动静分离？</span><br><span class="line"> 通过监听80/443端口，匹配URL访问的入口（进入对应的server &#123;&#125;区域），匹配server中的location ，如果是静态请求，则自己处理，如果是动态请求，则反向跳转到后端的应用/业务服务器上进行处理</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">##### Nginx 面试题 </span></span><br><span class="line">⭐⭐1、你们的Nginx 做过哪些优化？？</span><br><span class="line">在介绍的过程中，Nginx的使用</span><br><span class="line">- 安全加固（隐藏版本号、运行权限最小化user nginx nginx）</span><br><span class="line">- 性能优化（配置缓存expires、压缩Gzip、超时 KeepAlive、进程数worker_processes）</span><br><span class="line">- 资源保护（防盗链）</span><br><span class="line">- 日志管理（定期切割清理）</span><br><span class="line"></span><br><span class="line">⭐2、Nginx 怎么做反向代理的？？怎么做负载均衡的？？Nginx 有哪些负载均衡的算法？</span><br><span class="line">答：静态资源由nginx直接处理后返回，动态资源由 Nginx 将请求转发给后端的服务器（如 Tomcat、Python、PHP）。</span><br><span class="line">配置http中的upstream后端地址池，server中的proxy_pass</span><br><span class="line"><span class="comment"># 负载均衡算法</span></span><br><span class="line">轮询 (Round Robin - 默认)： 每个请求按时间顺序逐一分配到不同服务器。</span><br><span class="line">加权轮询 (Weight)： 指定轮询几率，权重越高，分配到的请求越多（用于服务器性能不均的场景）。</span><br><span class="line">IP Hash (ip_hash)： 根据客户端 IP 的 Hash 结果分配，确保同一客户端始终访问同一台后端服务器（解决 Session 保持问题）。</span><br><span class="line">最少连接 (least_conn)： 将请求分配到当前活动连接数最少的服务器（适合后端处理时间长短不一的场景）。</span><br><span class="line"></span><br><span class="line">⭐3、你们管理Nginx 遇到过哪些故障？？怎么处理的？？？（准备2个有价值的，不要写在搭建过程中遇到的故障）</span><br><span class="line"><span class="comment"># 案例 1：大量 504 Gateway Timeout（上游超时故障）</span></span><br><span class="line">现象： 业务高峰期，前端页面频繁出现 504 错误，监控显示 Nginx 负载不高，但后端业务响应变慢。</span><br><span class="line">排查思路：</span><br><span class="line">查日志： <span class="built_in">tail</span> -f /var/log/nginx/error.log。发现大量 upstream timed out (110: Connection timed out) <span class="keyword">while</span> reading response header from upstream。</span><br><span class="line">看连接： 使用 netstat -ant | grep TIME_WAIT | <span class="built_in">wc</span> -l 发现大量连接处于等待状态。</span><br><span class="line">因果分析： 504 通常意味着 Nginx 等待后端（如 PHP-FPM 或 Java）响应超时。由于后端数据库慢查询，导致请求堆积，超出了 Nginx 预设的 proxy_read_timeout。</span><br><span class="line">解决方案：</span><br><span class="line">临时避险： 适当调大 proxy_read_timeout 和 proxy_connect_timeout，缓解报错。</span><br><span class="line">核心治理： 配合研发优化后端接口耗时和数据库索引；在 Nginx 端开启 Keepalive，保持与后端长连接，减少频繁握手的开销。</span><br><span class="line"><span class="comment"># 案例 2：大量 502 Bad Gateway（后端服务崩溃或配置冲突）</span></span><br><span class="line">现象： 网站瞬间无法访问，报错 502。</span><br><span class="line">排查思路：</span><br><span class="line">检查后端状态： 首先确认后端服务（如 Tomcat）是否存活。发现后端存活，但 Nginx 依然报错。</span><br><span class="line">检查文件句柄： 查看内核日志 dmesg 发现 TCP: possible SYN flooding on port 80. Sending cookies. 且 Nginx 报错 open() ... failed (24: Too many open files)。</span><br><span class="line">因果分析： 高并发下，Linux 系统默认的**文件描述符上限（Limit）**太低，导致 Nginx 无法建立新连接。</span><br><span class="line">解决方案：</span><br><span class="line">系统级： 修改 /etc/security/limits.conf，将 soft nofile 和 hard nofile 调至 65535。</span><br><span class="line">Nginx 级： 在全局配置中设置 worker_rlimit_nofile 65535;。</span><br><span class="line">重载配置： nginx -s reload。</span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line">502 找 Nginx 和后端之间的连通性： “后端挂了”、“防火墙拦截”或“连接数满了”。</span><br><span class="line">504 找后端业务的处理速度： “后端太慢了”、“数据库慢查询”或“程序死锁”。</span><br><span class="line"></span><br><span class="line">⭐4、20x、30x、40x、50x 这些Nginx状态码代表的是什么意思? ⭐跟进问几个状态码 ： 404 301/302 502（bad gateway） 403 </span><br><span class="line">- **2xx（成功）**：请求成功处理</span><br><span class="line">- **3xx（重定向）**：需要进一步操作完成请求</span><br><span class="line">- **4xx（客户端错误）**：请求有问题，服务器拒绝处理</span><br><span class="line">- **5xx（服务器错误）**：服务器处理请求时出错</span><br><span class="line">404 Not Found 资源不存在/权限</span><br><span class="line">403 Forbidden 禁止访问（无权限）</span><br><span class="line">301 Moved Permanently 永久重定向（如HTTP→HTTPS）</span><br><span class="line">302 Found 临时重定向（登录后重定向到首页）</span><br><span class="line">502 Bad Gateway 网关错误（反向代理后端出错）</span><br><span class="line"></span><br><span class="line">5、nginx、 haproxy 、lvs 、SLB区别是什么?</span><br><span class="line">LVS (Linux Virtual Server): 它是 Linux 内核的一部分（四层）。它不看你的 HTTP 请求内容，只看 IP+端口。因为不需要解析复杂的协议头，所以它的处理速度最快，是承载海量流量的“大门”。</span><br><span class="line">HAProxy: 它比 Nginx 更纯粹地专注于“负载均衡”。在高并发下，它的稳定性比 Nginx 略好，且健康检查机制（探测后端服务器死活）非常精准。</span><br><span class="line">Nginx: 虽然也做负载均衡（七层），但它更多被当作 Web 服务器使用。它最强大的地方在于处理 HTTP 协议细节，比如重写 URL、压缩图片、灰度发布等灵活配置。</span><br><span class="line">SLB (Server Load Balancer): 这不是一个开源软件，而是公有云的产品（通常底层是由 LVS + Tengine/Nginx 封装的）。它最大的特点是免运维，自带跨可用区高可用，能自动对接云服务器的增减。</span><br><span class="line">总结：</span><br><span class="line">LVS 做最前端的流量分发（抗压），Nginx/HAProxy 做具体的业务调度（精细），而 SLB 是在云环境下为了省事和高可用直接购买的交钥匙方案。</span><br><span class="line"></span><br><span class="line">⭐6、你们业务的平均吞吐量多少？平时在线流量多少，高并发时期流量大概多少，以及你们的nginx 怎么配置的？？（这个配置的效果是什么）</span><br><span class="line">（nginx 怎么应对高并发、nginx 平时做了哪些策略来应对流量正常访问、流量激增等场景---弹性伸缩、负载均衡、流量管控、限流降低等策略）</span><br><span class="line">答：</span><br><span class="line">平均吞吐量（QPS/TPS）： 平时业务大约在 500 - 2,000 QPS。</span><br><span class="line">平时在线流量： 日活跃用户 (DAU) 约 10万 - 50万，峰值带宽占用约 200Mbps - 500Mbps。</span><br><span class="line">高并发时期（如大促、活动）： 流量会激增 5 - 10 倍，QPS 达到 10,000 - 20,000+。</span><br><span class="line"><span class="comment"># Nginx 如何配置应对高并发？</span></span><br><span class="line">Nginx 的优化通常分为系统层优化、性能参数调优和高可用策略。</span><br><span class="line">A. 性能参数调优（榨干硬件性能）</span><br><span class="line">worker_processes  auto;      <span class="comment"># 自动根据 CPU 核数启动进程</span></span><br><span class="line">worker_cpu_affinity auto;    <span class="comment"># 将进程绑定到特定 CPU 核，减少上下文切换</span></span><br><span class="line">worker_rlimit_nofile 65535;  <span class="comment"># 突破系统文件描述符限制</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  10240; <span class="comment"># 单个进程允许的最大连接数</span></span><br><span class="line">    use epoll;                 <span class="comment"># 使用 epoll 事件模型（Linux 下最高效）</span></span><br><span class="line">    multi_accept on;           <span class="comment"># 允许一次性接受多个新连接</span></span><br><span class="line">&#125;</span><br><span class="line">配置效果： 确保 Nginx 能够充分利用多核 CPU，且在高并发连接涌入时，不会因为“文件句柄不足”或“排队严重”导致丢包。</span><br><span class="line"></span><br><span class="line">B. 开启长连接（Keepalive）</span><br><span class="line">http &#123;</span><br><span class="line">    keepalive_timeout 65;       <span class="comment"># 客户端长连接超时时间</span></span><br><span class="line">    keepalive_requests 1000;    <span class="comment"># 一个长连接最多允许的请求数</span></span><br><span class="line">    </span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 192.168.1.10:8080;</span><br><span class="line">        keepalive 32;           <span class="comment"># Nginx 与后端服务器保持的长连接数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">配置效果： 减少 TCP 三次握手和四次挥手的频率，显著降低 CPU 消耗和响应延迟。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应对流量正常与激增的策略</span></span><br><span class="line">1. 负载均衡策略（平时流量分配）</span><br><span class="line">轮询/加权轮询： 平时最常用，按比例分配给后端。</span><br><span class="line">Least_conn： 优先发给连接数最少的服务器，适合后端处理能力不一的情况。</span><br><span class="line">Ip_hash： 解决 Session 保持问题。</span><br><span class="line">2. 限流降级（激增流量管控）</span><br><span class="line">当流量超过后端承载能力时，必须在 Nginx 层“挡住”多余请求，防止后端数据库宕机。</span><br><span class="line"><span class="comment"># 定义限流区域，每秒只允许 10 个请求</span></span><br><span class="line">limit_req_zone <span class="variable">$binary_remote_addr</span> zone=mylimit:10m rate=10r/s;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        <span class="comment"># 允许突发 5 个请求，不延迟处理</span></span><br><span class="line">        limit_req zone=mylimit burst=5 nodelay; </span><br><span class="line">        error_page 503 = @fallback; <span class="comment"># 触发限流后降级处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">配置效果： 即使受到恶意刷票或流量瞬间暴涨，系统也能以预设的速度处理请求，超出的部分直接返回 503 或跳转到静态降级页面。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动静分离与缓存</span></span><br><span class="line">策略： 所有的图片、JS、CSS 静态资源由 Nginx 直接读取磁盘或推送到 CDN。</span><br><span class="line">效果： 减少 70% 以上的请求到达后端 Tomcat/PHP，极大地释放了计算资源。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合 K8S 的弹性伸缩 (HPA)</span></span><br><span class="line">话术： “单纯靠 Nginx 调优是有上限的。在实际生产中，我们会配合 K8S 的 HPA (Horizontal Pod Autoscaler)：</span><br><span class="line">监控触发： 当 Prometheus 监测到 Pod 的 CPU 使用率超过 60% 或并发连接数达到阈值。</span><br><span class="line">自动扩容： K8S 会自动启动更多副本。</span><br><span class="line">动态发现： Nginx (或 Ingress Controller) 会通过 Service 自动感知新加入的 Pod 节点，并将流量瞬间分摊出去。</span><br><span class="line">缩容： 流量高峰过后，自动回收资源节省成本。”</span><br><span class="line"></span><br><span class="line"><span class="comment">#####实际场景问题：</span></span><br><span class="line">1、客户反馈/监控观测到，页面报错了返回码是xxx，怎么处理(F12)</span><br><span class="line">2、客户反馈/监控观测到，能看到页面，但图片读不出来，怎么处理</span><br><span class="line">3、客户反馈/监控观测到，文件的下载渠道首先下载缓慢，然后直接失败，怎么处理</span><br><span class="line">4、客户反馈/监控观测到，页面账号的数据和实际的数据不一致，是什么情况，怎么处理</span><br><span class="line">5、我想在代理给后端时，显示真实IP怎么做？（小概率）</span><br><span class="line">问到的话，直接说：在匹配proxy_pass 跳转的时候，添加配置，把转发给后端地址池的源IP，改位客户IP就可以</span><br><span class="line">6、你们使用过Nginx的哪些模块？</span><br><span class="line">worker_processes （工作进程数）</span><br><span class="line">events： 事件（事件驱动模块）</span><br><span class="line">http/https </span><br><span class="line">ngx_http_charset_module: （字符集）</span><br><span class="line">gzip_module（gzip压缩模块）</span><br><span class="line">log_module（日志访问记录）</span><br><span class="line">proxy_module （反向代理模块）</span><br><span class="line">rewrite_module （rewrite模块）</span><br><span class="line">ssl_module （SSL证书加密模块）</span><br><span class="line">PS：注意：Server &#123;&#125; global全局配置 不是模块，它是区域</span><br></pre></td></tr></table></figure>

<h5 id="（2）Spring-cloud-boot-微服务"><a href="#（2）Spring-cloud-boot-微服务" class="headerlink" title="（2）Spring cloud&#x2F;boot 微服务"></a>（2）Spring cloud&#x2F;boot 微服务</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">走话术，nginx 反向代理给后端----》微服务gateway api 网关 ---》AUTH认证 ----》 找到nacos 注册中心 ---》运行的Jdk环境---》加载Serverlet 代码（动态任务处理的代码类型）---》根据动态请求,通过JDBC 驱动，调用后端的数据库API（redis / mysql 等等）</span><br><span class="line">简版框架如下：</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251211152901133.png" alt="image-20251211152901133"></p>
<h5 id="（3）中间件缓冲层"><a href="#（3）中间件缓冲层" class="headerlink" title="（3）中间件缓冲层"></a>（3）中间件缓冲层</h5><p><strong>中间件主要由</strong>：Redis 或者MQ（消息队列）组成</p>
<p><strong>Redis 内存缓存型数据库&#x2F;非关系型数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">运维的工作：</span><br><span class="line">1、搭建（短期）Redis 集群（集群模式有几种？你们用的哪个？原理是什么？）</span><br><span class="line">  ① 哨兵 </span><br><span class="line">  ② cluster </span><br><span class="line">  ③ 主从复制</span><br><span class="line">使用哪个??</span><br><span class="line">答： 可以说哨兵，或者说Cluster模式</span><br><span class="line">  哨兵模式：至少6台节点，原理：每个哨兵单独监控redis集群、通过hello频道同步信息，故障时，单个哨兵判断master故障了，会定义为主观下线、多个哨兵判断master故障则定义为客观下线，客观下线后，通过RAFT算法进行选举投票，选择出新master顶上来，然后其他redis集群同步新master位置</span><br><span class="line">  cluster集群模式：至少6个节点，原理:需要奇数数量的master，cluster集群模式让master相互进行健康检查、判断彼此存活性，同时每个master都会有至少1台自己的从服务器，并且实现<span class="string">&quot;主从复制&quot;</span>,当一个master 挂掉了，其他master 也会进行选举，选择出最适合成为新master的slave服务器，同时挂掉的Master也会指定一个自己的slave 服务器来继承slots(哈希槽)。保证集群的完整性。</span><br><span class="line">  PS： slots 哈希槽有16384个（0~16383），哈希槽会平均分配给cluster的每个master，数据通常，是以分布式的方式，存储在master的哈希槽中的。</span><br><span class="line"> </span><br><span class="line">2、Redis 持久化（怎么做？有什么区别？怎么触发的）</span><br><span class="line"> 答：AOF和 RDB</span><br><span class="line">区别？</span><br><span class="line"> AOF 记录写与删的语句</span><br><span class="line"> RDB 相当于快照</span><br><span class="line">Redis 优先会使用AOF 恢复数据，没有的话，使用RDB恢复数据</span><br><span class="line">怎么触发的？</span><br><span class="line"> </span><br><span class="line">3、Redis 常规优化(问的比较少)</span><br><span class="line">①、碎片清理</span><br><span class="line">监控碎片率，超过1.5时执行SHUTDOWN SAVE重启</span><br><span class="line"></span><br><span class="line">⭐②、持久化的压缩、合并、备份删除机制</span><br><span class="line">一、 RDB（快照模式）的机制</span><br><span class="line">RDB 是一次全量数据的二进制压缩备份。</span><br><span class="line">1. 压缩机制 (Compression)</span><br><span class="line">LZF 算法： 默认情况下，Redis 会对 RDB 文件进行 LZF 压缩。</span><br><span class="line">对象压缩： 对于字符串（String），如果长度超过一定阈值，Redis 会尝试将其压缩存储。</span><br><span class="line">配置项： rdbcompression <span class="built_in">yes</span>（建议开启，虽然消耗一点 CPU，但极大地节省磁盘 I/O 和空间）。</span><br><span class="line">2. 备份机制 (Backup)</span><br><span class="line">Copy-On-Write (COW)： 当触发 bgsave 时，Redis 调用 fork() 产生子进程。子进程拥有父进程的内存快照。</span><br><span class="line">写时复制： 只有在父进程修改内存数据时，才会复制物理内存页。这保证了快照的一致性，且不阻塞主线程。</span><br><span class="line">二、 AOF（日志追加模式）的机制</span><br><span class="line">AOF 记录的是每一条写命令。随着时间推移，文件会变得非常臃肿，因此需要“合并”机制，即 AOF 重写 (Rewrite)。</span><br><span class="line">1. 合并机制 (AOF Rewrite)</span><br><span class="line">原理： 重写并不读取旧的 AOF 文件，而是读取当前的内存数据库状态。</span><br><span class="line">示例： 如果你对一个计数器 INCR 了 100 次，旧 AOF 有 100 行记录，重写后的 AOF 只需一条 SET counter 100。</span><br><span class="line">触发条件：</span><br><span class="line">auto-aof-rewrite-percentage 100（当前文件比上次重写后增长了 100%）。</span><br><span class="line">auto-aof-rewrite-min-size 64mb（文件至少达到 64MB）。</span><br><span class="line">2. 压缩与混合持久化 (Hybrid Persistence)</span><br><span class="line">混合模式： 在 Redis 4.0 之后，通常开启 aof-use-rdb-preamble <span class="built_in">yes</span>。</span><br><span class="line">效果： AOF 文件的前半部分是 RDB 格式的二进制数据（压缩率极高），后半部分是重写期间产生的增量 AOF 命令（纯文本）。这兼顾了加载速度和数据完整性。</span><br><span class="line">三、 备份与删除策略 (Backup &amp; Deletion)</span><br><span class="line">Redis 自身不负责历史备份的管理和旧文件的自动删除，这通常需要运维配合脚本完成。</span><br><span class="line">1. 备份策略 (The Industry Standard)</span><br><span class="line">RDB 定期备份： * 每小时备份一次最近的 RDB，存放在本地不同目录。</span><br><span class="line">每天备份一次 RDB，同步到远端对象存储（如阿里云 OSS、AWS S3）。</span><br><span class="line">AOF 备份： 由于 AOF 实时增长，通常只在重写完成后备份最新的 AOF 副本。</span><br><span class="line">2. 删除机制 (Retention)</span><br><span class="line">由于 Redis 持久化文件（尤其是 AOF）可能撑爆磁盘，运维通常采用以下手段：</span><br><span class="line">定时清理： 使用 find 命令结合 cron 任务。</span><br><span class="line"><span class="comment"># 删除 7 天前的备份文件</span></span><br><span class="line">find /data/redis/backup/ -name <span class="string">&quot;*.rdb&quot;</span> -mtime +7 -<span class="built_in">exec</span> <span class="built_in">rm</span> -f &#123;&#125; \;</span><br><span class="line">磁盘空间报警： 配合监控（Prometheus/Zabbix）监控 /var/lib/redis 所在分区的 <span class="built_in">df</span> 使用率。</span><br><span class="line"></span><br><span class="line">⭐③、过期删除与淘汰策略</span><br><span class="line">根据场景选择合适的淘汰策略（缓存场景推荐allkeys-lru）</span><br><span class="line">当Redis内存达到`maxmemory`限制时，触发淘汰策略：</span><br><span class="line">noeviction      禁止删除，满时报错（**严格场景**）    </span><br><span class="line">allkeys-lru     删除最少使用的key（**缓存场景推荐**） </span><br><span class="line">volatile-lru    仅在设置TTL的key中删除最少使用        </span><br><span class="line">volatile-ttl    删除剩余生存时间最短的key             </span><br><span class="line">allkeys-random  随机删除任意key                       </span><br><span class="line">⭐④、为了减少缓存穿透、缓存击穿、雪崩的常见故障的发生概率，做的对应优化策略</span><br><span class="line">1.根据数据量合理规划实例大小：保证物理内存 &gt; Redis最大使用内存，一般建议不超过70-80%</span><br><span class="line">2.使用Hash结构存储：Redis对小Hash结构有优化（压缩存储）</span><br><span class="line">3.设置key的过期时间(TTL)</span><br><span class="line">4.合理设置maxmemory</span><br><span class="line">5.关闭或限制swap</span><br></pre></td></tr></table></figure>

<p><strong>MySQL 关系型数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">运维工作：</span><br><span class="line">1、搭建（短期）</span><br><span class="line">① 搭建单台</span><br><span class="line">② 搭建集群（主从复制、读写分离--一般由开发完成、高可用--MHA MM+keepalived ）</span><br><span class="line">  主从复制原理：2日志 3线程，原理如下：</span><br><span class="line"> 两日志：主-二进制日志</span><br><span class="line">      从-中继日志</span><br><span class="line"> 三线程：</span><br><span class="line">    ① 主-dump线程，把二进制日志中更新的部分推送给I/O线程</span><br><span class="line">    ② 从-I/O线程：</span><br><span class="line">      第一，负责监听主-二进制日志，一旦发生更新，I/O会通知dump线程，传输SQL语句到从服务器</span><br><span class="line">      第二：I/O 线程会负责把更新的二进制的内容，同步写入到自己（从服务器）的中继日志中 </span><br><span class="line">    ③ 从-SQL线程</span><br><span class="line">      负责把中继日志中的SQL语句，在自己数据库内跑一边</span><br><span class="line">简单话术:</span><br><span class="line">两日志三线程，主节点发数更新，从节点I/O会同步主节点二进制日志内容到本地中继日志中，然后SQL线程把中继日志中SQL语句，写入到自己数据库内部</span><br><span class="line">   追加面试题：MySQL 主从复制日志记录模式有几种？默认哪个？（基于SQL 基于row 基于mixed（混合）），主从复制的处理类型（异步、全同步、半同步）</span><br><span class="line">   ⭐可能会追加，怎么做的：</span><br><span class="line">       答：启动主库二进制日志，开启从库复制同步，设置serverid等</span><br><span class="line">       创建从库访问用户给予权限</span><br><span class="line">       启动从库的中继日志，设置serverid</span><br><span class="line">       从库连接主库并配置同步位置等</span><br><span class="line">       启动并验证</span><br><span class="line">  读写分离原理：主--》负责写任务 从--》读任务，客户端访问读写分离的代理，代理服务器，会根据后端数据库池，将读写任务交给后端的mysql服务器进行处理</span><br><span class="line">  </span><br><span class="line">  MHA 高可用原理：</span><br><span class="line">  MHA 自动监控Master，故障时找最新的Slave提升为Master，同时转移VIP，应用无感知自动转移，10-30秒完成。</span><br><span class="line">  MHA 怎么搭建的：  </span><br><span class="line">1. 基础配置 | 关闭防火墙，安装MySQL 5.7                                    </span><br><span class="line">2. 一主两从 | 配置主从复制（Master-Slave1-Slave2）（配置my.cnf⭐，grant给予slave，mha权限） </span><br><span class="line">3. 安装MHA  | 安装node和manager组件                                        </span><br><span class="line">4. SSH认证  | 配置各节点间无密码认证                                       </span><br><span class="line">5. MHA配置  | 复制管理脚本，配置failover脚本和app1.cnf，在配置文件中指定   </span><br><span class="line">6. 启动监控 | 启动MHA manager进程                                          </span><br><span class="line">7. 故障测试 | 模拟故障验证自动切换                                         </span><br><span class="line"></span><br><span class="line">③ 容灾备份</span><br><span class="line">  mysql集群，备份一套在其他的机房中（可用区），并持续进行数据同步</span><br><span class="line">  也可以使用DTS（云产品）将本地数据库同步给云上数据库</span><br><span class="line">2、SQL管理（增删改查）</span><br><span class="line"> ① 增：create、insert</span><br><span class="line"> ② 删：drop、delete、<span class="built_in">truncate</span></span><br><span class="line"> ③ 改：alter update </span><br><span class="line"> ④ 查：<span class="keyword">select</span> desc</span><br><span class="line">⭐⭐⭐SQL操作中的<span class="keyword">select</span> 查询语句</span><br><span class="line">① 查询指定库.表中xx字段等于xx值的表内容 </span><br><span class="line">② 子查询、內连查询语句、外连查询、左连接右连接查询语句、多表联合查询的语句（条件判断），会问具体的sql、也会问子查询和外连接有什么区别这类问题</span><br><span class="line">   查询语句的结构中，可以在多表相连的条件判断语句中，给每个表定义别名，然后再分组，order by 然后进行<span class="built_in">where</span> 条件判断查询，这个面试题主要是把查询语句的结构要整明白，可以使用以下方式表示结构关系：</span><br><span class="line"> （<span class="keyword">select</span> 字段名/* from a库名.a表 inner <span class="built_in">join</span> b库.b表 <span class="built_in">where</span> a表字段=b表字段）</span><br><span class="line"></span><br><span class="line">3、MySQL优化</span><br><span class="line"> ① SQL语句优化</span><br><span class="line">  可以先使用慢“⭐查询日志”筛选出需要进行优化的语句，explain 校对一下SQL语句有哪些部分可以进行优化（修改查询条件、添加索引、添加一些组合查询的方式等）</span><br><span class="line">  索引类型：主键、唯一、组合、全文、外键</span><br><span class="line">  创建索引依据：</span><br><span class="line">粗略的小结（主要用于给各位回答面试题时的过渡性介绍）</span><br><span class="line">一般情况：① 频繁使用且唯一性较高、更新频次较低的字段，适合添加索引 ② 唯一性弱、更新频繁的字段不要增加索引</span><br><span class="line"> ② 线程/线程池优化</span><br><span class="line"> ③ 日志管理优化，（异步、半同步、同步---对应场景）、日志轮转</span><br><span class="line"> ④ mysql服务器的系统资源优化</span><br><span class="line"> ⑤ 权限优化</span><br><span class="line">⭐⭐⑥ 系统内核优化</span><br><span class="line">⭐⭐⑦ 慢查询语句的优化</span><br><span class="line">⭐⭐⑧ 索引优化</span><br><span class="line">⭐explain 检测一个语句执行过程，索引、查看是否需要使用其他的存储引擎(优化sql语句),线程池的优化（具体的执行语句）</span><br><span class="line">4、定期备份和恢复 </span><br><span class="line">备份类型：物理/逻辑备份 --》备份的方式： 全备、增备、差备 --》备份工具：mysqldump 全量、日志备份mysqlbinlog 增备</span><br><span class="line">5、故障处理 </span><br><span class="line">至少准备2个（不要是搭建过程中的，要有排查过程，PS：各位可以使用我给的故障文档，然后让工具给各位输出5个生产故障）</span><br><span class="line">【故障1：查询超慢导致应用响应慢】</span><br><span class="line">现象：下单接口响应从100ms飙升到3s</span><br><span class="line">排查：</span><br><span class="line">  1. 确认是DB问题（processlist查看连接数)</span><br><span class="line">  2. 查慢查询日志找出具体SQL</span><br><span class="line">  3. EXPLAIN分析发现全表扫描</span><br><span class="line">  4. 发现缺少索引</span><br><span class="line">解决：</span><br><span class="line">  1. 立即杀死慢查询（缓解症状）</span><br><span class="line">  2. 创建索引idx_date_status(<span class="built_in">date</span>,status)</span><br><span class="line">  3. 修改应用逻辑只查需要的列</span><br><span class="line">学到：</span><br><span class="line">  - 新增查询字段必须同时创建索引</span><br><span class="line">  - 定期审查慢查询日志</span><br><span class="line">  - 建立SQL审查流程</span><br><span class="line"></span><br><span class="line">【故障2：主从复制中断】</span><br><span class="line">现象：Slave一直没在同步，Slave_IO_Running=No</span><br><span class="line">排查：</span><br><span class="line">  1. SHOW SLAVE STATUS查看错误</span><br><span class="line">  2. 发现复制用户认证失败</span><br><span class="line">  3. 检查Master上repl用户权限</span><br><span class="line">  4. 发现Master重启后权限未生效</span><br><span class="line">解决：</span><br><span class="line">  1. Master上执行FLUSH PRIVILEGES</span><br><span class="line">  2. Slave上STOP SLAVE、START SLAVE</span><br><span class="line">  3. 验证Slave_IO_Running和Slave_SQL_Running都=Yes</span><br><span class="line">优化：</span><br><span class="line">  - 启用GTID自动处理日志位置</span><br><span class="line">  - 添加复制延迟告警</span><br><span class="line">  - Master重启脚本中加入权限刷新步骤</span><br></pre></td></tr></table></figure>

<p><strong>MQ消息队列</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运维工作，主要在于怎么查询Kafka 的topic主题，pattition分区和数据以及如何监控</span><br><span class="line">面试题，会问：</span><br><span class="line"><span class="number">1</span>、你们用过消息队列中间件吗？怎么用的?（问消息队列部署在什么位置，干嘛用的？）--》一般来说使用消息队列的场景，都是数据量比较庞大的场景（看咱们自己的项目业务是否符合）</span><br><span class="line"><span class="number">2</span>、如果回答用过kafka，追问kafka的组件有哪些？？怎么查询topic主题，pattition？</span><br><span class="line"><span class="number">3</span>、你们kafka的生产者和消费者是谁?</span><br></pre></td></tr></table></figure>

<h4 id="3、支持、管理工具"><a href="#3、支持、管理工具" class="headerlink" title="3、支持、管理工具"></a>3、支持、管理工具</h4><p><strong>以下部分，是企业通用的项目架构(主要突出的是“支持、管理工具“ )</strong></p>
<p><img src="/./imgs/image-20251214145249600.png" alt="image-20251214145249600"></p>
<h5 id="1-ELK-体系"><a href="#1-ELK-体系" class="headerlink" title="(1) ELK 体系"></a>(1) ELK 体系</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ELK 日志分析管理系统</span><br><span class="line">采集日志------》处理日志数据----》存储、管理日志数据-----》展示日志数据</span><br><span class="line"></span><br><span class="line">运维工程师的工作：</span><br><span class="line"><span class="number">1</span>、日志分析管理系统的选型与部署</span><br><span class="line"><span class="number">2</span>、索引数据查询（mysql -》 数据库--二维表--记录行 ES -》索引--类型--文档） </span><br><span class="line">  索引怎么查询（test 索引数据）</span><br><span class="line"><span class="number">3</span>、明确采集哪些日志，有的时候，开发、测试、部分客户需要看日志，我们会需要把日志保存出来给到对方</span><br><span class="line"><span class="number">4</span>、kiabana 看一些报错日志，排查故障，包括--》用于写文档（故障文档）</span><br><span class="line">PS: ELK 可能会问到你们使用什么版本的（<span class="number">7.7</span>左右的版本）</span><br></pre></td></tr></table></figure>

<p><strong>ELK 基本架构：</strong></p>
<p><img src="/./imgs/image-20251214145313386.png" alt="image-20251214145313386"></p>
<p><strong>ELK架构选型</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ELK 采集日志---》对于文件日志的采集，主要还是会集成filebeat采集器---》Es + filebeat + logstash + kiabna/GRAFANA 日志采集与分析</span><br><span class="line">ELK 采集容器日志---》 EFK --》 ES + FLUENTED + LOGSTASH + KIBANA/GRAFANA </span><br><span class="line">ELK怎么部署的：</span><br><span class="line">   ① 传统：</span><br><span class="line">     源码安装（tar） </span><br><span class="line">   ② Docker容器：</span><br><span class="line">     容器跑采集器，kibana跑容器中，es放容器外</span><br><span class="line">     PS：业务容器可以选择和fluented 集成，采集和输出日志</span><br><span class="line">   ③ K8S：</span><br><span class="line">     可以选择跑在同一个Pod里面，使用fluented 采集（存储--》emptydir 共享业务容器的日志文件）</span><br><span class="line">   ④ 云：</span><br><span class="line">     例如阿里云：SLS 日志服务（如下图）</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145331322.png" alt="image-20251214145331322"></p>
<p><strong>ELK面试题：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">⭐⭐<span class="number">1</span>、你们用ELK采集哪些日志，怎么采集的？</span><br><span class="line">采集哪些日志？</span><br><span class="line">① 应用程序</span><br><span class="line">② 中间件日志</span><br><span class="line">③ 数据库日志</span><br><span class="line">⑤ 容器日志</span><br><span class="line">⑥ 业务日志 log4j（java）</span><br><span class="line">⑦ 系统日志 syslog</span><br><span class="line">以上，每个类型要说具体的服务具体的日志名称（<span class="number">1</span>-<span class="number">2</span>个）</span><br><span class="line">怎么采集的？一般使用以下方式采集日志</span><br><span class="line">logstash 通用，但不是所有场景都适用</span><br><span class="line">filebeat 采集文件系统的日志</span><br><span class="line">fluented 采集容器的日志</span><br><span class="line">提示：问具体采集哪些日志：可以直接看人家公司产品/阿里云的文档，来描述我们采集哪些日志</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、ES 查询索引的语句是什么？</span><br><span class="line">提示：库（索引）、表（类型）、记录行（文档）</span><br><span class="line">索引(Index) = 数据库</span><br><span class="line">类型(Type)  = 表格</span><br><span class="line">文档(Doc)   = 记录行</span><br><span class="line">字段(Field) = 列</span><br><span class="line">常用查询：</span><br><span class="line">- 精确查询：term查询</span><br><span class="line">- 模糊查询：match查询</span><br><span class="line">- 范围查询：range（时间范围）</span><br><span class="line">- 组合查询：bool must/should</span><br><span class="line">- 聚合统计：aggs分组统计</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、一般是组合搭配来问，比如：你们简历项目工作中描述道：K8S日志收集管理---&gt;追问，怎么收集的?怎么管理的？一般看哪些啊？</span><br><span class="line">K8s日志采集</span><br><span class="line">采集：Filebeat DaemonSet（轻量推荐）</span><br><span class="line">存储：Elasticsearch（按日期分索引）</span><br><span class="line">管理：ILM生命周期（热温冷分层）</span><br><span class="line">查询：Kibana仪表板</span><br><span class="line">告警：ERROR日志 &gt; 阈值、存储 &gt; <span class="number">80%</span></span><br><span class="line">答：我们用Filebeat采集K8s日志 → 存到Elasticsearch → 用Kibana查询分析</span><br><span class="line">主要看：ERROR日志数量、各Pod日志分布、响应时间、存储容量。</span><br><span class="line">设置了ILM策略自动清理旧日志，ERROR日志超过阈值会触发告警。</span><br></pre></td></tr></table></figure>

<h5 id="2-监控服务"><a href="#2-监控服务" class="headerlink" title="(2) 监控服务"></a>(2) 监控服务</h5><p><strong>主要是了解：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">运维工程师做传统运维监控的工作：</span><br><span class="line"><span class="number">1</span>、选型监控产品与部署（传统业务-使用zabbix 更多 ）</span><br><span class="line"><span class="number">2</span>、监控哪些对象？指标数据有哪些（SRE <span class="number">4</span>个黄金指标）</span><br><span class="line">延迟(Latency)</span><br><span class="line">   - 处理请求花费的时间</span><br><span class="line">   - 例：API响应时间 &lt; <span class="number">200ms</span></span><br><span class="line">流量(Traffic)</span><br><span class="line">   - 系统处理的请求量</span><br><span class="line">   - 例：QPS、吞吐量(Throughput)</span><br><span class="line">错误率(Errors)</span><br><span class="line">   - 失败请求占比</span><br><span class="line">   - 例：<span class="number">5</span>xx错误率 &lt; <span class="number">0.1%</span></span><br><span class="line">饱和度(Saturation)</span><br><span class="line">   - 资源使用程度</span><br><span class="line">   - 例：CPU &lt; <span class="number">70%</span>、内存 &lt; <span class="number">85%</span></span><br><span class="line"><span class="number">3</span>、数据采集方法有哪些？？（代理插件、脚本、不同协议的相关工具采集--》SNMP TELNET）</span><br><span class="line">Agent（Push推送</span><br><span class="line">Server拉取（Pull）</span><br><span class="line">脚本采集</span><br><span class="line">SNMP</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、zabbix 内部的使用（不讲了）</span><br><span class="line"></span><br><span class="line">zabbix 的工作模式（Server端--<span class="attr">--agent</span>代理端）</span><br><span class="line">⭐ zabbix 和prometheus 区别？</span><br><span class="line">简略提示：zabbix 和prometheus 擅长采集的被监控对象数据是有一定区别的</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>维度</th>
<th>Zabbix</th>
<th>Prometheus</th>
</tr>
</thead>
<tbody><tr>
<td><strong>采集模式</strong></td>
<td>Push推送</td>
<td>Pull拉取</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>传统IDC、混合云</td>
<td>云原生、K8s、微服务</td>
</tr>
<tr>
<td><strong>架构复杂度</strong></td>
<td>中等（Agent+Server+DB）</td>
<td>简单（只需Server）</td>
</tr>
<tr>
<td><strong>数据库</strong></td>
<td>MySQL&#x2F;PostgreSQL</td>
<td>内置时间序列DB</td>
</tr>
<tr>
<td><strong>部署难度</strong></td>
<td>中等（每台机器装Agent）</td>
<td>简单（只部署Server）</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>中等（多Agent管理复杂）</td>
<td>高（服务发现自动）</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>实时推送（秒级）</td>
<td>定时拉取（分钟级）</td>
</tr>
<tr>
<td><strong>历史数据</strong></td>
<td>保留完整</td>
<td>保留有限（需Thanos）</td>
</tr>
<tr>
<td><strong>告警机制</strong></td>
<td>内置强大</td>
<td>需Alertmanager</td>
</tr>
<tr>
<td><strong>学习成本</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>企业级</strong></td>
<td>支持（收费版）</td>
<td>开源（社区）</td>
</tr>
</tbody></table>
<h4 id="4、云原生基础环境"><a href="#4、云原生基础环境" class="headerlink" title="4、云原生基础环境"></a>4、云原生基础环境</h4><h5 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">云计算：用户可以通过网络，获取到需要的计算资源、网络资源、存储资源，特性是：按量计费、弹性伸缩、租赁行为(云平台)</span><br><span class="line"></span><br><span class="line">云计算有几种模式：IAAS、PASS、SAAS （FAAS、MAAS） 如下图<span class="number">1</span></span><br><span class="line">以上是云平台的<span class="number">3</span>种常规的商业模式（基础款）</span><br><span class="line"></span><br><span class="line">云平台部署、管理方式（<span class="number">3</span>种基础）：私有云、公有云、混合云</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145458163.png" alt="image-20251214145458163"></p>
<p><strong>公有云：</strong></p>
<p><img src="/./imgs/image-20251214145511456.png" alt="image-20251214145511456"></p>
<p><strong>私有云：</strong></p>
<p><img src="/./imgs/image-20251214145533875.png" alt="image-20251214145533875"></p>
<p><strong>混合云：</strong> </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种： 私有云+公有云混合</span><br><span class="line">第二种：多个不同的公有云混合（阿里云+华为云 一起使用）</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145550169.png" alt="image-20251214145550169"></p>
<h5 id="虚拟化-容器技术"><a href="#虚拟化-容器技术" class="headerlink" title="虚拟化&#x2F;容器技术"></a>虚拟化&#x2F;容器技术</h5><p>企业常规虚拟化产品（开源）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">虚拟化产品一般作为底座，基础底座技术：IBM公司的产品、XEN、EXSI、KVM、hyper-v</span><br><span class="line">虚拟化产品--》全虚拟化方案（纯使用软件模拟硬件的功能）</span><br><span class="line">            半虚拟化方案（软件+硬件结合实现虚拟化的效果）</span><br><span class="line">            硬件辅助虚拟化技术（主要使用硬件的性能+直接集成在硬件上的软件产品赖完成虚拟化功能）</span><br><span class="line">            轻量级虚拟化技术----》容器</span><br><span class="line">容器技术和虚拟化技术之间区别：</span><br><span class="line">⭐本质：容器是进程级别，共享宿主机内核的，虚拟机技术，完整OS(操作系统)级别，完整的操作系统内核。</span><br><span class="line">区别如图：       </span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251214145610564.png" alt="image-20251214145610564"></p>
<p><strong>容器技术</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">容器技术有多个不同的类型,市面上常用的类型有：</span><br><span class="line">Docker 、 POSTMAN 、Containerd</span><br><span class="line">这三种容器技术，只会Docker 也可以，但是需要理解容器、镜像的原理</span><br><span class="line"></span><br><span class="line">运维的工作：</span><br><span class="line"><span class="number">1</span>、镜像、容器、存储、监控、<span class="selector-tag">image</span>仓库、日志、网络、多容器编排、故障处理（大类）</span><br><span class="line"><span class="number">2</span>、镜像管理：</span><br><span class="line">   ⭐⭐① 镜像制作 写dockerfile</span><br><span class="line">   ② harbor使用，自动更新（Dockerfile 把镜像写好，推送harbor，然后可以使用ansible 批量更新多个不同的容器节点）</span><br><span class="line"><span class="number">3</span>、容器日志管理（定期清理容器日志--日志轮转） 主要是配置文件限制+ 日志定期清理</span><br><span class="line">  ##日志文件的数量与单个日志文件大小控制</span><br><span class="line">  &quot;log-driver&quot;: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    &quot;max-size&quot;: <span class="string">&quot;500m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;max-file&quot;</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ## 定期清理容器日志（借助Shell + crontab 定期清理日志）</span><br><span class="line"> ## 采集容器日志（EFK ES+FLUENTED+KIBANA）</span><br><span class="line">⭐⭐<span class="number">4</span>、容器的故障处理</span><br><span class="line">docker ps -<span class="selector-tag">a</span>  --》容器的状态是什么类型的异常 --》docker logs -f <span class="attr">--tail</span> <span class="number">1000</span></span><br><span class="line"><span class="number">5</span>、docker-compose 容器编排（Ruo-Yi 前后端分离的VUE项目）</span><br><span class="line">可以使用docker-compose管理多个容器组合的场景（创建并管理一套小型的系统）</span><br><span class="line"><span class="number">6</span>、容器的基本操作</span><br></pre></td></tr></table></figure>

<p><strong>容器面试题：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、docker 常用命令（增删改查）</span><br><span class="line"><span class="number">2</span>、docker -<span class="selector-tag">i</span> -t -d什么意思 </span><br><span class="line"><span class="number">3</span>、dockerfile 有哪些指令，dockerfile内容怎么写的，写过哪些dockerfile </span><br><span class="line"><span class="number">4</span>、dockerfile中cmd 和entrypoint 有什么区别 ，copy和add有什么区别 </span><br><span class="line"><span class="number">5</span>、容器和虚拟化的区别是什么，为什么要用容器？</span><br><span class="line"><span class="number">6</span>、docker的底层原理是什么 </span><br><span class="line"><span class="number">7</span>、docker的工作流程是什么？</span><br><span class="line"><span class="number">8</span>、docker 怎么发布容器到外面 ？引申：-<span class="selector-tag">p</span> -<span class="selector-tag">P</span>区别</span><br><span class="line"><span class="number">9</span>、docker 网络类型有哪些，有什么特性？</span><br><span class="line"><span class="number">10</span>、docker-compose会写么，有没有用过，在哪用的？</span><br><span class="line"><span class="number">11</span>、docker中 怎么把文件传到运行的容器中</span><br><span class="line"><span class="number">12</span>、dockerfile 怎么写，怎么做优化</span><br></pre></td></tr></table></figure>

<h4 id="5、资源管理器"><a href="#5、资源管理器" class="headerlink" title="5、资源管理器"></a>5、资源管理器</h4><p>**容器集群化管理工具：**Messos 、Docker Swarm 、Kubernetes</p>
<p><strong>kuberntes里面跑什么</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K8S 中可以运行所有微服务业务、应用服务、各类的管理系统，除了数据库、中间件（rabbitmq、kafka 等）以及其他极度吃资源的服务/环境，其他都可以跑在K8S中</span><br></pre></td></tr></table></figure>

<p><strong>Kunernets 运维工作</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、kubernetes 搭建:</span><br><span class="line">① 二进制（每个组件进行手工编译安装，然后申请ca证书，对接起来）</span><br><span class="line">② kubeadm （官方推荐的搭建方式）</span><br><span class="line">③ 工具安装：kubesphere 安装（kubesphere安装K8S --》 K9s） </span><br><span class="line">          rancher 安装 （rancher安装K8S--》K3S）</span><br><span class="line">④ 云平台安装：阿里云的ACK （托管版的K8S安装）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、Kubernetes 管理</span><br><span class="line">① 围绕 Pod 进行管理（配置、发布、控制器、调度器、存储、L7网络、监控、日志）</span><br><span class="line">② 修改、优化YML文件配置</span><br><span class="line">③ 使用web界面管理K8S平台（rancher）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、平时业务更新、发布、回滚，需要用到K8S，主要的流程是 docker（运行jenkins + gitlab/gitee）+ harbor + K8S +管理平台（rancher、云控制台、kubesphere）完成CI/CD的持续集成持续发布的任务</span><br><span class="line">以及集成其他应用来完成其他综合性的工作，包括：</span><br><span class="line">EFK、prometheus、nacos、持久化层、对接大数据流域的数据仓库、数据分析等、配合使用包含gpu处理的worker节点跑模型类的业务。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、故障处理和日志管理</span><br><span class="line">K8S 故障处理流程：</span><br><span class="line">① kubectl get po -n namespace ---&gt; 查看 pod的status 状态（Pod生命周期状态 -》<span class="number">10</span>几个--》清楚异常状态是怎么导致的，怎么处理）</span><br><span class="line">② kubectl describe [资源类型] [资源对象] -n namespace 查看events 事件 --》根据事件反馈的内容模糊定位问题的方向</span><br><span class="line">③ kubectl logs -f --tail <span class="number">1000</span>  查看日志（或者直接搜索kibana 的信息）</span><br><span class="line">④ 根据具体的业务，当前故障的时间节点，从业务场景角度、系统资源角度、报错的Pod中服务类型的角度，以及从报错现象与提示维度来排查错误</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、prometheus 和efk 监控与日志工作</span><br><span class="line">① 整理、优化监控指标项，日志采集输出的内容合理性，调整监控、日志的输出与展示内容</span><br><span class="line">② 优化维护prometheus 的监控资源文档</span><br><span class="line">③ 优化grafana 图标展示与其他日常工作</span><br><span class="line">④ 根据其他不同部门的需求与业务的实际情况，优化prometheus 监控内容</span><br><span class="line">以上工作是持续完成的</span><br></pre></td></tr></table></figure>

<p><strong>K8S 面试题：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">① K8S 核心组件有哪些？每个组件是干嘛的？</span><br><span class="line">② K8S 工作流程是什么？</span><br><span class="line">XXXXX③ K8S 搭建用的是什么方式，你们CNI用的是什么？</span><br><span class="line">④ 你们K8S集群规模大概多大 （1、节点数量-包括master数量和worker数量 2、Pod数量）</span><br><span class="line">⑤ 你们K8S中跑的是什么？</span><br><span class="line">⑥ K8S 云上还是自建（看你们业务）</span><br><span class="line">私有云（） 公有云 混合云 （社区云）</span><br><span class="line">它是一种商业模式</span><br><span class="line">核心：1） 服务器资源归属于哪</span><br><span class="line">     2） 服务方是谁</span><br><span class="line">3个角色： </span><br><span class="line">1） 客户：购买产品的</span><br><span class="line">2） 解决方案提供商：你在的公司（给产品方案的）</span><br><span class="line">3）云厂商：</span><br><span class="line">改一下：私有云、公有云、混合云分别是什么</span><br><span class="line">⑦ K8S 常用命令（简单问）</span><br><span class="line">⑧ 有哪些控制器</span><br><span class="line">⑨ 你们项目中的产品/业务是怎么更新的</span><br><span class="line">答：一套流程（我们拿到开发代码开始，到发布完成整个过程）</span><br><span class="line">10 容器的重启策略、镜像下载策略</span><br><span class="line">11 Pod内有几种容器，分别是做什么的</span><br><span class="line">12 Pod类型有哪些，有什么区别</span><br><span class="line">13、Pod 删除的工作流程是什么</span><br><span class="line">① 参与的组件</span><br><span class="line">② 起始的位置 </span><br><span class="line">③ 过程中相互协作的组件</span><br><span class="line">④ 方向 </span><br><span class="line">⑤ 机制</span><br><span class="line">14、pod 增删改查命令是什么，以Nginx 为例</span><br><span class="line">① 增：创建Ng 、副本集3、暴露80 创建在abc namespace中 控制器的名字为ng-deploy</span><br><span class="line">kubectl create deployment ng-deploy --replicas=3 --image=nginx --port=80 -n abc </span><br><span class="line">② 修改镜像nginx 为1.20 </span><br><span class="line">kubectl set deployment ng-deploy --image=nginx:1.20 -n abc </span><br><span class="line">③ 查询label标签为nginx的所有资源</span><br><span class="line">kubectl get po app=nginx -n abc </span><br><span class="line">④ kubectl delete deployment ng-deploy -n abc </span><br><span class="line">Pod 如何发布的（过程描述）以service 的NodePort 模式为例</span><br><span class="line">16、K8S 更新Pod 方法（滚动、蓝绿、金丝雀/灰度）分别是怎么发布的</span><br><span class="line">关键点：</span><br><span class="line">蓝绿：一半/一半 以更新后正常使用为标准</span><br><span class="line">滚动：定义步长（百分比）以更新成功正常使用为标准</span><br><span class="line">金丝雀：百分比更新，以接入流量后的反馈为标准，持续、谨慎更新</span><br><span class="line"></span><br><span class="line">蓝绿：50%   正常使用标准</span><br><span class="line">滚动：步长 正常使用标准</span><br><span class="line">金丝雀：百分比更新，流量接入，观测反馈，更新</span><br><span class="line">17、K8S Pod资源限制怎么做的，参数是什么？</span><br><span class="line">18、K8S集群的默认驱逐机制中，各个资源的驱逐阈值是多少？</span><br><span class="line">19、Pod 健康检查机制是什么，有哪些（探针）类型，有什么区别</span><br><span class="line">20、Pod 探针的检查方式有哪些</span><br><span class="line">21、钩子的使用作为加分项，在容器创建后，启动前，想插入一端指令或准备一个环境，应该怎么做</span><br><span class="line">22、第一层面试题：直接问调度策略有哪些，怎么做的</span><br><span class="line">23、第二层面试题：给需求，然后让你使用对应的调度策略完成（需求中往往会结合其他的资源对象特性）</span><br><span class="line">24、第三层面试题：实际业务报错场景下，如何排查错误发生的可能性（调度策略相关）</span><br><span class="line">    2个情况：① 面试官给你场景，你来描述排查思路</span><br><span class="line">                   ② 面试官问你，你遇到什么印象深刻的报错情况，如何解决的/你遇到过印象最深刻/严重的故障是什么</span><br><span class="line">25、调度器的默认调度规则/策略是什么？</span><br><span class="line">26、污点和容忍的作用是什么，什么时候会使用污点机制？</span><br><span class="line">PS（调度器相关的组合题）</span><br><span class="line">27、存储类型有哪些，你们用的是什么存储，什么场景使用？</span><br><span class="line">28、Pod的生命周期有哪些（指的是Pod的状态及对应场景）</span><br><span class="line">29、新建污点的命令</span><br><span class="line">30、PV PVC SC 有没有用过，用在哪些场景/业务（极少部分会问怎么做的）？</span><br><span class="line">31、你们的PV PVC用的是什么？ NFS Ceph 云存储</span><br><span class="line">32、控制器有哪些，分别是干嘛的？</span><br><span class="line">32、控制器+调度器的需求场景，例如我有20个节点，每个几点都需要跑一个pod副本，我要怎么做？</span><br><span class="line">33、以32题为基础，增加一个需求，新增的Pod需要和拥有app=a标签的Pod 跑在一起，我要怎么做？</span><br><span class="line">34、K8S 控制组合题，比如daemonset 搭配调度器的需求场景 </span><br><span class="line">35、你们业务/应用，会使用哪些控制器，或者32题介绍后，追问，statefulset和deployment控制器分别用于什么场景/业务</span><br><span class="line">36、你们配置文件是怎么管理的/或者直接问configmap和secret分别用在什么场景</span><br><span class="line">37、你们是怎么暴露服务的？</span><br><span class="line">38、你们用的是哪个ingress（含义：ingress-controller-nginx 控制器，还是云上的ingress）？</span><br><span class="line">39、ingress的工作原理是什么？有可能会问 ingress 组件有哪些</span><br><span class="line">40、ingress怎么做https转发？</span><br><span class="line">申请tls/ca证书，申请域名，将证书与密钥文件创建为secret资源，然后写ingress-api对象的yaml文件时，在spec字段下定义域名参数和tls参数，指向secret证书资源。然后在rules 规则中，定义443访问端口即可 </span><br><span class="line">41、我K8S节点资源充足的，但是为什么我在创建pod的时候，一直创建失败呢，有哪些可能性？</span><br><span class="line">前提：没有调度问题，没有配置问题，没有镜像问题，没有控制器问题、没有网络问题、没有探针问题，没有钩子问题。</span><br><span class="line">我们可能给namespace 配置了limit（这个limits 可能是pod 数量上限，可能是可用资源上限）</span><br><span class="line">42、怎么将http的流量转到https下？</span><br><span class="line">做301重定向</span><br><span class="line">具体怎么做呢？ 在ingress文件（ingress-api对象的文件）的注释信息中，写明：</span><br><span class="line">annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/force-ssl-redirect: &quot;true&quot;</span><br><span class="line"></span><br><span class="line">43、你们平时是怎么管理K8S集群的？</span><br><span class="line">rancher 平台、promtheus 监控辅助 日志管理efk+ grafana监控、日志数据可视化 helm 资源管理</span><br><span class="line">或者云平台管理</span><br><span class="line"></span><br><span class="line">44、你们的K8S安全管理是什么？？？</span><br><span class="line">RBAC：认证、鉴权、准入控制</span><br><span class="line">管理方法如下：</span><br><span class="line">权限申明</span><br><span class="line">role  指定ns</span><br><span class="line">clusterole 所有ns</span><br><span class="line">权限认证：</span><br><span class="line">rolebinding 指定ns认证</span><br><span class="line">clusterrolebinding 指定所有ns</span><br><span class="line">绑定subject 角色</span><br><span class="line">sa    Pod资源对象</span><br><span class="line">user  用户</span><br><span class="line">group 组-组成员</span><br><span class="line"></span><br><span class="line">45、低概率问到helm组件、怎么用的?</span><br><span class="line">helm 包含了几个元素：</span><br><span class="line">① chart 包，这是一个&quot;tgz压缩文件&quot;  helm包的扩展名 </span><br><span class="line">② repostry ： helm包的仓库，存放着各类tgz软件包（需要安装好helm之后进行同步仓库位置）</span><br><span class="line">③ release（实例）： helm根据chart包发布/部署的资源对象</span><br><span class="line"></span><br><span class="line">helm 包的内部文件组成：</span><br><span class="line">以nginx为例， nginx-v1.0.1.tgz的chart 包 ，可以解压为一个nginx-chart工作目录</span><br><span class="line">在nginx-chart工作目录中会包含以下几个核心文件：</span><br><span class="line">① Chart.yaml ： nginx-chart包的基本概览，包括api版本，镜像，chart版本，keyworkd关键词等内容</span><br><span class="line">② template目录：这是创建Nginx-chart的release的相关资源模板，例如deployment.yaml svc.yaml ingress.yaml configmap.yaml等资源的配置模板，且模板中包含的都是基本配置+参数&quot;变量&quot;，参数&quot;变量&quot;的值，来源于nginx工作目录下，values.yaml 申明的值</span><br><span class="line">③ values.yaml：定义具体资源参数的文件，修改的内容，会在创建release时，传递给template目录下的各类资源的</span><br><span class="line">参数变量中使用。</span><br><span class="line"></span><br><span class="line">helm install nginx ./nginx -n namespace 创建release</span><br><span class="line"></span><br><span class="line">helm 的使用场景：</span><br><span class="line">在devops工作流程中使用，同时在应用发布更新、或比较复杂的应用资源管理，会使用helm</span><br><span class="line"></span><br><span class="line">46、你们采集K8S日志是怎么做的？？</span><br><span class="line"></span><br><span class="line">47、K8S内的Pod 怎么抓包？？</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="反复要讲清楚的主题"><a href="#反复要讲清楚的主题" class="headerlink" title="反复要讲清楚的主题"></a>反复要讲清楚的主题</h1><h2 id="Linux和Shell类"><a href="#Linux和Shell类" class="headerlink" title="Linux和Shell类"></a>Linux和Shell类</h2><p>Linux系统的启动过程?</p>
<p><img src="/./imgs/image-20251222132842432.png" alt="image-20251222132842432"></p>
<p>工作中你常使用的Linux命分有哪些?</p>
<p>查看CPU,内存,磁盘,还有进程的Linux命分都有哪些?</p>
<p>LVM扩展根分区的过程?</p>
<p>如何查找7天前修改的文件?如何查找文件大小大于10M小于100M的文件?如何查找属于某个用户的文件,并把这些文件复制到&#x2F;tmp路径下?</p>
<p>工作中都配置过哪些Linux系统的优化?分别在什么场景下配置的?</p>
<p>在实际的工作生产环境中，Linux 系统的优化通常不是“为了优化而优化”，而是<strong>基于具体的业务痛点（如高并发、高 IO、低延迟）进行的针对性调整</strong>。</p>
<p>以下我整理了几个核心场景及其对应的优化配置：</p>
<hr>
<h3 id="1-网络高并发场景-Web-服务器-Nginx"><a href="#1-网络高并发场景-Web-服务器-Nginx" class="headerlink" title="1. 网络高并发场景 (Web 服务器 &#x2F; Nginx)"></a>1. 网络高并发场景 (Web 服务器 &#x2F; Nginx)</h3><p><strong>场景：</strong> 面对海量短连接（如大促、抢购）时，系统常出现 <code>TIME_WAIT</code> 过多，导致新连接无法建立。</p>
<ul>
<li><strong>内核参数调整 (<code>/etc/sysctl.conf</code>)：</strong><ul>
<li><strong>端口范围：</strong> 增大 <code>net.ipv4.ip_local_port_range</code>，增加可用临时端口。</li>
<li><strong>连接回收：</strong> 开启 <code>net.ipv4.tcp_tw_reuse = 1</code>，允许重用 <code>TIME_WAIT</code> 状态的套接字。</li>
<li><strong>队列长度：</strong> 增大 <code>net.core.somaxconn</code>，提高系统能处理的并发连接上限。</li>
</ul>
</li>
<li><strong>文件句柄：</strong><ul>
<li>修改 <code>limits.conf</code> 中的 <code>nofile</code>（如 65535），避免出现 “Too many open files” 错误。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-高负载数据库场景-MySQL-PostgreSQL-Redis"><a href="#2-高负载数据库场景-MySQL-PostgreSQL-Redis" class="headerlink" title="2. 高负载数据库场景 (MySQL &#x2F; PostgreSQL &#x2F; Redis)"></a>2. 高负载数据库场景 (MySQL &#x2F; PostgreSQL &#x2F; Redis)</h3><p><strong>场景：</strong> 数据库服务器通常对 IO 延迟和内存管理非常敏感。</p>
<ul>
<li><strong>内存优化：</strong><ul>
<li><strong>关闭 Swap：</strong> 如果物理内存充足，建议调低 <code>vm.swappiness = 1</code>（或直接关闭），防止内存数据交换到磁盘导致延迟大幅波动。</li>
<li><strong>大页内存 (HugePages)：</strong> 对于 Redis 或大型数据库，开启大页内存可以减少页表项，提升内存寻址效率。</li>
</ul>
</li>
<li><strong>磁盘调度策略：</strong><ul>
<li>对于 SSD 硬盘，将调度算法改为 <code>noop</code> 或 <code>deadline</code>（传统 HDD 常用 <code>cfq</code>），减少 CPU 在 IO 调度上的开销。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Java-应用与中间件场景-JVM-Kafka"><a href="#3-Java-应用与中间件场景-JVM-Kafka" class="headerlink" title="3. Java 应用与中间件场景 (JVM &#x2F; Kafka)"></a>3. Java 应用与中间件场景 (JVM &#x2F; Kafka)</h3><p><strong>场景：</strong> Java 应用容易受到“内存抖动”影响，而 Kafka 等中间件则极度依赖文件系统缓存。</p>
<ul>
<li><strong>虚拟内存优化：</strong><ul>
<li>调整 <code>vm.max_map_count</code>：这是 Elasticsearch 和部分 Java 应用常要求的，决定了进程能拥有的 VMA（虚拟内存区域）数量。</li>
</ul>
</li>
<li><strong>脏数据回写：</strong><ul>
<li>调整 <code>vm.dirty_ratio</code> 和 <code>vm.dirty_background_ratio</code>，控制数据在内存中停留的时间，防止大量数据一次性写入磁盘导致的系统卡顿（Flush 导致的 IO 阻塞）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-容器化场景-Docker-Kubernetes"><a href="#4-容器化场景-Docker-Kubernetes" class="headerlink" title="4. 容器化场景 (Docker &#x2F; Kubernetes)"></a>4. 容器化场景 (Docker &#x2F; Kubernetes)</h3><p><strong>场景：</strong> 容器环境下，单台宿主机可能运行成百上千个容器，资源隔离和网络转发是重点。</p>
<ul>
<li><strong>连接跟踪 (Conntrack)：</strong><ul>
<li>增大 <code>net.netfilter.nf_conntrack_max</code>。如果这个表满了，容器间网络通信会无故丢包，表现为偶发性的超时。</li>
</ul>
</li>
<li><strong>路由转发：</strong><ul>
<li>必须开启 <code>net.ipv4.ip_forward = 1</code>，确保 Pod&#x2F;容器的网络流量能正确通过宿主机转发。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-通用基础优化"><a href="#5-通用基础优化" class="headerlink" title="5. 通用基础优化"></a>5. 通用基础优化</h3><p>无论什么场景，上线前通常都会做的“基本功”：</p>
<table>
<thead>
<tr>
<th><strong>优化项</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>磁盘挂载参数</strong></td>
<td>使用 <code>noatime</code> 挂载，不记录文件最后访问时间，减少写开销。</td>
</tr>
<tr>
<td><strong>CPU 频率调节</strong></td>
<td>将 CPU 模式设为 <code>performance</code>，防止 CPU 频繁进入节能模式导致性能波动。</td>
</tr>
<tr>
<td><strong>系统日志限制</strong></td>
<td>调整 <code>journald</code> 大小，防止日志爆满撑爆根分区。</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h3><p>优化 Linux 系统的核心原则是：<strong>不要盲目照搬“万能模版”</strong>。</p>
<ol>
<li><strong>先监控：</strong> 使用 <code>top</code>, <code>iostat</code>, <code>netstat</code>, <code>htop</code> 找到瓶颈。</li>
<li><strong>单变量测试：</strong> 每次只修改一个参数，观察性能变化。</li>
<li><strong>持久化：</strong> 确认有效后，务必写入 <code>/etc/sysctl.conf</code> 或 <code>/etc/security/limits.conf</code>，否则重启失效。</li>
</ol>
<p>shell中$?代表什么意思? 脚本中$@和 $1..$N 代表啥意思?shell中如何获取字符串的长度?如何截取一段字符串?</p>
<p><img src="/./imgs/image-20251222143709848.png" alt="image-20251222143709848"></p>
<p>shell中都有用过哪些循环?分别说一下每种循环的语法结构是什么?</p>
<p>shell中什么是函数,如何简单定义一个函数?shell中脚本的参数如何传递到函数里面去?</p>
<p>shell中如何并发执行代码块?</p>
<h2 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h2><p>TCP和UDP协议区别?</p>
<p>OSI七层网络模型?</p>
<p>TCP的三次握手和四次挥手过程是什么?</p>
<p>在浏览器中输入一个网站,按下回车键背后发生哪些事情?</p>
<h2 id="虚拟化技术类"><a href="#虚拟化技术类" class="headerlink" title="虚拟化技术类"></a>虚拟化技术类</h2><p>怎么理解容器和虚拟化?</p>
<p>Docker run的时候有哪些常见参数和选项?具体作用是什么?</p>
<p>DockerFile文件中都有哪些关键字?COPY 和 ADD 区别是什么?CMD 和ENTRYPOINT区别是什么?</p>
<h2 id="中间件类"><a href="#中间件类" class="headerlink" title="中间件类"></a>中间件类</h2><p>解释反向代理和正向代理?</p>
<p>Mysql数据库如何优化?</p>
<p>Nginx如何优化?</p>
<p>Mysql内连接,左连接,右连接是什么意思?一条完整内连接查询语言怎么写?</p>
<p>Mysql的主从复制原理是什么?</p>
<p>二日志三线程</p>
<p><strong>MySQL主从复制怎么配置？</strong></p>
<p><strong>master</strong>中开启log_bin二进制日志</p>
<p>log_slave-updates&#x3D;ture开启从服务器日志铜鼓吧</p>
<p>设置server_id</p>
<p>在mysql中进行grant进程用户权限授权</p>
<p><strong>slave</strong>开启二进制日志log-bin</p>
<p>设置server_id</p>
<p>开启中继日志relay-log&#x3D;relay-log-bin</p>
<p>定义relay-log的位置和名称relay-log-index&#x3D;slave-relay-bin.index</p>
<p>在mysql中设置主服务器配置，确认指向，同步位置</p>
<p>change master to master_host&#x3D;’192.168.118.91’,master_user&#x3D;’slave’,master_password&#x3D;’123456’,master_log_file&#x3D;’master-bin.000001’,master_log_pos&#x3D;450;</p>
<p>start slave开启服务</p>
<p>查看线程是否都正常启动</p>
<p><strong>MySQL读写分离怎么配置？</strong></p>
<p>通过中间件Amoeba代理</p>
<p>修改其中的xml配置文件设置读写分离amoeba.xml</p>
<p>配置数据库配置文件-dbServers.xml</p>
<p><strong>为什么会使用到ES?倒排索引（分词）是什么？ mysql精确查找，es模糊匹配</strong></p>
<p>ES分布式搜索引擎</p>
<p>答：mysql主要做的是精确查找，需要一个更加合适模糊查找的数据库</p>
<p><strong>倒排索引</strong>记录的是哪个词出现在了哪条记录里</p>
<p><strong>ES的倒排索引（Inverted Index）是怎么做的?</strong></p>
<p>答：对文本进行切分，分词，记录词项和文本ID的关系，查询直接查询词项，定位到对应的文本ID。</p>
<p>将文档<strong>分词</strong> → 建立词-&gt;文档ID的<strong>映射关系</strong>。查询时直接查询词映射，快速定位文档</p>
<p><strong>ES的分片有什么作用?</strong></p>
<p>答：将数据分散到多个节点，提高查询的并发性和速度。</p>
<p><strong>ES的副本有什么作用?</strong></p>
<p>答：作为备份，提高ES的可用性和容错性，也可以辅助读取，提高读取速度。</p>
<p><strong>ES中索引,文档你是怎么理解的?</strong></p>
<p>答：索引是文档的集合，类似数据库中的<strong>表</strong>；文档是最小的数据单位，是JSON格式，类似数据库中的一<strong>行</strong>记录。</p>
<p><strong>补充：</strong></p>
<p>Term Index加速搜索：（信息存放在磁盘中，查询比较慢，所以通过term index加速搜索）</p>
<p>把词项再进行细分，生成前缀信息树（存放到内存中）</p>
<p>Storeed Fields存放文档原始信息</p>
<p>Doc Values排序聚合</p>
<p>segment具备完整搜索功能的最小单元（包含了Inverted index,term index,stored fields,doc values）</p>
<p>segment一旦生成，无法修改，有新的文件生成需要重新生成segment</p>
<p>Luence是什么？</p>
<p>开源基础搜索库luence：多个segment共同构成一个单机文本检索库</p>
<p>⭐<strong>Prometheus的架构是什么?数据是怎么流的?</strong></p>
<p><img src="/./imgs/image-20251222171127569.png" alt="image-20251222171127569"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">│ 1. 通过 Service Discovery 发现监控目标                         │</span><br><span class="line">│ 2. Prometheus Server 通过 pull 方式抓取指标数据                │</span><br><span class="line">│ 3. 或通过 Pushgateway 接收 push 方式推送的数据                  │</span><br><span class="line">│ 4. 数据通过 TSDB 存储到本地磁盘（默认 15 天）                    │</span><br><span class="line">│ 5. 根据告警规则生成告警通知发送到 Alertmanager                   │</span><br><span class="line">│ 6. Alertmanager 进行分组、去重、路由和发送告警                   │</span><br><span class="line">│ 7. 用户通过 Web UI 使用 PromQL 查询监控数据                     │</span><br><span class="line">│ 8. Grafana 可接入 Prometheus 数据源进行图形化展示  </span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251223132331788.png" alt="image-20251223132331788"></p>
<p>直接采集是服务中有自建指标，直接暴露对应端口即可采集</p>
<p>间接采集需要依赖exporter（比如linux—node-exporter,mysql-exporter）——类似边车&#x2F;agent，exporter抓取数据暴露metrics端口暴露供promethes抓取</p>
<p>本质上就是将抓取的数据转换为文本格式，然后提供http接口</p>
<p><img src="/./imgs/image-20251223133042306.png" alt="image-20251223133042306"></p>
<p><strong>Nginx负载均衡算法有哪些?</strong></p>
<p>RR,WRR,IP_HASH,Least Connections </p>
<p><strong>Nginx的状态码有哪些,分别代表啥意思?</strong></p>
<p>2xx成功 3xx重定向 4xx客户端问题 5xx服务端问题</p>
<p>⭐<strong>Redis持久化方式有哪些,分别有什么特点?</strong></p>
<p>RDB（Redis Database <strong>Snapshot</strong>）类似快照</p>
<p>AOF（Append Only File）类似二进制日志</p>
<p>1、从向主发送sync请求<br>2、主开启<strong>bgsave</strong>进行RDB 持久化（保存文件）<br>3、保存后推送给从服务器，从服务器开始”恢复”数据到内存中<br>4、<strong>同时</strong>主将内存中新增的数据通过AOF的方式给到从服务器</p>
<p>⭐<strong>Mysql有哪些高可用解决方案?</strong></p>
<p>MHA：在主库发生故障时，自动将从库提升为主库，保证数据库服务的连续性。</p>
<p>MHA Manager 会定时探测集群中的 master 节点。当 master 出现故障时，它可以自动将最新数据的 slave 提升为新的 master， 然后将所有其他的 slave 重新指向新的 master。</p>
<p><img src="/./imgs/image-20251223110642978.png" alt="image-20251223110642978"></p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1. <strong>基础配置</strong></td>
<td>关闭防火墙，安装MySQL 5.7</td>
</tr>
<tr>
<td>2. <strong>一主两从</strong></td>
<td>配置主从复制（Master-Slave1-Slave2）（配置my.cnf⭐，grant给予slave，mha权限）</td>
</tr>
<tr>
<td>3. <strong>安装MHA</strong></td>
<td>安装node和manager组件</td>
</tr>
<tr>
<td>4. <strong>SSH认证</strong></td>
<td>配置各节点间无密码认证</td>
</tr>
<tr>
<td>5. <strong>MHA配置</strong></td>
<td>复制管理脚本，配置failover脚本和app1.cnf，在配置文件中指定</td>
</tr>
<tr>
<td>6. <strong>启动监控</strong></td>
<td>启动MHA manager进程</td>
</tr>
<tr>
<td>7. <strong>故障测试</strong></td>
<td>模拟故障验证自动切换</td>
</tr>
</tbody></table>
<p>双MM</p>
<p>MySQL 双主架构是一种<strong>互为主从</strong>的复制配置，两台服务器都既是主(Master)也是从(Slave)。</p>
<p><strong>核心原理：</strong></p>
<ul>
<li>服务器A和B建立双向复制关系，每台服务器都有binlog(二进制日志)</li>
<li>当一台服务器的数据发生变化时，该变化会被复制到另一台服务器</li>
<li>通过binlog和relay log实现数据同步</li>
<li>依靠server_id区分不同的服务器，防止复制循环</li>
</ul>
<p>⭐<strong>Redis的高可用解决方案有哪些?</strong></p>
<p>哨兵 集群</p>
<p>MYSQL 的增删改查关键字分别是什么?详细说一下表的增删改查?</p>
<p><strong>Redis啃兵模式和集群模式有什么区别?</strong></p>
<p>  <strong>哨兵模式：<strong>至少6台节点，原理：<strong>每个哨兵单独监控</strong>redis集群、通过</strong>hello频道</strong>同步信息，故障时，<strong>单个哨兵</strong>判断master故障了，会定义为<strong>主观下线</strong>、<strong>多个哨兵</strong>判断master故障则定义为<strong>客观下线</strong>，客观下线后，通过<strong>RAFT算法</strong>进行<strong>选举投票</strong>，选择出新master顶上来，然后其他redis集群同步新master位置<br>  <strong>cluster集群模式：<strong>至少6个节点，原理:需要</strong>奇数</strong>数量的<strong>master</strong>，cluster集群模式让master<strong>相互进行健康检查</strong>、判断彼此存活性，同时<strong>每个master都会有至少1台自己的从服务器</strong>，并且实现”<strong>主从复制</strong>“,当一个master 挂掉了，其他master 也会进行<strong>选举</strong>，选择出最适合成为新master的slave服务器，同时挂掉的Master也会<strong>指定</strong>一个自己的slave 服务器来继承<strong>slots(哈希槽)</strong>。保证集群的完整性。<br>  PS： slots 哈希槽有<strong>16384</strong>个（0~16383），<strong>哈希槽会平均分配</strong>给cluster的每个master，数据通常，是以<strong>分布式</strong>的方式，存储在master的<strong>哈希槽</strong>中的。</p>
<p><strong>⭐EFK&#x2F;ELK的架构细节,详细说一下?</strong></p>
<p><img src="/./imgs/image-20251222172921613.png" alt="image-20251222172921613"></p>
<p><img src="/./imgs/image-20251222173004226.png" alt="image-20251222173004226"></p>
<p><strong>ES的常见使用场景有哪些?</strong></p>
<p>搜索场景：全文检索，模糊匹配，多字段搜索等</p>
<p>日志实时分析：ELK等</p>
<p>时序数据分析：监控数据，物联网传感器数据</p>
<p>关系型数据库查询瓶颈：mysql数据量大多表关联导致查询慢，用ES加速</p>
<p>数据分析与聚合：多维度统计，实时用户画像，订单分析等</p>
<h2 id="kubenetes类"><a href="#kubenetes类" class="headerlink" title="kubenetes类"></a>kubenetes类</h2><p><strong>K8S有控制面和工作面都有哪些组件,每个组件的作用是什么?</strong></p>
<p>Master：</p>
<ul>
<li>apiserver(API接口，集群管理调度任务分配，etcd数据库交互)</li>
<li>scheduler(调度器，选择最合适创建Pod的节点)</li>
<li>controller-manager(控制器，管理各类控制器，管理pod生命周期)</li>
<li>etcd(存储，集群核心库)</li>
<li>kubectl(管理集群的命令)</li>
<li>auth(认证鉴权)</li>
</ul>
<p>Node：</p>
<ul>
<li>kubelet(节点代理，管理监控节点中k8s资源与任务的核心组件，负责管理和维护节点上的 Pod ，将节点信息返回给api-server给etcd保存)</li>
<li>kube-proxy(网络代理)</li>
</ul>
<p>kube-proxy 是 Kubernetes <strong>网络代理</strong>，运行在每个 Node 节点上。它的核心作用是<strong>实现 Service 的抽象</strong>，负责维护节点上的网络规则，从而实现将发送到 Service VIP（虚拟 IP）的请求转发到后端正确的 Pod 上。</p>
<ul>
<li>pod(资源调度的最小单位，分装了多个容器，业务运行在容器中)</li>
</ul>
<p><strong>kubectl run mypod -image nginx:latest -port 80 按下后发生哪些事情?</strong></p>
<p>用户通过Kubectl即这行代码，首先通过auth进行认证鉴权，通过后请求发送到Apiserver，Apiserver接收请求后发送给ETCD数据库，ETCD接收后存储需求信息，生成list清单给Apiserver，Scheduler调度器监听到List清单中是事件，触发默认调度规则，选出最合适的节点并提交到apiserver的list清单中，节点上的kubelet监听到List清单中的调度结果，会触发CRI容器运行时的动作，进行nginx:latest的镜像拉取，创建容器，启动容器，进行网络配置，Kubectl通过Apiserver将Pod的状态信息更新到ETCD中。</p>
<p><strong>数据流向&#x2F;工作流程</strong></p>
<p>① kubectl 创建一个Pod 资源（指令&#x2F;yml文件）<br>② 通过auth 认证鉴权后，到达api-server<br>③ api-server将信息记录在etcd中，etcd 会创建一个ADD的事件，并返回给api-server一个<br>list清单（清单中，会申明需要哪些资源）<br>④ Scheduler 监听到Api-server上的ADD事件后，会触发default-scheduler 规则，选择出<br>最适合创建Pod的节点（如worker02），并提交到api-server的list清单中<br>⑤ worker02 的kubelet组件监听到Api-server上的List清单的调度结果后，会触发连接容器<br>运行时的动作，从而pull image 、create container、start container<br>（主要管理的是容器，比如pause 容器、init容器、主应用容器）<br>⑥ controller-manager 控制器管理中心，也会监听到api-server上的List 清单add事件<br>此时，controller-manager会创建deployment–》创建RS—》RS创建Pod 管理kubelet<br>创建的容器<br>⑦ 后续pod的状态，容器的探针等均由kubelet来监控、管理与汇报给api-server<br>⑧ api-server会持续记录在etcd中</p>
<p><img src="/./imgs/image-20251222173510121.png" alt="image-20251222173510121"></p>
<p>⭐<strong>Pod生命周期有哪些？</strong></p>
<p><strong>1. Pending（待处理）</strong> Pod 已被创建并存储在 etcd 中，但还未被调度到任何节点上。这个阶段可能是因为集群资源不足、节点选择器不匹配或其他调度限制。</p>
<p><strong>2. ContainerCreating（容器创建中）</strong> Pod 已被调度到某个节点，kubelet 正在为 Pod 中的容器拉取镜像并启动容器。</p>
<p><strong>3. Running（运行中）</strong> Pod 中至少有一个容器正在运行。如果 Pod 中有多个容器，这个阶段表示至少一个已经启动。在这个阶段，容器可能会出现失败或重启的情况。</p>
<p><strong>4. Succeeded（成功）</strong> Pod 中的所有容器都已成功退出，且不会重启。通常用于 Job 和 CronJob 这类一次性任务。</p>
<p><strong>5. Failed（失败）</strong> Pod 中至少有一个容器异常终止（退出码非零）。此时 Pod 不会自动重启（除非配置了重启策略）。</p>
<p><strong>6. Unknown（未知）</strong> 由于某种原因，无法获取 Pod 的状态。通常表示 kubelet 与 API 服务器之间的通信出现问题。</p>
<p><strong>7. CrashLoopBackOff（崩溃回退）</strong> 容器不断崩溃并尝试重启，但重启失败，进入指数级的等待后重试。这通常表示应用程序存在问题。</p>
<p><strong>8.ImagePullBackOff（镜像拉取回退）</strong> kubelet 尝试拉取容器镜像失败，然后进入指数级退避重试。常见原因包括镜像不存在、镜像仓库网络不可达、镜像仓库认证失败或镜像tag错误。这个状态会持续重试，直到镜像拉取成功或 Pod 被删除。</p>
<p><strong>9.Terminating（终止中）</strong> Pod 正在被删除。当收到删除请求后，Pod 会进入这个状态。在这个阶段，kubelet 会给容器一个优雅关闭的机会（由 terminationGracePeriodSeconds 指定，默认30秒），超时后会强制杀死容器。</p>
<p><strong>10.Error（错误）</strong> Pod 处于错误状态，通常表示发生了某种异常。比如 API 对象配置错误、资源不足导致 Pod 无法调度、或者节点状态异常等情况。</p>
<p><strong>其他补充的常见状态：</strong></p>
<p><strong>Evicted（驱逐）</strong> 当节点资源不足时（如内存、磁盘），kubelet 会驱逐 Pod 以释放资源。被驱逐的 Pod 会显示这个状态。</p>
<p><strong>init 0&#x2F;2（初始化）</strong> 初始化容器 –》pause创建之后，主容器之前；表示未初始化完成，正在进行初始化环境</p>
<p><strong>OOMKILL（内存溢出）</strong> OOM内存溢出</p>
<p><strong>pod的生命周期都经历哪些?</strong></p>
<p>答：Pending → ContainerCreating → Running → Succeeded&#x2F;Failed&#x2F;Unknown。中间经历initContainer、postStart、preStop等hook。</p>
<p><strong>pod启动失败都有哪些原因?</strong></p>
<p>答：镜像不存在&#x2F;拉取失败、资源不足、存储卷挂载失败、权限问题、健康检查失败、配置错误。参考上面的<strong>生命周期</strong></p>
<p><strong>pod网络,svc网络,节点网络网络是怎么流向的?</strong></p>
<p>在 Kubernetes 中，网络通信是一个分层的结构。要理清流量流向，我们需要理解一个核心概念：<strong>所有的 Pod 都在一个扁平的、跨节点的二层&#x2F;三层网络中，可以直接通过 IP 互访。</strong></p>
<p>我们可以按照**“由近及远”**的四个场景来拆解流量流向：</p>
<hr>
<h3 id="1-同一个-Pod-内的容器通信（Loopback）"><a href="#1-同一个-Pod-内的容器通信（Loopback）" class="headerlink" title="1. 同一个 Pod 内的容器通信（Loopback）"></a>1. 同一个 Pod 内的容器通信（Loopback）</h3><p><strong>场景：</strong> Pod A 里的容器 1 想访问容器 2。</p>
<ul>
<li><strong>流向：</strong> 流量不经过网卡，直接通过本地回环地址 <code>localhost</code> (127.0.0.1) 通信。</li>
<li><strong>原理：</strong> 同一个 Pod 内的所有容器共享同一个 <strong>Network Namespace</strong>。</li>
</ul>
<hr>
<h3 id="2-同一节点上的-Pod-间通信（Bridge）"><a href="#2-同一节点上的-Pod-间通信（Bridge）" class="headerlink" title="2. 同一节点上的 Pod 间通信（Bridge）"></a>2. 同一节点上的 Pod 间通信（Bridge）</h3><p><strong>场景：</strong> 节点 1 上的 Pod A (10.1.1.1) 访问 Pod B (10.1.1.2)。</p>
<ul>
<li><strong>流向：</strong> Pod A → <code>veth</code> 对 → <strong>虚拟网桥 (如 cni0 或 docker0)</strong> → <code>veth</code> 对→ Pod B。</li>
<li><strong>原理：</strong> 虚拟网桥充当了交换机的角色，根据 MAC 地址将包转发到同一个网段的目标 Pod。</li>
</ul>
<hr>
<h3 id="3-跨节点的-Pod-间通信（Overlay-Routing）"><a href="#3-跨节点的-Pod-间通信（Overlay-Routing）" class="headerlink" title="3. 跨节点的 Pod 间通信（Overlay &#x2F; Routing）"></a>3. 跨节点的 Pod 间通信（Overlay &#x2F; Routing）</h3><p>场景： 节点 1 上的 Pod A (10.1.1.1) 访问 节点 2 上的 Pod C (10.1.2.1)。</p>
<p>这是最复杂的逻辑，取决于你的 CNI 插件（如 Flannel, Calico）：</p>
<ul>
<li>封装模式 (Overlay, 如 Flannel VXLAN)： 1. 原始包（Pod A IP → Pod C IP）被发往网桥。<ol start="2">
<li>节点 1 的网络插件发现目标 IP 在节点 2，于是将原始包封装在一个 UDP&#x2F;VXLAN 包里。</li>
<li>外层包的地址是：源节点 IP → 目标节点 IP。</li>
<li>流量通过物理节点网络传输。</li>
<li>节点 2 收到包后拆封，露出原始包，转发给 Pod C。</li>
</ol>
</li>
<li><strong>路由模式 (BGP, 如 Calico)：</strong> 节点网络直接通过路由表知道 10.1.2.0&#x2F;24 网段在节点 2 上，直接通过物理路由转发，不需要额外封装。</li>
</ul>
<hr>
<h3 id="4-Pod-访问-Service-Svc-网络"><a href="#4-Pod-访问-Service-Svc-网络" class="headerlink" title="4. Pod 访问 Service (Svc 网络)"></a>4. Pod 访问 Service (Svc 网络)</h3><p><strong>场景：</strong> Pod A 访问 Service IP (10.96.0.1)。Service 是虚拟 IP，并不存在于任何网卡上。</p>
<ul>
<li><strong>流向：</strong> Pod A 发出包 → 经过宿主机的 <strong>内核网络协议栈</strong>。</li>
<li>核心动作（DNAT）： 1. 内核里的 iptables 或 IPVS 规则（由 kube-proxy 配置）会拦截这个目的地址为 Service IP 的包。<ol start="2">
<li>规则会进行 目的地址转换 (DNAT)，将 Service IP 替换为后端某个随机 Pod 的 真实 IP。</li>
<li>转换后，流程退化为上述的“场景 2”或“场景 3”。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-总结：三类网络的职责"><a href="#5-总结：三类网络的职责" class="headerlink" title="5. 总结：三类网络的职责"></a>5. 总结：三类网络的职责</h3><table>
<thead>
<tr>
<th><strong>网络类型</strong></th>
<th><strong>范围</strong></th>
<th><strong>实现者</strong></th>
<th><strong>职责</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>节点网络</strong></td>
<td>宿主机物理&#x2F;虚拟网卡</td>
<td>云厂商&#x2F;网络管理员</td>
<td>承载节点间的物理通信，是所有网络的地基。</td>
</tr>
<tr>
<td><strong>Pod 网络</strong></td>
<td>容器 Namespace</td>
<td>CNI 插件 (Calico&#x2F;Flannel)</td>
<td>负责 Pod 之间的连通性（扁平化网络）。</td>
</tr>
<tr>
<td><strong>Service 网络</strong></td>
<td>集群全局虚拟 IP</td>
<td>kube-proxy</td>
<td>负责负载均衡，将虚拟 IP 映射到具体的 Pod IP。</td>
</tr>
</tbody></table>
<p><strong>⭐Calico网络和Flannel网络区别是什么?</strong></p>
<p>核心区别：**二层封装（Overlay）<strong>与</strong>三层路由（Routing）**的取向</p>
<p><strong>Flannel (侧重简单)：<strong>主要了解</strong>VXLAN</strong>模式</p>
<ul>
<li><strong>默认模式 (VXLAN)：</strong> 属于 <strong>Overlay 网络</strong>。它把 Pod 的原始数据包封装在 UDP 包里，通过宿主机的物理网络进行“隧道(TUN)”传输。</li>
<li><strong>UDP 模式：</strong> 性能较差（多次用户态&#x2F;内核态切换），现在基本不用。</li>
<li><strong>Host-Gateway 模式：</strong> 性能好，但要求所有节点在同一个子网。</li>
</ul>
<p><strong>Calico (侧重性能与功能)：<strong>主要了解</strong>BGP</strong>模式</p>
<ul>
<li><strong>BGP 模式：</strong> 属于 <strong>三层路由网络</strong>。它不进行数据包封装，而是把每个 Node 都当作一台路由器。节点之间通过 <strong>BGP 协议</strong> 交换路由信息。Pod 流量像普通网络包一样在物理网线上裸奔。</li>
<li><strong>IPIP 模式：</strong> 类似于 VXLAN 的封装模式，用于跨网段的复杂环境。</li>
</ul>
<p>在 Kubernetes 网络方案中，<strong>Flannel</strong> 和 <strong>Calico</strong> 是最常用的两个 CNI 插件。如果把 Pod 通信比作快递运输，Flannel 侧重于“如何简单地把路修通”，而 Calico 则侧重于“如何高效地修路并管理交通规则”。</p>
<p>以下是它们的核心区别：</p>
<hr>
<h3 id="1-核心原理与模式"><a href="#1-核心原理与模式" class="headerlink" title="1. 核心原理与模式"></a>1. 核心原理与模式</h3><p>它们最大的区别在于**二层封装（Overlay）<strong>与</strong>三层路由（Routing）**的取向。</p>
<ul>
<li><strong>Flannel (侧重简单)：</strong><ul>
<li><strong>默认模式 (VXLAN)：</strong> 属于 <strong>Overlay 网络</strong>。它把 Pod 的原始数据包封装在 UDP 包里，通过宿主机的物理网络进行“隧道”传输。</li>
<li><strong>UDP 模式：</strong> 性能较差（多次用户态&#x2F;内核态切换），现在基本不用。</li>
<li><strong>Host-Gateway 模式：</strong> 性能好，但要求所有节点在同一个子网。</li>
</ul>
</li>
<li><strong>Calico (侧重性能与功能)：</strong><ul>
<li><strong>BGP 模式：</strong> 属于 <strong>三层路由网络</strong>。它不进行数据包封装，而是把每个 Node 都当作一台路由器。节点之间通过 <strong>BGP 协议</strong> 交换路由信息。Pod 流量像普通网络包一样在物理网线上裸奔。</li>
<li><strong>IPIP 模式：</strong> 类似于 VXLAN 的封装模式，用于跨网段的复杂环境。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-详细对比"><a href="#2-详细对比" class="headerlink" title="2. 详细对比"></a>2. 详细对比</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Flannel</strong></th>
<th><strong>Calico</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>网络模型</strong></td>
<td>二层 Overlay (默认)</td>
<td>三层 纯路由 (默认)</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较好 (封装有一定解包损耗)</td>
<td><strong>极高</strong> (原生性能，无封装损耗)</td>
</tr>
<tr>
<td><strong>网络策略 (NetworkPolicy)</strong></td>
<td><strong>不支持</strong></td>
<td><strong>完美支持</strong> (支持精细的访问控制)</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>非常简单，几乎零配置</td>
<td>较高，需要了解 BGP 或 IPIP 配置</td>
</tr>
<tr>
<td><strong>数据存储</strong></td>
<td>依赖 ETCD 或直接读 K8s API</td>
<td>依赖 ETCD 或 K8s API</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>中小型集群、新手、简单环境</td>
<td>大型集群、高性能需求、对安全性要求高</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-网络策略-NetworkPolicy-的差异"><a href="#3-网络策略-NetworkPolicy-的差异" class="headerlink" title="3. 网络策略 (NetworkPolicy) 的差异"></a>3. 网络策略 (NetworkPolicy) 的差异</h3><p>这是生产环境选型的重要考量点：</p>
<ul>
<li><strong>Flannel：</strong> 它的目标纯粹，只负责让 Pod 互通。如果你需要限制“Pod A 不能访问 Pod B”，Flannel 本身做不到，通常需要额外配合 <strong>Canal</strong>（Flannel 的网络 + Calico 的策略）。</li>
<li><strong>Calico：</strong> 自带强大的网络策略引擎。你可以基于标签（Label）、命名空间（Namespace）、端口甚至 IP 段来定义极其复杂的访问控制规则（ACL）。</li>
</ul>
<hr>
<h3 id="4-流量路径的区别"><a href="#4-流量路径的区别" class="headerlink" title="4. 流量路径的区别"></a>4. 流量路径的区别</h3><ul>
<li><p>Flannel (VXLAN) 的路径：</p>
<p>Pod → veth → cni0 网桥 → flannel.1 (隧道接口进行封装) → 宿主机物理网卡 → 远端节点。</p>
</li>
<li><p>Calico (BGP) 的路径：</p>
<p>Pod → veth → 宿主机路由表 (直接转发)→ 宿主机物理网卡 → 远端节点。</p>
<p>(由于没有经过网桥和封装，延迟更低，吞吐量更大)</p>
</li>
</ul>
<hr>
<h3 id="5-如何选型？"><a href="#5-如何选型？" class="headerlink" title="5. 如何选型？"></a>5. 如何选型？</h3><ul>
<li><strong>选 Flannel 的场景：</strong><ul>
<li>集群规模较小（几十个节点以下）。</li>
<li>网络环境非常简单（都在同一个交换机下）。</li>
<li>不需要复杂的安全访问控制。</li>
<li>希望“上手即用”，不想折腾网络排查。</li>
</ul>
</li>
<li><strong>选 Calico 的场景：</strong><ul>
<li><strong>生产环境首选</strong>。</li>
<li>对网络性能有极致要求（高并发、低延迟）。</li>
<li>需要多租户隔离、安全策略控制。</li>
<li>集群规模较大，或者存在跨网段通信的需求。</li>
</ul>
</li>
</ul>
<p>Flannel</p>
<p>在宿主机的网络之上创建另一个扁平网络——覆盖网络，所有的容器和POD都会在这个覆盖网络上分配一个IP地址，通过直接调用各自的IP地址进行通信</p>
<p>vxlan(默认模式)：数据包从源主机POD发出，到cni0网桥接收</p>
<p>cni0网桥将数据包发送到flannel.1接口设备</p>
<p>flannel.1接口设备在内核态给数据包添加以太网头部和vxlan头部，封装到<strong>UDP报文</strong>中</p>
<p>flannel.1接口设备通过查询本地FDB表获取目标节点的nodeIP</p>
<p>通过节点网络发送UDP报文到目标节点</p>
<p>目标节点的UDP报文通过8472端口发送到flannel.1设备</p>
<p>目标节点的flannel.1设备在内核态解封装获取的原始数据包</p>
<p>数据包根据本地路由发送到cni0网桥</p>
<p>cni0将数据包发送到目标POD</p>
<p>Calico（BGP）：直接通过路由转发数据包到目标主机，不需要额外的封包和解包。</p>
<p>路由规则设置：每个pod有一对veth pair设备，一端接入Pod，另一端接入宿主机的网络空间，Felix维护路由规则</p>
<p>路由分发：Felix通过BIRD（BGP Client）使用BGP动态路由协议将路由规则分发给其他节点</p>
<p>数据包流向：</p>
<p>原始数据包从源主机的Pod发出</p>
<p>数据包经过<strong>veth</strong> pair设备送达<strong>宿主机网络空间</strong></p>
<p>根据<strong>Felix</strong>维护的<strong>路由规则</strong>，数据包通过<strong>物理网卡</strong>发送到目标节点</p>
<p>目标节点收到数据包后，根据<strong>本地路由规则</strong>，数据包经过<strong>veth</strong> pair设备发送到目标Pod</p>
<h2 id="DevOps类"><a href="#DevOps类" class="headerlink" title="DevOps类"></a>DevOps类</h2><p><img src="/./imgs/image-20251222201224911.png" alt="image-20251222201224911"></p>
<p><strong>怎么理解DevOps Cl&#x2F;CD Jenkins?</strong></p>
<p>答：DevOps是开发和运维的协作文化。</p>
<p>CI是持续集成(频繁合并代码)，CD是持续部署(自动发布)。</p>
<p>Jenkins是自动化流程编排工具。</p>
<p><strong>三者如何一起工作？（经典链路）</strong></p>
<p>想象一下这个过程：</p>
<ol>
<li><strong>开发：</strong> 提交代码到 GitLab。</li>
<li><strong>触发：</strong> GitLab 发送一个信号（Webhook）给 <strong>Jenkins</strong>。</li>
<li><strong>Jenkins 执行：</strong> * 从仓库拉取代码。<ul>
<li>调用 <strong>Maven</strong> 编译成 Java Jar 包。</li>
<li>调用 <strong>SonarQube</strong> 进行代码质量扫描。</li>
<li>调用 <strong>Docker</strong> 把 Jar 包封装成镜像，推送到私有仓库。</li>
<li>调用 <strong>Kubectl</strong> 更新集群，完成滚动更新。</li>
</ul>
</li>
<li><strong>反馈：</strong> Jenkins 告诉大家：“发布成功，新版本已上线！”</li>
</ol>
<p><strong>具体说说你是怎么理解CI和CD的?</strong></p>
<p>简单来说，<strong>CI&#x2F;CD 是软件开发的“自动驾驶系统”</strong>。如果把软件开发比作盖房子，CI 负责确保每一块运到工地的砖头都是合格的，而 CD 负责把合格的砖头自动砌到墙上。</p>
<p>我们可以从<strong>核心动作、解决的痛点、以及具体的流程</strong>来深度理解：</p>
<hr>
<h3 id="1-CI-Continuous-Integration-——-持续集成"><a href="#1-CI-Continuous-Integration-——-持续集成" class="headerlink" title="1. CI (Continuous Integration) —— 持续集成"></a>1. CI (Continuous Integration) —— 持续集成</h3><p><strong>核心：代码合并之前的“安检”。</strong></p>
<ul>
<li><p>为什么要 CI？</p>
<p>以前开发者各自写代码，几周甚至几个月才往主干（Main&#x2F;Master）合并一次。结果一合并，发现几千处冲突，代码根本跑不起来。这就是著名的**“集成地狱”**。</p>
</li>
<li><p><strong>具体在干什么？</strong></p>
<ul>
<li><strong>频繁合并：</strong> 开发者每天至少提交一次代码。</li>
<li><strong>自动构建：</strong> 每次提交，Jenkins 等工具会自动触发编译（比如把 Java 源码变成 Jar 包）。</li>
<li><strong>自动测试：</strong> 立即运行<strong>单元测试</strong>。如果测试失败，系统会立刻打回代码并通知开发者。</li>
</ul>
</li>
<li><p><strong>价值：</strong> 确保主干代码永远是“健康”的。</p>
</li>
</ul>
<hr>
<h3 id="2-CD-——-持续交付与持续部署"><a href="#2-CD-——-持续交付与持续部署" class="headerlink" title="2. CD —— 持续交付与持续部署"></a>2. CD —— 持续交付与持续部署</h3><p><strong>核心：代码通过安检后，如何“上路”。</strong></p>
<p>这里其实包含两个进阶层面，大家统称为 CD，但其实有细微差别：</p>
<h4 id="CD-Continuous-Delivery-持续交付"><a href="#CD-Continuous-Delivery-持续交付" class="headerlink" title="CD - Continuous Delivery (持续交付)"></a><strong>CD - Continuous Delivery (持续交付)</strong></h4><ul>
<li><strong>定义：</strong> 代码通过了 CI 阶段，已经具备了发布的资格。</li>
<li><strong>动作：</strong> 自动将代码部署到<strong>测试环境 (Staging)</strong> 或 <strong>预发环境</strong>。</li>
<li><strong>人工干预：</strong> <strong>最后一步发布到生产环境需要人来“点一下鼠标”</strong>。</li>
<li><strong>场景：</strong> 适合对稳定性要求极高，需要项目经理或运维最后确认的业务。</li>
</ul>
<h4 id="CD-Continuous-Deployment-持续部署"><a href="#CD-Continuous-Deployment-持续部署" class="headerlink" title="CD - Continuous Deployment (持续部署)"></a><strong>CD - Continuous Deployment (持续部署)</strong></h4><ul>
<li><strong>定义：</strong> 交付的终极形态。</li>
<li><strong>动作：</strong> 只要代码通过了所有自动化测试，系统就<strong>自动、直接</strong>把它部署到<strong>生产环境</strong>。</li>
<li><strong>核心：</strong> 完全去中心化，不需要人工干预。</li>
<li><strong>场景：</strong> 适合互联网敏捷开发，如 Facebook、Netflix，每天发布几百次。</li>
</ul>
<hr>
<h3 id="3-一张表总结-CI-与-CD-的差异"><a href="#3-一张表总结-CI-与-CD-的差异" class="headerlink" title="3. 一张表总结 CI 与 CD 的差异"></a>3. 一张表总结 CI 与 CD 的差异</h3><table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>核心任务</strong></th>
<th><strong>状态</strong></th>
<th><strong>目标</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>CI (集成)</strong></td>
<td>编译、打包、单元测试</td>
<td>自动化</td>
<td>发现代码冲突和逻辑错误</td>
</tr>
<tr>
<td><strong>CD (交付)</strong></td>
<td>部署到测试&#x2F;预发环境、集成测试</td>
<td>自动化 + 人工确认</td>
<td>确保随时可以发布</td>
</tr>
<tr>
<td><strong>CD (部署)</strong></td>
<td>部署到生产环境</td>
<td><strong>完全自动化</strong></td>
<td>实现业务价值的快速闭环</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-一个真实的例子（以你常用的-Nginx-项目为例）"><a href="#4-一个真实的例子（以你常用的-Nginx-项目为例）" class="headerlink" title="4. 一个真实的例子（以你常用的 Nginx 项目为例）"></a>4. 一个真实的例子（以你常用的 Nginx 项目为例）</h3><ol>
<li><strong>CI 阶段：</strong> 你改了 Nginx 的一个配置文件，代码推送到 GitLab。Jenkins 监测到变化，启动一个容器，检查配置语法（<code>nginx -t</code>）是否正确。</li>
<li><strong>CD 阶段：</strong><ul>
<li><strong>交付：</strong> 语法正确后，Jenkins 自动把这个配置应用到“测试服务器”上，你打开浏览器确认没问题。</li>
<li><strong>部署：</strong> 你点击 Jenkins 上的“确认发布”，它自动调用 <code>kubectl</code> 把这个配置更新到 K8s 集群的所有 Pod 上。</li>
</ul>
</li>
</ol>
<p><strong>详细说一下配置pipeline的过程,从代码提交到自动化部署完成的整个过程?</strong></p>
<p>配置 Jenkins Pipeline（流水线）的过程，实际上是将<strong>软件开发的生命周期代码化</strong>。我们通常使用 <code>Jenkinsfile</code>（基于 Groovy 脚本）来定义这个过程，并将其存放在代码仓库中。</p>
<p>以下是从代码提交到自动化部署的 5 个核心阶段：</p>
<hr>
<h3 id="1-环境准备与触发（Trigger）"><a href="#1-环境准备与触发（Trigger）" class="headerlink" title="1. 环境准备与触发（Trigger）"></a>1. 环境准备与触发（Trigger）</h3><p>流水线的起点是<strong>代码变更</strong>。</p>
<ul>
<li><strong>代码提交：</strong> 开发者将代码 <code>git push</code> 到 GitLab&#x2F;GitHub。</li>
<li><strong>Webhook 触发：</strong> GitLab 会向 Jenkins 发送一个 HTTP POST 请求（Webhook），告诉 Jenkins：“有新代码来了，快干活！”</li>
<li><strong>Jenkins 接收：</strong> Jenkins 根据配置找到对应的 Pipeline 任务，并分配一个 Agent（执行机）开始工作。</li>
</ul>
<hr>
<h3 id="2-阶段一：检出与环境检查-Checkout-Init"><a href="#2-阶段一：检出与环境检查-Checkout-Init" class="headerlink" title="2. 阶段一：检出与环境检查 (Checkout &amp; Init)"></a>2. 阶段一：检出与环境检查 (Checkout &amp; Init)</h3><p>Jenkins 在指定的节点上创建一个工作空间。</p>
<ul>
<li><strong>代码拉取：</strong> 通过 <code>git</code> 插件将指定分支的代码下载到本地。</li>
<li><strong>版本定义：</strong> 脚本会自动获取 Git Commit ID 作为镜像标签，确保版本可追溯。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        git <span class="attr">branch:</span> <span class="string">&#x27;main&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;http://gitlab.com/pro/demo.git&#x27;</span>, <span class="attr">credentialsId:</span> <span class="string">&#x27;git-auth&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-阶段二：构建与测试-Build-Test-——-CI-核心"><a href="#3-阶段二：构建与测试-Build-Test-——-CI-核心" class="headerlink" title="3. 阶段二：构建与测试 (Build &amp; Test) —— CI 核心"></a>3. 阶段二：构建与测试 (Build &amp; Test) —— <strong>CI 核心</strong></h3><p>这是确保代码质量的关键步骤。</p>
<ul>
<li><strong>编译打包：</strong> 如果是 Java，调用 <code>mvn clean package</code>；如果是 Go，执行 <code>go build</code>。</li>
<li><strong>单元测试：</strong> 运行测试脚本。如果测试失败，Pipeline 立即终止，并向开发发送报警（邮件&#x2F;钉钉）。</li>
<li><strong>代码扫描：</strong> 调用 <strong>SonarQube</strong> 插件进行静态代码分析，检查是否存在漏洞或不规范。</li>
</ul>
<hr>
<h3 id="4-阶段三：镜像制作与推送-Docker-Build-Push"><a href="#4-阶段三：镜像制作与推送-Docker-Build-Push" class="headerlink" title="4. 阶段三：镜像制作与推送 (Docker Build &amp; Push)"></a>4. 阶段三：镜像制作与推送 (Docker Build &amp; Push)</h3><p>在云原生环境下，我们将应用封装成容器镜像。</p>
<ul>
<li><strong>构建镜像：</strong> 执行 <code>docker build -t my-app:${BUILD_ID} .</code>。</li>
<li><strong>扫描镜像：</strong> 使用 Trivy 或 Clair 扫描镜像是否存在系统级漏洞。</li>
<li><strong>推送到私有库：</strong> 将镜像 <code>docker push</code> 到仓库（如 Harbor 或阿里云 ACR）。</li>
</ul>
<hr>
<h3 id="5-阶段四：自动化部署-Deploy-——-CD-核心"><a href="#5-阶段四：自动化部署-Deploy-——-CD-核心" class="headerlink" title="5. 阶段四：自动化部署 (Deploy) —— CD 核心"></a>5. 阶段四：自动化部署 (Deploy) —— <strong>CD 核心</strong></h3><p>根据部署目标的不同，通常有两种方式：</p>
<ul>
<li><strong>K8s 部署：</strong><ul>
<li>Jenkins 使用 <code>sed</code> 命令修改 <code>deployment.yaml</code> 中的镜像版本。</li>
<li>执行 <code>kubectl apply -f deployment.yaml</code>。</li>
<li><strong>健康检查：</strong> 脚本会循环检查 Pod 状态，如果 3 分钟内没达到 <code>Ready</code>，自动执行 <code>kubectl rollout undo</code> 回滚。</li>
</ul>
</li>
<li><strong>传统主机部署：</strong><ul>
<li>通过 Ansible 或 SSH 将 Jar 包传送到服务器，重启服务。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-阶段五：通知与清理-Post-Actions"><a href="#6-阶段五：通知与清理-Post-Actions" class="headerlink" title="6. 阶段五：通知与清理 (Post Actions)"></a>6. 阶段五：通知与清理 (Post Actions)</h3><p>无论成功或失败，都要有反馈。</p>
<ul>
<li><strong>发送通知：</strong> 通过 Webhook 将执行结果推送至钉钉群或企业微信。</li>
<li><strong>清理现场：</strong> 删除工作目录中的临时文件和过期的 Docker 镜像，释放磁盘空间。</li>
</ul>
<hr>
<h3 id="总结：一份完整的-Jenkinsfile-结构"><a href="#总结：一份完整的-Jenkinsfile-结构" class="headerlink" title="总结：一份完整的 Jenkinsfile 结构"></a>总结：一份完整的 Jenkinsfile 结构</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;编译打包&#x27;</span>) &#123;</span><br><span class="line">            steps &#123; sh <span class="string">&#x27;mvn clean package -DskipTests&#x27;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;镜像制作&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;docker build -t harbor.com/app:v$&#123;BUILD_NUMBER&#125; .&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;docker push harbor.com/app:v$&#123;BUILD_NUMBER&#125;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;部署K8s&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&quot;sed -i &#x27;s|IMAGE_TAG|v$&#123;BUILD_NUMBER&#125;|g&#x27; k8s.yaml&quot;</span></span><br><span class="line">                sh <span class="string">&#x27;kubectl apply -f k8s.yaml&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        failure &#123;</span><br><span class="line">            echo <span class="string">&#x27;部署失败，请检查日志！&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jenkins配置gitlab自动触发编译的过程?</strong></p>
<p>简述：答：1.Gitlab生成Access Token → 2.Jenkins配置Gitlab连接 → 3.项目配置webhook → 4.Webhook指向Jenkins URL(<a target="_blank" rel="noopener" href="http://jenkins-ip:8080/project/xxx">http://jenkins-ip:8080/project/xxx</a>) → 5.代码提交自动触发Pipeline。</p>
<p>要实现 <strong>GitLab 代码提交后自动触发 Jenkins 编译</strong>，核心原理是利用 <strong>Webhook（网络钩子）</strong>。</p>
<p>整个配置过程可以分为四个关键步骤。以下是详细的实操指南：</p>
<hr>
<h3 id="第一步：Jenkins-安装插件与准备"><a href="#第一步：Jenkins-安装插件与准备" class="headerlink" title="第一步：Jenkins 安装插件与准备"></a>第一步：Jenkins 安装插件与准备</h3><p>首先，Jenkins 需要具备处理 GitLab 请求的能力。</p>
<ol>
<li><p><strong>安装插件：</strong></p>
<ul>
<li>进入 <code>Manage Jenkins</code> -&gt; <code>Plugins</code>。</li>
<li>搜索并安装：<strong>GitLab Plugin</strong> 和 <strong>Generic Webhook Trigger Plugin</strong>。</li>
</ul>
<p><img src="/./imgs/image-20251222201611570.png" alt="image-20251222201611570"></p>
</li>
<li><p><strong>配置 GitLab 凭据：</strong></p>
<ul>
<li>在 <code>Manage Jenkins</code> -&gt; <code>Credentials</code> 中添加 GitLab 的 API Token（在 GitLab 的 User Settings -&gt; Access Tokens 中生成），以便 Jenkins 能将构建状态回传给 GitLab。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="第二步：Jenkins-侧配置-Pipeline-任务"><a href="#第二步：Jenkins-侧配置-Pipeline-任务" class="headerlink" title="第二步：Jenkins 侧配置 Pipeline 任务"></a>第二步：Jenkins 侧配置 Pipeline 任务</h3><p><img src="/./imgs/image-20251222201410579.png" alt="image-20251222201410579"></p>
<p>你需要告诉 Jenkins 哪些项目需要监听 GitLab 的信号。</p>
<ol>
<li><p><strong>新建任务：</strong> 创建一个 <code>Pipeline</code> 或 <code>Freestyle</code> 项目。</p>
</li>
<li><p><strong>构建触发器 (Build Triggers)：</strong></p>
<ul>
<li>勾选 <strong>Build when a change is pushed to GitLab</strong>。</li>
<li><strong>记下旁边的 GitLab webhook URL</strong>（通常是 <code>http://your-jenkins-ip:8080/project/your-job-name</code>）。</li>
</ul>
</li>
<li><p><strong>生成 Token：</strong></p>
<ul>
<li>点击右下角的 <code>Advanced</code>（高级）按钮。</li>
<li>在 <code>Secret token</code> 栏点击 <strong>Generate</strong>，<strong>记下这个 Token</strong>。</li>
</ul>
<p><img src="/./imgs/image-20251222201509288.png" alt="image-20251222201509288"></p>
</li>
<li><p><strong>配置过滤（可选）：</strong></p>
<ul>
<li>你可以指定只有特定的分支（如 <code>main</code> 或 <code>develop</code>）提交代码时才触发。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="第三步：GitLab-侧配置-Webhook"><a href="#第三步：GitLab-侧配置-Webhook" class="headerlink" title="第三步：GitLab 侧配置 Webhook"></a>第三步：GitLab 侧配置 Webhook</h3><p><img src="/./imgs/image-20251222201523510.png" alt="image-20251222201523510"></p>
<p>将 Jenkins 提供的地址和 Token 填入 GitLab 项目中。</p>
<ol>
<li><strong>进入项目：</strong> 在 GitLab 中打开你的代码仓库。</li>
<li><strong>设置 Webhook：</strong><ul>
<li>点击 <code>Settings</code> -&gt; <code>Webhooks</code>。</li>
<li><strong>URL：</strong> 填入刚才 Jenkins 任务中生成的 URL。</li>
<li><strong>Secret Token：</strong> 填入刚才 Jenkins 生成的 Secret Token。</li>
</ul>
</li>
<li><strong>选择触发事件：</strong><ul>
<li>通常勾选 <strong>Push events</strong>（代码推送）。</li>
<li>可选 <strong>Merge request events</strong>（合并请求时触发，常用于门禁测试）。</li>
</ul>
</li>
<li><strong>保存并测试：</strong><ul>
<li>点击 <code>Add webhook</code>。</li>
<li>在页面下方找到刚添加的 Webhook，点击 <code>Test</code> -&gt; <code>Push events</code>。</li>
<li>如果返回 <strong>HTTP 200</strong> 或 <strong>HTTP 201</strong>，说明链路打通了。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="第四步：Pipeline-脚本编写-Jenkinsfile"><a href="#第四步：Pipeline-脚本编写-Jenkinsfile" class="headerlink" title="第四步：Pipeline 脚本编写 (Jenkinsfile)"></a>第四步：Pipeline 脚本编写 (Jenkinsfile)</h3><p>在 Pipeline 脚本中，你可以通过环境变量感知是谁触发了这次编译。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    </span><br><span class="line">    triggers &#123;</span><br><span class="line">        <span class="comment">// 这一块也可以直接在代码里声明，代替 UI 界面上的勾选</span></span><br><span class="line">        gitlab(<span class="attr">triggerOnPush:</span> <span class="literal">true</span>, <span class="attr">triggerOnMergeRequest:</span> <span class="literal">true</span>, <span class="attr">branchFilterType:</span> <span class="string">&#x27;All&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Pull Code&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// git 检出</span></span><br><span class="line">                checkout scm</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo <span class="string">&quot;代码已被 GitLab 触发，正在编译...&quot;</span></span><br><span class="line">                sh <span class="string">&#x27;mvn clean compile&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    post &#123;</span><br><span class="line">        success &#123;</span><br><span class="line">            <span class="comment">// 构建成功后，Jenkins 会自动将绿色的勾传回 GitLab 的提交记录旁</span></span><br><span class="line">            updateGitlabCommitStatus <span class="attr">name:</span> <span class="string">&#x27;build&#x27;</span>, <span class="attr">state:</span> <span class="string">&#x27;success&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Jenkins插件安装失败,工作中如何解决?插件依赖的问题你是怎么解决的?</strong></p>
<p>答：1.检查网络和DNS → 2.更换插件源(国内源) → 3.手动上传.hpi文件 → 4.检查插件依赖版本 → 5.升级Jenkins版本 → 6.查看日志定位具体错误。</p>
<h2 id="综合类"><a href="#综合类" class="headerlink" title="综合类"></a>综合类</h2><p><strong>k8s中使用ingress暴露的应用,不能访问,如何排查?</strong></p>
<p>答：1.检查Ingress是否创建成功(kubectl get ingress) → 2.检查后端Service&#x2F;Pod是否健康 → 3.检查Ingress Controller是否运行 → 4.检查DNS解析 → 5.查看Ingress日志和事件 → 6.检查网络策略是否限制。</p>
<p><strong>若依项目微服务的数据是怎么流向的?</strong></p>
<p>若依（RuoYi-Cloud）微服务架构的数据流向，可以从**请求链路（北向流量）<strong>和</strong>内部调用（东向流量）**两个维度来拆解。它是一个典型的“网关 + 注册中心 + 配置中心”的微服务模型。</p>
<hr>
<h3 id="1-宏观请求流向：从浏览器到数据库"><a href="#1-宏观请求流向：从浏览器到数据库" class="headerlink" title="1. 宏观请求流向：从浏览器到数据库"></a>1. 宏观请求流向：从浏览器到数据库</h3><p>当用户点击页面上的按钮（如“查询用户列表”）时，数据流向如下：</p>
<ol>
<li><strong>客户端（Vue&#x2F;ElementUI）：</strong> 发起 Axios 请求，所有请求统一指向 <strong>Gateway（网关）</strong>。</li>
<li><strong>网关层（ruoyi-gateway）：</strong><ul>
<li><strong>鉴权：</strong> 从 Redis 验证 Token 状态。</li>
<li><strong>路由：</strong> 根据 URL 前缀（如 <code>/system</code> 或 <code>/auth</code>），利用 <strong>Nacos</strong> 找到对应的服务实例。</li>
<li><strong>限流&#x2F;黑名单：</strong> 拦截不符合规则的请求。</li>
</ul>
</li>
<li><strong>认证中心（ruoyi-auth）：</strong> 如果是登录请求，网关转发至此，验证账号密码，并将用户信息存入 Redis，生成 Token。</li>
<li><strong>业务服务（如 ruoyi-system）：</strong> 网关将请求转发给具体的业务服务。</li>
<li><strong>数据持久层（MySQL）：</strong> 业务服务通过 <strong>MyBatis</strong> 访问数据库，将结果原路返回。</li>
</ol>
<hr>
<h3 id="2-微服务间流向（内部调用）"><a href="#2-微服务间流向（内部调用）" class="headerlink" title="2. 微服务间流向（内部调用）"></a>2. 微服务间流向（内部调用）</h3><p>当一个服务需要获取另一个服务的数据时（例如：业务服务需要查询用户信息）：</p>
<ul>
<li><strong>RPC 调用（Feign）：</strong> * 服务 A（消费者）通过 <strong>Feign</strong> 接口发起伪 HTTP 调用。<ul>
<li><strong>LoadBalancer（负载均衡）：</strong> 在本地通过 Nacos 缓存的服务列表，选取一个健康的服务 B（提供者）实例。</li>
</ul>
</li>
<li><strong>配置中心（Nacos）：</strong> 所有服务启动时，从 Nacos 动态拉取数据库连接、Redis 地址等配置信息。</li>
<li><strong>异步流向（MQ - 可选）：</strong> 若项目中集成了消息队列，部分非实时数据（如日志采集、邮件发送）会通过 RabbitMQ&#x2F;RocketMQ 异步流向专门的处理服务。</li>
</ul>
<hr>
<h3 id="3-组件间的数据交互关系"><a href="#3-组件间的数据交互关系" class="headerlink" title="3. 组件间的数据交互关系"></a>3. 组件间的数据交互关系</h3><p>若依微服务中，各个核心组件之间的数据流向关系如下表：</p>
<table>
<thead>
<tr>
<th><strong>数据交互对象</strong></th>
<th><strong>交互内容</strong></th>
<th><strong>媒介</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Vue &lt;-&gt; Gateway</strong></td>
<td>业务请求、Restful 接口</td>
<td>HTTP&#x2F;JSON</td>
</tr>
<tr>
<td><strong>Gateway &lt;-&gt; Redis</strong></td>
<td>验证 Token 是否有效、黑名单列表</td>
<td>Redis 协议</td>
</tr>
<tr>
<td><strong>Service &lt;-&gt; Nacos</strong></td>
<td>注册服务地址、获取 YAML 配置</td>
<td>gRPC&#x2F;HTTP</td>
</tr>
<tr>
<td><strong>Service A &lt;-&gt; Service B</strong></td>
<td>跨服务数据取值（如系统参数、字典）</td>
<td><strong>OpenFeign</strong></td>
</tr>
<tr>
<td><strong>Service &lt;-&gt; MySQL</strong></td>
<td>业务数据增删改查</td>
<td>JDBC&#x2F;Druid</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-详细的认证数据流向（特色环节）"><a href="#4-详细的认证数据流向（特色环节）" class="headerlink" title="4. 详细的认证数据流向（特色环节）"></a>4. 详细的认证数据流向（特色环节）</h3><p>若依微服务采用了 <strong>无状态 JWT + Redis</strong> 的模式，其权限数据流向比较特殊：</p>
<ol>
<li><strong>登录成功：</strong> <code>ruoyi-auth</code> 将用户信息、角色、权限封装成对象，存入 <strong>Redis</strong>（Key 是 UUID）。</li>
<li><strong>前端携带：</strong> 返回给前端一个包含 UUID 的 Token。</li>
<li><strong>后续请求：</strong> 前端在 Header 携带 Token 请求网关。</li>
<li><strong>内部透传：</strong> 网关拦截请求，根据 Token 从 Redis 查出用户信息，将其放入 <strong>HTTP Header</strong> 中向下游服务转发。</li>
<li><strong>服务解析：</strong> 业务服务从 Header 中直接读取用户信息，无需再次查询数据库，提高了性能。</li>
</ol>
<hr>
<h3 id="5-总结：数据流转的核心"><a href="#5-总结：数据流转的核心" class="headerlink" title="5. 总结：数据流转的核心"></a>5. 总结：数据流转的核心</h3><p>若依微服务的数据流向核心逻辑是：<strong>“统一入口（Gateway）、自动发现（Nacos）、同步互联（Feign）、异步提速（Redis&#x2F;MQ）”</strong>。</p>
<p><strong>服务不能访问,如何排查?</strong></p>
<p>答：1.ping网络是否联通 → 2.telnet端口是否开放 → 3.netstat查看服务是否监听 → 4.查看应用日志 → 5.检查防火墙规则 → 6.检查DNS解析 → 7.检查负载均衡&#x2F;网关配置。</p>
<p><strong>若依项目中使用的后端有哪些技术?前端有哪些技术?前后端是如何对接(实际问题换成你在简历中写的项目)</strong></p>
<p>在简历中，如果你的项目是 <strong>HIS（医院信息系统）</strong> 并且基于若依（RuoYi）微服务架构开发，你可以按照以下结构来梳理技术栈和对接流程。这种表达方式能体现你对项目的深度掌控。</p>
<hr>
<h3 id="一、-后端技术栈（重点：稳、准、快）"><a href="#一、-后端技术栈（重点：稳、准、快）" class="headerlink" title="一、 后端技术栈（重点：稳、准、快）"></a>一、 后端技术栈（重点：稳、准、快）</h3><p>HIS 系统对数据的准确性和并发处理有极高要求，后端技术栈主要解决<strong>服务拆分、业务安全和高并发挂号&#x2F;缴费</strong>的问题：</p>
<ol>
<li><strong>核心框架</strong>：Spring Boot + Spring Cloud Alibaba（微服务标准套件）。</li>
<li><strong>注册&#x2F;配置中心</strong>：<strong>Nacos</strong>。解决 HIS 众多微服务（挂号、药房、诊间、住院）的自动发现与动态配置。</li>
<li><strong>网关</strong>：<strong>Spring Cloud Gateway</strong>。负责统一入口，进行患者身份校验、路由分发。</li>
<li><strong>远程调用</strong>：<strong>OpenFeign</strong>。例如：缴费服务调用药库服务检查库存。</li>
<li><strong>权限安全</strong>：<strong>Spring Security + JWT</strong>。HIS 涉及敏感病历数据，JWT 实现了无状态的跨服务鉴权。</li>
<li><strong>持久层</strong>：<strong>MyBatis-Plus + Druid</strong>。快速开发 CRUD，Druid 负责监控慢 SQL，防止因查询大型病历导致数据库崩溃。</li>
<li><strong>中间件</strong>：<ul>
<li><strong>Redis</strong>：缓存字典数据（如药品分类）、排班信息、分布式锁（防止挂号超卖）。</li>
<li><strong>RabbitMQ</strong>：处理耗时操作。例如：患者缴费后，异步通知药房配药、打印电子发票。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、-前端技术栈（重点：交互、图表、适配）"><a href="#二、-前端技术栈（重点：交互、图表、适配）" class="headerlink" title="二、 前端技术栈（重点：交互、图表、适配）"></a>二、 前端技术栈（重点：交互、图表、适配）</h3><p>HIS 前端（医生站、护士站、收费处）强调<strong>高频率操作和多端展示</strong>：</p>
<ol>
<li><strong>框架</strong>：<strong>Vue.js (Vue 2 或 Vue 3)</strong>。单页面架构，页面切换流畅。</li>
<li><strong>UI 组件库</strong>：<strong>Element UI</strong>。若依封装了大量后台模板，适合医生站这种复杂的表单布局。</li>
<li><strong>状态管理</strong>：<strong>Vuex &#x2F; Pinia</strong>。存储当前登录的医生信息、所属科室、患者 ID 等全局状态。</li>
<li><strong>网络库</strong>：<strong>Axios</strong>。负责与后端 API 通信，封装了请求&#x2F;响应拦截器。</li>
<li><strong>数据可视化</strong>：<strong>ECharts</strong>。用于院长查询统计（如：每日就诊量走势、收入占比、药品消耗排名）。</li>
</ol>
<hr>
<h3 id="三、-前后端是如何对接的？（面试必问）"><a href="#三、-前后端是如何对接的？（面试必问）" class="headerlink" title="三、 前后端是如何对接的？（面试必问）"></a>三、 前后端是如何对接的？（面试必问）</h3><p>在你的 HIS 项目中，前后端通过 <strong>Restful API</strong> 进行“解耦对接”。具体流程如下：</p>
<h4 id="1-接口定义（约定阶段）"><a href="#1-接口定义（约定阶段）" class="headerlink" title="1. 接口定义（约定阶段）"></a>1. 接口定义（约定阶段）</h4><ul>
<li><strong>Swagger&#x2F;Knife4j</strong>：后端通过代码生成在线接口文档。前端开发者通过文档查看接口地址、请求参数（患者 ID、挂号科室）以及返回的 JSON 结构。</li>
</ul>
<h4 id="2-网关分发（路由阶段）"><a href="#2-网关分发（路由阶段）" class="headerlink" title="2. 网关分发（路由阶段）"></a>2. 网关分发（路由阶段）</h4><ul>
<li>前端所有请求统一发往 <code>http://his-api.com</code>（网关地址）。</li>
<li>网关根据 URL 前缀（如 <code>/his-system</code>、<code>/his-medical</code>）将请求分发给对应的后端微服务。</li>
</ul>
<h4 id="3-鉴权对接（核心环节）"><a href="#3-鉴权对接（核心环节）" class="headerlink" title="3. 鉴权对接（核心环节）"></a>3. 鉴权对接（核心环节）</h4><ul>
<li><strong>登录</strong>：前端发送用户名密码到认证服务。后端验证成功生成 <strong>JWT Token</strong> 返回。</li>
<li><strong>请求携带</strong>：前端使用 Axios 拦截器，将 Token 放入 Header 的 <code>Authorization</code> 字段中。</li>
<li><strong>校验</strong>：网关拦截每个请求，校验 Token 有效性，并从 Token 中解析出医生角色和权限。</li>
</ul>
<h4 id="4-跨域处理（Cors）"><a href="#4-跨域处理（Cors）" class="headerlink" title="4. 跨域处理（Cors）"></a>4. 跨域处理（Cors）</h4><ul>
<li>在网关层（Gateway）配置 <strong>CORS 策略</strong>，允许前端域名访问后端资源。</li>
</ul>
<h4 id="5-数据转换（交互阶段）"><a href="#5-数据转换（交互阶段）" class="headerlink" title="5. 数据转换（交互阶段）"></a>5. 数据转换（交互阶段）</h4><ul>
<li>前端将表单对象转为 <strong>JSON</strong> 字符串提交。</li>
<li>后端使用 <code>@RequestBody</code> 接收并处理业务。</li>
<li>后端统一返回 <code>R</code> 对象（包含 <code>code</code> 状态码, <code>msg</code> 提示信息, <code>data</code> 数据主体）。</li>
</ul>
<hr>
<h3 id="四、-简历亮点描述示例"><a href="#四、-简历亮点描述示例" class="headerlink" title="四、 简历亮点描述示例"></a>四、 简历亮点描述示例</h3><p>你可以这样写在简历里：</p>
<blockquote>
<p>“在 HIS 医院项目中，我基于 <strong>RuoYi-Cloud</strong> 架构实现了前后端分离开发。后端利用 <strong>Nacos</strong> 进行服务治理，通过 <strong>OpenFeign</strong> 解决了挂号与支付系统间的异构调用；前端采用 <strong>Vue + Axios</strong> 实现，并针对高并发挂号场景，利用 <strong>Redis 分布式锁</strong> 保证了库存的一致性。通过 <strong>Gateway</strong> 统一封装了跨域处理与 JWT 鉴权，实现了医院敏感数据的权限隔离。”</p>
</blockquote>
<p><strong>阿里云产品你都使用哪些,简单介绍一下你所使用的这些云产品?</strong></p>
<p>在实际的项目部署（如你提到的 <strong>HIS 医院项目</strong>）中，通常会结合阿里云的 <strong>IaaS（基础设施）</strong>、<strong>PaaS（平台服务）</strong> 和 <strong>网络安全产品</strong>。</p>
<h3 id="1-计算与容器服务（核心承载）"><a href="#1-计算与容器服务（核心承载）" class="headerlink" title="1. 计算与容器服务（核心承载）"></a>1. 计算与容器服务（核心承载）</h3><ul>
<li><strong>ECS (Elastic Compute Service - 云服务器)：</strong><ul>
<li><strong>作用：</strong> 最基础的计算资源。在非全量容器化阶段，用于部署 Jenkins、JumpServer（跳板机）或一些特定的中间件。</li>
</ul>
</li>
<li><strong>ACK (Alibaba Cloud Container Service for Kubernetes - 容器服务)：</strong><ul>
<li><strong>作用：</strong> 这是<strong>若依微服务版最理想的家</strong>。它托管了 K8s 集群。</li>
<li><strong>解决问题：</strong> 解决了 HIS 系统高并发时的动态扩容问题。比如早起挂号高峰期，ACK 可以根据 CPU 利用率自动增加挂号服务的 Pod 数量。</li>
</ul>
</li>
</ul>
<h3 id="2-网络与负载均衡（流量入口）"><a href="#2-网络与负载均衡（流量入口）" class="headerlink" title="2. 网络与负载均衡（流量入口）"></a>2. 网络与负载均衡（流量入口）</h3><ul>
<li><strong>SLB &#x2F; ALB (Server Load Balancer - 负载均衡)：</strong><ul>
<li><strong>作用：</strong> 放在网关（Gateway）的前面。</li>
<li><strong>解决问题：</strong> 它是系统的唯一入口 IP。它将外部流量分发到 ACK 集群中的不同节点上，并提供 HTTPS 证书卸载功能，减轻了后端服务的压力。</li>
</ul>
</li>
<li><strong>VPC (Virtual Private Cloud - 专有网络)：</strong><ul>
<li><strong>作用：</strong> 构建一个隔离的网络环境。</li>
<li><strong>解决问题：</strong> 确保 HIS 系统的数据库（RDS）只能被内网微服务访问，不暴露在公网上，保证医院数据的安全性。</li>
</ul>
</li>
</ul>
<h3 id="3-数据存储与缓存（数据底座）"><a href="#3-数据存储与缓存（数据底座）" class="headerlink" title="3. 数据存储与缓存（数据底座）"></a>3. 数据存储与缓存（数据底座）</h3><ul>
<li><strong>RDS for MySQL (Relational Database Service)：</strong><ul>
<li><strong>作用：</strong> 托管的 MySQL 数据库。</li>
<li><strong>解决问题：</strong> 解决了手动维护数据库的繁琐（如主从复制、自动备份、故障自动切换）。对于 HIS 系统，开启了“多可用区高可用”，确保机房断电时数据不丢失。</li>
</ul>
</li>
<li><strong>Redis (KV Store)：</strong><ul>
<li><strong>作用：</strong> 云版 Redis 缓存。</li>
<li><strong>解决问题：</strong> 存储若依的 Token 和排班缓存。相比自建 Redis，云产品提供了更直观的监控和一键扩容能力。</li>
</ul>
</li>
<li><strong>OSS (Object Storage Service - 对象存储)：</strong><ul>
<li><strong>作用：</strong> 存储非结构化数据。</li>
<li><strong>解决问题：</strong> HIS 项目中的<strong>患者电子病历附件、化验单图片、放射科 DICOM 影像</strong>等，都上传到 OSS，避免占用 ECS 磁盘。</li>
</ul>
</li>
</ul>
<h3 id="4-中间件与消息（解耦异步）"><a href="#4-中间件与消息（解耦异步）" class="headerlink" title="4. 中间件与消息（解耦异步）"></a>4. 中间件与消息（解耦异步）</h3><ul>
<li><strong>RocketMQ &#x2F; RabbitMQ：</strong><ul>
<li><strong>作用：</strong> 云托管的消息队列。</li>
<li><strong>解决问题：</strong> 实现业务解耦。比如患者“挂号成功”后，通过消息队列通知“短信平台”发消息，不需要挂号接口同步等待，提高吞吐量。</li>
</ul>
</li>
</ul>
<h3 id="5-安全与监控（稳定保障）"><a href="#5-安全与监控（稳定保障）" class="headerlink" title="5. 安全与监控（稳定保障）"></a>5. 安全与监控（稳定保障）</h3><ul>
<li><strong>ARMS (Application Real-Time Monitoring Service)：</strong><ul>
<li><strong>作用：</strong> 应用实时监控。</li>
<li><strong>解决问题：</strong> 这就是云上的 <strong>SkyWalking</strong>。它能看到每一个 SQL 的耗时，如果 HIS 系统某个接口变慢，ARMS 能直接定位到是哪一行代码或者哪一个数据库调用导致的。</li>
</ul>
</li>
<li><strong>WAF (Web Application Firewall - Web 应用防火墙)：</strong><ul>
<li><strong>作用：</strong> 过滤恶意请求。</li>
<li><strong>解决问题：</strong> 防止 SQL 注入、XSS 攻击。在 HIS 这种涉及大量隐私的项目中非常重要。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：在简历中如何组织这段话？"><a href="#总结：在简历中如何组织这段话？" class="headerlink" title="总结：在简历中如何组织这段话？"></a>总结：在简历中如何组织这段话？</h3><blockquote>
<p>“在项目中，我主要使用了阿里云的 <strong>ACK</strong> 托管 K8s 集群来部署微服务。通过 <strong>RDS</strong> 和 <strong>Redis</strong> 实现数据的持久化与高并发缓存，并利用 <strong>OSS</strong> 存储患者的化验单影像。网络层面通过 <strong>SLB</strong> 做流量分发，并配合 <strong>VPC</strong> 进行内网隔离，同时利用 <strong>ARMS</strong> 进行全链路监控，确保了 HIS 系统的高可用和数据安全性。”</p>
</blockquote>
<p><strong>什么是脑裂,RAFT算法如何避免脑裂的?</strong></p>
<p>在分布式系统中，“脑裂”（Split-Brain）是一个非常形象且危险的概念。</p>
<h3 id="1-什么是脑裂？"><a href="#1-什么是脑裂？" class="headerlink" title="1. 什么是脑裂？"></a>1. 什么是脑裂？</h3><p><strong>脑裂</strong>是指在一个原本统一的集群中，由于网络故障（如网线断开、交换机异常）导致集群分裂成两个或多个独立的子集群。</p>
<ul>
<li><strong>现象：</strong> 每个子集群都认为对方“挂了”，于是各自选举出自己的“大脑”（主节点&#x2F;Leader）。</li>
<li><strong>后果：</strong> * <strong>数据冲突：</strong> 不同的客户端可能向不同的 Leader 写入不同的数据，导致数据不一致。<ul>
<li><strong>数据丢失：</strong> 当网络恢复、集群重新合并时，其中一个 Leader 的数据可能会被另一个覆盖，导致部分已确认的数据永久丢失。</li>
<li><strong>资源竞争：</strong> 多个主节点可能同时抢占同一个共享资源（如数据库连接、共享磁盘），导致文件损坏。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-RAFT-算法如何避免脑裂？"><a href="#2-RAFT-算法如何避免脑裂？" class="headerlink" title="2. RAFT 算法如何避免脑裂？"></a>2. RAFT 算法如何避免脑裂？</h3><p>RAFT 算法作为目前最流行的共识算法，通过一套严密的<strong>数学机制</strong>和<strong>任期逻辑</strong>，从根本上杜绝了脑裂的发生。</p>
<h4 id="①-过半投票机制（Quorum）"><a href="#①-过半投票机制（Quorum）" class="headerlink" title="① 过半投票机制（Quorum）"></a>① 过半投票机制（Quorum）</h4><p>这是最核心的防御手段。</p>
<ul>
<li><strong>规则：</strong> 一个节点想要成为 Leader，必须获得集群中**超过半数（n&#x2F;2 + 1）**的选票。</li>
<li><strong>逻辑：</strong> * 在一个 5 节点的集群中，半数以上是 3。<ul>
<li>如果网络分裂成 2 节点和 3 节点两个分区，只有 3 节点的分区能选出 Leader。</li>
<li>2 节点的分区因为凑不够 3 票，永远无法选出 Leader。</li>
<li><strong>结论：</strong> 在任何时候，全集群最多只会存在一个合法的 Leader。</li>
</ul>
</li>
</ul>
<h4 id="②-任期编号（Term）"><a href="#②-任期编号（Term）" class="headerlink" title="② 任期编号（Term）"></a>② 任期编号（Term）</h4><p>RAFT 把时间切分为一段段连续的“任期”。</p>
<ul>
<li><strong>规则：</strong> 每个 Leader 都有一个唯一的 <code>Term</code> 编号，且编号是单调递增的。</li>
<li><strong>逻辑：</strong> * 如果老 Leader 被隔离在少数派分区，它虽然自以为还是 Leader，但它的 <code>Term</code> 已经落后了。<ul>
<li>当网络恢复，老 Leader 尝试发指令给其他节点时，其他节点发现它的 <code>Term</code> 比较小，会立即拒绝它的请求并强迫它退化为 Follower。</li>
</ul>
</li>
<li><strong>结论：</strong> 高任期的 Leader 具有绝对的统治权，老 Leader 会被自动“废黜”。</li>
</ul>
<h4 id="③-预投票机制（Pre-Vote）——-进阶优化"><a href="#③-预投票机制（Pre-Vote）——-进阶优化" class="headerlink" title="③ 预投票机制（Pre-Vote）—— 进阶优化"></a>③ 预投票机制（Pre-Vote）—— 进阶优化</h4><p>在某些网络不稳定的情况下，被隔离的孤立节点会不断增加自己的 <code>Term</code> 并发起选举，导致网络恢复后由于它的 <code>Term</code> 太高而踢掉现有的正常 Leader（这叫“干扰选举”）。</p>
<ul>
<li><strong>做法：</strong> 节点在正式增加 <code>Term</code> 启动选举前，先发起一次“预投票”。如果它发现自己连多数派都连不上，就根本不会增加 <code>Term</code>。</li>
<li><strong>结论：</strong> 进一步减少了网络波动对集群稳定性的冲击。</li>
</ul>
<h4 id="④-选票只能投一次"><a href="#④-选票只能投一次" class="headerlink" title="④ 选票只能投一次"></a>④ 选票只能投一次</h4><p>在同一个 <code>Term</code> 内，每个节点只能投出一张票。这确保了不会在同一个任期内出现两个节点同时赢得多数选票的情况。</p>
<hr>
<h3 id="3-特殊情况：如果是-2-个节点的集群呢？"><a href="#3-特殊情况：如果是-2-个节点的集群呢？" class="headerlink" title="3. 特殊情况：如果是 2 个节点的集群呢？"></a>3. 特殊情况：如果是 2 个节点的集群呢？</h3><p>如果集群只有 2 个节点，按照 <strong>n&#x2F;2 + 1</strong> 的公式：</p>
<ul>
<li>$2&#x2F;2 + 1 &#x3D; 2$。</li>
<li>这意味着任何操作都必须 2 个节点全部同意。如果其中 1 个节点挂了或网络断了，剩下的那一个节点也无法工作。</li>
<li><strong>最佳实践：</strong> 所以在生产环境中，部署 RAFT 集群（如 ZooKeeper, etcd）通常建议使用 <strong>3、5、7 等奇数个节点</strong>，这样容错能力最强。</li>
</ul>
<hr>
<h3 id="💡-面试加分点：如何解决“线性一致性读”中的脑裂？"><a href="#💡-面试加分点：如何解决“线性一致性读”中的脑裂？" class="headerlink" title="💡 面试加分点：如何解决“线性一致性读”中的脑裂？"></a>💡 面试加分点：如何解决“线性一致性读”中的脑裂？</h3><p>有时候虽然 Leader 没变，但它被隔离到了少数派，由于它还不知道自己被废了，可能会返回旧数据（Stale Read）。</p>
<ul>
<li><strong>解决：</strong> 优秀的实现（如 etcd）会引入 <strong>Leader Lease（领导者租约）</strong>。只有在租约期内，且 Leader 能定期确认自己依然拥有多数派支持时，才允许提供读服务。</li>
</ul>
<p><strong>作为运维工程师的一天主要都做些什么?</strong></p>
<p>答：1.早上检查系统健康状况(监控告警) → 2.处理故障和问题 → 3.代码发布和部署 → 4.系统优化和性能调优 → 5.容量规划和扩容 → 6.文档和知识库维护 → 7.值班和应急响应。</p>
<h2 id="微服务类"><a href="#微服务类" class="headerlink" title="微服务类"></a>微服务类</h2><p><strong>若依微服务项目中,都使用哪些技术,这些技术在这个项目中主要的作用是什么?解决那方面的问题?</strong></p>
<p>若依微服务版（RuoYi-Cloud）是一个非常经典的微服务架构实战项目。它集成了目前 Java 后端主流的 <strong>Spring Cloud Alibaba</strong> 生态。</p>
<p>以下是该项目使用的核心技术及其在项目中的角色、解决的具体问题：</p>
<hr>
<h3 id="1-核心框架与基础架构"><a href="#1-核心框架与基础架构" class="headerlink" title="1. 核心框架与基础架构"></a>1. 核心框架与基础架构</h3><table>
<thead>
<tr>
<th><strong>技术名称</strong></th>
<th><strong>主要作用</strong></th>
<th><strong>解决的问题</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Spring Boot</strong></td>
<td>整个项目的基石，负责自动配置和快速启动。</td>
<td>解决了 Spring 繁琐的 XML 配置问题，实现了服务的零成本启动。</td>
</tr>
<tr>
<td><strong>Spring Cloud Alibaba</strong></td>
<td>微服务治理的核心套件（包含 Nacos, Sentinel 等）。</td>
<td>解决了微服务拆分后带来的通信、配置、流量控制等一系列复杂管理问题。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-微服务治理组件-关键"><a href="#2-微服务治理组件-关键" class="headerlink" title="2. 微服务治理组件 (关键)"></a>2. 微服务治理组件 (关键)</h3><h4 id="Nacos-注册中心-配置中心"><a href="#Nacos-注册中心-配置中心" class="headerlink" title="Nacos (注册中心 + 配置中心)"></a><strong>Nacos (注册中心 + 配置中心)</strong></h4><ul>
<li><strong>作用：</strong> 服务启动时向 Nacos 登记 IP 和端口；同时管理所有服务的 YAML 配置文件。</li>
<li><strong>解决问题：</strong><ul>
<li><strong>服务发现：</strong> 解决服务间调用时，由于 Pod IP 经常漂移导致找不到目标服务器的问题。</li>
<li><strong>动态配置：</strong> 修改数据库连接或参数时，无需重启服务，实现配置秒级生效。</li>
</ul>
</li>
</ul>
<h4 id="Spring-Cloud-Gateway-网关"><a href="#Spring-Cloud-Gateway-网关" class="headerlink" title="Spring Cloud Gateway (网关)"></a><strong>Spring Cloud Gateway (网关)</strong></h4><ul>
<li><strong>作用：</strong> 作为所有外部请求的唯一入口，负责路由转发、权限校验、限流。</li>
<li><strong>解决问题：</strong><ul>
<li><strong>统一入口：</strong> 解决前端需要记住几十个微服务地址的问题。</li>
<li><strong>安全防线：</strong> 在网关层拦截非法 Token，防止攻击者直接绕过验证访问内网服务。</li>
</ul>
</li>
</ul>
<h4 id="Sentinel-流量防卫兵"><a href="#Sentinel-流量防卫兵" class="headerlink" title="Sentinel (流量防卫兵)"></a><strong>Sentinel (流量防卫兵)</strong></h4><ul>
<li><strong>作用：</strong> 监控接口 QPS，实现熔断、降级和限流。</li>
<li><strong>解决问题：</strong> * <strong>雪崩效应：</strong> 当“用户服务”挂了，“订单服务”调用它时会一直等待导致自身也挂掉。Sentinel 会及时断开（熔断），防止一个服务拖死整个集群。</li>
</ul>
<hr>
<h3 id="3-通信与中间件"><a href="#3-通信与中间件" class="headerlink" title="3. 通信与中间件"></a>3. 通信与中间件</h3><h4 id="OpenFeign-声明式调用"><a href="#OpenFeign-声明式调用" class="headerlink" title="OpenFeign (声明式调用)"></a><strong>OpenFeign (声明式调用)</strong></h4><ul>
<li><strong>作用：</strong> 像调用本地方法一样调用远程微服务的接口。</li>
<li><strong>解决问题：</strong> 简化了 HTTP 请求的代码编写。你不需要写复杂的 RestTemplate 逻辑，只需要定义一个 Java 接口即可。</li>
</ul>
<h4 id="Redis-分布式缓存"><a href="#Redis-分布式缓存" class="headerlink" title="Redis (分布式缓存)"></a><strong>Redis (分布式缓存)</strong></h4><ul>
<li><strong>作用：</strong> 存储用户 Token、权限数据、数据字典、防重提交等。</li>
<li><strong>解决问题：</strong> * <strong>高性能：</strong> 减少对 MySQL 的直接访问，提升系统响应速度。<ul>
<li><strong>分布式 Session：</strong> 解决微服务多实例环境下，用户登录状态共享的问题。</li>
</ul>
</li>
</ul>
<h4 id="RabbitMQ-RocketMQ-消息队列"><a href="#RabbitMQ-RocketMQ-消息队列" class="headerlink" title="RabbitMQ &#x2F; RocketMQ (消息队列)"></a><strong>RabbitMQ &#x2F; RocketMQ (消息队列)</strong></h4><ul>
<li><strong>作用：</strong> 负责服务间的异步通信，如日志记录、消息通知。</li>
<li><strong>解决问题：</strong> <strong>流量削峰填谷</strong>。例如大批量导入用户时，先发消息到队列，慢慢处理，防止瞬间压垮服务器。</li>
</ul>
<hr>
<h3 id="4-权限与安全"><a href="#4-权限与安全" class="headerlink" title="4. 权限与安全"></a>4. 权限与安全</h3><h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT (JSON Web Token)"></a><strong>JWT (JSON Web Token)</strong></h4><ul>
<li><strong>作用：</strong> 跨微服务的身份验证凭证。</li>
<li><strong>解决问题：</strong> 实现<strong>无状态登录</strong>。网关解析 JWT 后，下游服务无需再去数据库查询“这个人是谁”，直接从 Token 中解密出用户信息。</li>
</ul>
<hr>
<h3 id="5-数据持久层"><a href="#5-数据持久层" class="headerlink" title="5. 数据持久层"></a>5. 数据持久层</h3><table>
<thead>
<tr>
<th><strong>技术名称</strong></th>
<th><strong>主要作用</strong></th>
<th><strong>解决的问题</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MySQL</strong></td>
<td>核心业务数据的关系型存储。</td>
<td>保证业务数据的 ACID 特性（一致性、持久性）。</td>
</tr>
<tr>
<td><strong>MyBatis-Plus</strong></td>
<td>数据库操作框架（ORM）。</td>
<td>解决了原生 MyBatis 编写大量重复 SQL 的痛苦，提供开箱即用的 CRUD 功能。</td>
</tr>
<tr>
<td><strong>Druid</strong></td>
<td>数据库连接池。</td>
<td>监控数据库访问性能，防止连接泄露和瞬间并发过高导致数据库崩溃。</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-运维与监控"><a href="#6-运维与监控" class="headerlink" title="6. 运维与监控"></a>6. 运维与监控</h3><ul>
<li><strong>SkyWalking (链路追踪)：</strong> 解决“一个请求报错了，到底卡在哪个微服务”的问题。</li>
<li><strong>ELK (Elasticsearch + Logstash + Kibana)：</strong> 解决分布式环境下，日志分散在不同机器难以检索的问题。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>若依项目通过这套技术栈，完成了一个**从“开发”到“部署”再到“监控”**的闭环：</p>
<ol>
<li><strong>Nacos</strong> 解决了“你在哪”和“你怎么配”的问题。</li>
<li><strong>Gateway</strong> 解决了“谁能进”的问题。</li>
<li><strong>Feign</strong> 解决了“怎么说话”的问题。</li>
<li><strong>Sentinel</strong> 解决了“别被压死”的问题。</li>
<li><strong>Redis</strong> 解决了“跑得快”的问题。</li>
</ol>
<p><strong>微服务中?什么是熔断什么限流,什么是流量管控?</strong></p>
<p><strong>微服务中什么是熔断?</strong></p>
<p>答：服务故障或请求失败率过高时，暂停调用该服务，返回降级结果，避免故障扩散。一段时间后自动恢复。</p>
<p><strong>什么是限流?</strong></p>
<p>答：限制在单位时间内的请求数量，保护系统不被突发流量压垮。算法有令牌桶、漏桶、计数器等。</p>
<p><strong>什么是流量管控?</strong></p>
<p>答：通过权重分配、超时控制、重试策略、优先级划分等手段，管理和调度流量，实现高可用和资源高效利用。</p>
<p>在微服务的高并发场景下，<strong>限流、熔断和流量管控</strong>是保护系统的三道防火墙。它们的核心目的都是为了防止系统因为负载过高而产生“雪崩效应”。</p>
<p>我们可以用**“大坝排洪”**的逻辑来形象理解这三个概念：</p>
<hr>
<h4 id="1-限流-Rate-Limiting-——-“控制入口水量”"><a href="#1-限流-Rate-Limiting-——-“控制入口水量”" class="headerlink" title="1. 限流 (Rate Limiting) —— “控制入口水量”"></a>1. 限流 (Rate Limiting) —— “控制入口水量”</h4><p><strong>定义：</strong> 限制进入系统的请求总量或单位时间内的请求速率。</p>
<ul>
<li><strong>打比方：</strong> 景区门口的旋转闸机。每分钟只放 100 个人进去，后面的人只能在门口排队或者被劝返。</li>
<li><strong>解决的问题：</strong> 防止外部突发流量（如秒杀、攻击）把系统冲垮。</li>
<li><strong>常用算法：</strong> 令牌桶算法、漏桶算法。</li>
<li><strong>若依中的实现：</strong> 在 <code>ruoyi-gateway</code> 网关层配置 Redis + Lua 脚本，或者使用 <strong>Sentinel</strong> 定义 QPS 阈值。</li>
</ul>
<hr>
<h4 id="2-熔断-Circuit-Breaking-——-“家里的保险丝”"><a href="#2-熔断-Circuit-Breaking-——-“家里的保险丝”" class="headerlink" title="2. 熔断 (Circuit Breaking) —— “家里的保险丝”"></a>2. 熔断 (Circuit Breaking) —— “家里的保险丝”</h4><p><strong>定义：</strong> 当下游服务出现故障（如响应慢、频繁报错）时，上游服务暂时切断对它的调用，直接返回一个预设的错误（降级处理）。</p>
<ul>
<li><strong>打比方：</strong> 电路中的保险丝。当某个电器（服务）短路火花四溅时，保险丝自动烧断，防止整个屋子的电路被烧毁。</li>
<li><strong>解决的问题：</strong> 防止<strong>级联故障</strong>。如果 A 调 B，B 响应极慢，A 的线程就会被卡死，最终导致整个系统的线程池耗尽。</li>
<li>状态切换： 1.  关闭 (Closed)： 正常工作。<ol start="2">
<li>打开 (Open)： 故障触发，请求直接拒绝。</li>
<li>半开 (Half-Open)： 尝试放行少量请求，若成功则恢复正常，若失败则继续熔断。</li>
</ol>
</li>
<li><strong>若依中的实现：</strong> 使用 <strong>Sentinel</strong> 或 <strong>Hystrix</strong>。当接口错误率达到 50% 或耗时过长，自动触发熔断。</li>
</ul>
<hr>
<h4 id="3-流量管控-Traffic-Control-Governance-——-“交警指挥交通”"><a href="#3-流量管控-Traffic-Control-Governance-——-“交警指挥交通”" class="headerlink" title="3. 流量管控 (Traffic Control &#x2F; Governance) —— “交警指挥交通”"></a>3. 流量管控 (Traffic Control &#x2F; Governance) —— “交警指挥交通”</h4><p><strong>定义：</strong> 这是一个更宏观的概念，指对流量进行精准的调度和分配。它不仅仅是限制，更多是**“调配”**。</p>
<ul>
<li><strong>核心功能：</strong><ul>
<li><strong>灰度发布 &#x2F; 蓝绿部署：</strong> 让 10% 的流量去访问新版本（V2），90% 访问旧版本（V1），确认没问题后再全部切换。</li>
<li><strong>读写分离 &#x2F; 动静分离：</strong> 让查询请求去读库，写入请求去写库。</li>
<li><strong>权重分配：</strong> 性能好的服务器分配 80% 流量，性能差的分配 20%。</li>
<li><strong>全链路压测流量标记：</strong> 区分真实的业务流量和测试流量。</li>
</ul>
</li>
<li><strong>解决的问题：</strong> 提高系统的灵活性和高可用性，实现无损平滑升级。</li>
</ul>
<hr>
<h4 id="💡-三者对比总结"><a href="#💡-三者对比总结" class="headerlink" title="💡 三者对比总结"></a>💡 三者对比总结</h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>限流</strong></th>
<th><strong>熔断</strong></th>
<th><strong>流量管控</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>关注点</strong></td>
<td><strong>入口请求量</strong></td>
<td><strong>后端服务质量</strong></td>
<td><strong>流量流向与分配</strong></td>
</tr>
<tr>
<td><strong>动作</strong></td>
<td>丢弃或排队多余请求</td>
<td>直接阻断故障调用</td>
<td>路由转发、权重调整</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>保护自己不被压垮</td>
<td>保护整个调用链不雪崩</td>
<td>灰度发布、优化资源利用</td>
</tr>
<tr>
<td><strong>典型工具</strong></td>
<td>Sentinel、Nginx</td>
<td>Sentinel、Hystrix</td>
<td>Istio (Service Mesh)、Nacos</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-什么是“降级”-Fallback-？"><a href="#4-什么是“降级”-Fallback-？" class="headerlink" title="4. 什么是“降级” (Fallback)？"></a>4. 什么是“降级” (Fallback)？</h4><p>提到熔断，必须说降级。降级是熔断后的**“备选方案”**。</p>
<ul>
<li><strong>例子：</strong> 当“商品评论服务”熔断后，系统不再显示真实的实时评论，而是显示一段默认文字：“评价系统升级中，请稍后再试”。这就是<strong>服务降级</strong>。它保证了虽然部分功能不可用，但主流程（如购买）依然能跑通。</li>
</ul>
<p><strong>在若依项目中，如果你想给某个 Feign 接口配置熔断降级，通常需要在配置文件开启 <code>feign.sentinel.enabled=true</code> 并编写对应的 <code>Fallback</code> 类。需要我为你演示一下这段代码怎么写吗？</strong></p>
<p>拓展：Kafka，消息队列</p>
<p>原理是防止B服务处理的时候，重启导致内存中的消息丢失，将队列拿出来即消息队列</p>
<p><img src="/./imgs/image-20251222131156899.png" alt="image-20251222131156899"></p>
<p><img src="/./imgs/image-20251222131558414.png" alt="image-20251222131558414"></p>
<h1 id="Linux和DevOps工程师面试题库"><a href="#Linux和DevOps工程师面试题库" class="headerlink" title="Linux和DevOps工程师面试题库"></a>Linux和DevOps工程师面试题库</h1><h2 id="Linux系统类"><a href="#Linux系统类" class="headerlink" title="Linux系统类"></a>Linux系统类</h2><h3 id="Linux系统的启动过程"><a href="#Linux系统的启动过程" class="headerlink" title="Linux系统的启动过程?"></a>Linux系统的启动过程?</h3><p>答：BIOS自检 → 加载MBR → GRUB引导加载 → 加载内核kernel → 启动init进程(PID&#x3D;1) → 运行各种系统服务 → 进入登录界面。</p>
<h3 id="工作中常使用的Linux命令有哪些"><a href="#工作中常使用的Linux命令有哪些" class="headerlink" title="工作中常使用的Linux命令有哪些?"></a>工作中常使用的Linux命令有哪些?</h3><p>答：文件操作(ls,cd,cp,mv,rm,touch)、查看文件(cat,more,less,tail,head)、权限管理(chmod,chown,chgrp)、用户管理(useradd,userdel,passwd)、进程管理(ps,kill,top)、网络(ping,netstat,ss,curl)、文本处理(grep,sed,awk)、压缩(tar,zip,gzip)等。</p>
<h3 id="查看CPU、内存、磁盘、进程的Linux命令有哪些"><a href="#查看CPU、内存、磁盘、进程的Linux命令有哪些" class="headerlink" title="查看CPU、内存、磁盘、进程的Linux命令有哪些?"></a>查看CPU、内存、磁盘、进程的Linux命令有哪些?</h3><p>答：</p>
<ul>
<li>CPU：top、htop、lscpu、cat &#x2F;proc&#x2F;cpuinfo</li>
<li>内存：free -h、top、cat &#x2F;proc&#x2F;meminfo</li>
<li>磁盘：df -h、du -sh、fdisk -l、lsblk</li>
<li>进程：ps aux、top、pgrep、pidof</li>
</ul>
<h3 id="LVM扩展根分区的过程"><a href="#LVM扩展根分区的过程" class="headerlink" title="LVM扩展根分区的过程?"></a>LVM扩展根分区的过程?</h3><p>答：1.创建新的物理卷(pvcreate) → 2.扩展卷组(vgextend) → 3.扩展逻辑卷(lvextend) → 4.扩展文件系统(resize2fs或xfs_growfs)。需要提前准备新的磁盘或分区。</p>
<h3 id="如何查找7天前修改的文件"><a href="#如何查找7天前修改的文件" class="headerlink" title="如何查找7天前修改的文件?"></a>如何查找7天前修改的文件?</h3><p>答：<code>find / -type f -mtime +7</code>(精确7天前)，或<code>find / -type f -mtime 7</code>(7*24小时前)，或<code>find / -type f -mdays +7</code>。</p>
<h3 id="如何查找文件大小大于10M小于100M的文件"><a href="#如何查找文件大小大于10M小于100M的文件" class="headerlink" title="如何查找文件大小大于10M小于100M的文件?"></a>如何查找文件大小大于10M小于100M的文件?</h3><p>答：<code>find / -type f -size +10M -size -100M</code></p>
<h3 id="如何查找属于某个用户的文件，并复制到-tmp"><a href="#如何查找属于某个用户的文件，并复制到-tmp" class="headerlink" title="如何查找属于某个用户的文件，并复制到&#x2F;tmp?"></a>如何查找属于某个用户的文件，并复制到&#x2F;tmp?</h3><p>答：<code>find / -user username -exec cp {} /tmp/ \;</code> 或 <code>find / -user username | xargs -I {} cp {} /tmp/</code></p>
<h3 id="工作中配置过哪些Linux系统优化"><a href="#工作中配置过哪些Linux系统优化" class="headerlink" title="工作中配置过哪些Linux系统优化?"></a>工作中配置过哪些Linux系统优化?</h3><p>答：</p>
<ul>
<li>内核参数优化(sysctl)：增加文件描述符、TCP连接数、调整TCP参数</li>
<li>网络优化：调整网卡队列长度、启用GSO&#x2F;GRO</li>
<li>磁盘I&#x2F;O优化：调整I&#x2F;O调度器、readahead</li>
<li>内存优化：swap配置、cache管理</li>
<li>场景：高并发Web服务器、数据库服务器、消息队列等</li>
</ul>
<h2 id="Shell脚本类"><a href="#Shell脚本类" class="headerlink" title="Shell脚本类"></a>Shell脚本类</h2><h3 id="代表什么意思"><a href="#代表什么意思" class="headerlink" title="$?代表什么意思?"></a>$?代表什么意思?</h3><p>答：上一条命令的执行结果，0表示成功，非0表示失败。</p>
<h3 id="和-1-N代表什么意思"><a href="#和-1-N代表什么意思" class="headerlink" title="$@和$1..$N代表什么意思?"></a>$@和$1..$N代表什么意思?</h3><p>答：$@表示所有参数(保留参数间的空格)，$1表示第1个参数，$2第2个，以此类推。$0是脚本名本身。</p>
<h3 id="shell中如何获取字符串的长度"><a href="#shell中如何获取字符串的长度" class="headerlink" title="shell中如何获取字符串的长度?"></a>shell中如何获取字符串的长度?</h3><p>答：<code>${#str}</code>，例如str&#x3D;”hello”，${#str}&#x3D;5</p>
<h3 id="如何截取一段字符串"><a href="#如何截取一段字符串" class="headerlink" title="如何截取一段字符串?"></a>如何截取一段字符串?</h3><p>答：<code>${str:start:length}</code>，例如${str:0:3}从第0位截取3个字符。${str:2}从第2位到末尾。</p>
<h3 id="shell中都有用过哪些循环"><a href="#shell中都有用过哪些循环" class="headerlink" title="shell中都有用过哪些循环?"></a>shell中都有用过哪些循环?</h3><p>答：</p>
<ul>
<li>for循环：<code>for i in list; do ... done</code></li>
<li>while循环：<code>while condition; do ... done</code></li>
<li>until循环：<code>until condition; do ... done</code></li>
<li>case循环：<code>case $var in pattern) ... ;; esac</code></li>
</ul>
<h3 id="shell中什么是函数"><a href="#shell中什么是函数" class="headerlink" title="shell中什么是函数?"></a>shell中什么是函数?</h3><p>答：函数是可重复使用的代码块。定义语法：<code>function func_name() { ... }</code> 或 <code>func_name() { ... }</code></p>
<h3 id="shell脚本的参数如何传递到函数里面"><a href="#shell脚本的参数如何传递到函数里面" class="headerlink" title="shell脚本的参数如何传递到函数里面?"></a>shell脚本的参数如何传递到函数里面?</h3><p>答：直接在函数调用时传参：<code>func_name arg1 arg2</code>，在函数内通过$1、$2访问，$@表示所有参数。</p>
<h3 id="shell中如何并发执行代码块"><a href="#shell中如何并发执行代码块" class="headerlink" title="shell中如何并发执行代码块?"></a>shell中如何并发执行代码块?</h3><p>答：使用&amp;符号后台运行，例如：<code>(command1) &amp; (command2) &amp; wait</code></p>
<h2 id="网络类-1"><a href="#网络类-1" class="headerlink" title="网络类"></a>网络类</h2><h3 id="TCP和UDP协议区别"><a href="#TCP和UDP协议区别" class="headerlink" title="TCP和UDP协议区别?"></a>TCP和UDP协议区别?</h3><p>答：TCP面向连接、有序、可靠、有流量控制；UDP无连接、无序、不可靠、低延迟。TCP用于邮件、Web，UDP用于视频、DNS、游戏。</p>
<h3 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型?"></a>OSI七层网络模型?</h3><p>答：应用层(HTTP&#x2F;HTTPS)、表示层(加密&#x2F;压缩)、会话层(建立&#x2F;维护连接)、传输层(TCP&#x2F;UDP)、网络层(IP)、数据链路层(MAC)、物理层(网线)。</p>
<h3 id="TCP的三次握手和四次挥手过程"><a href="#TCP的三次握手和四次挥手过程" class="headerlink" title="TCP的三次握手和四次挥手过程?"></a>TCP的三次握手和四次挥手过程?</h3><p>答：</p>
<ul>
<li>三次握手：1.客户端SYN → 2.服务端SYN+ACK → 3.客户端ACK，连接建立</li>
<li>四次挥手：1.客户端FIN → 2.服务端ACK → 3.服务端FIN → 4.客户端ACK，连接关闭</li>
</ul>
<h3 id="在浏览器中输入网站按下回车键背后发生什么"><a href="#在浏览器中输入网站按下回车键背后发生什么" class="headerlink" title="在浏览器中输入网站按下回车键背后发生什么?"></a>在浏览器中输入网站按下回车键背后发生什么?</h3><p>答：1.DNS解析域名 → 2.三次握手建立连接 → 3.发送HTTP请求 → 4.服务器返回响应 → 5.浏览器解析HTML&#x2F;CSS&#x2F;JS → 6.渲染页面 → 7.四次挥手关闭连接。</p>
<h2 id="虚拟化技术类-1"><a href="#虚拟化技术类-1" class="headerlink" title="虚拟化技术类"></a>虚拟化技术类</h2><h3 id="怎么理解容器和虚拟化"><a href="#怎么理解容器和虚拟化" class="headerlink" title="怎么理解容器和虚拟化?"></a>怎么理解容器和虚拟化?</h3><p>答：虚拟化是通过Hypervisor虚拟硬件，每个VM有独立的OS；容器是轻量级虚拟化，共享宿主机OS内核，启动快，资源占用少。</p>
<h3 id="Docker-run常见参数"><a href="#Docker-run常见参数" class="headerlink" title="Docker run常见参数?"></a>Docker run常见参数?</h3><p>答：</p>
<ul>
<li><code>-d</code>后台运行</li>
<li><code>-p 8080:80</code>端口映射 -P随机端口</li>
<li><code>-v /host:/container</code>挂载卷</li>
<li><code>-e VAR=value</code>环境变量</li>
<li><code>--name</code>容器名称</li>
<li><code>--restart=always</code>自动重启</li>
<li><code>-m 512m</code>内存限制</li>
<li><code>-c 1024</code>CPU限制</li>
</ul>
<h3 id="Dockerfile关键字"><a href="#Dockerfile关键字" class="headerlink" title="Dockerfile关键字?"></a>Dockerfile关键字?</h3><p>答：FROM(基础镜像)、RUN(执行命令)、COPY&#x2F;ADD(复制文件)、EXPOSE(暴露端口)、ENV(环境变量)、WORKDIR(工作目录)、CMD(默认启动命令)、ENTRYPOINT(入口点)、VOLUME(挂载点)。</p>
<h3 id="COPY和ADD的区别"><a href="#COPY和ADD的区别" class="headerlink" title="COPY和ADD的区别?"></a>COPY和ADD的区别?</h3><p>答：COPY只复制文件，ADD可以复制文件、解压tar、支持URL。一般优先使用COPY。</p>
<h3 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别?"></a>CMD和ENTRYPOINT的区别?</h3><p>答：CMD是默认执行的命令，可被docker run参数覆盖；ENTRYPOINT是容器启动时的入口点，CMD作为参数传给ENTRYPOINT。</p>
<h2 id="中间件类-1"><a href="#中间件类-1" class="headerlink" title="中间件类"></a>中间件类</h2><p>Nginx和Tomcat的区别，核心地位和工作模式。</p>
<p>nginx并发能力高，tomcat每个请求分配一个工作进程，遇到比较复杂消耗cpu性能大</p>
<p>nginx异步非阻塞，tomcat多线程同步阻塞</p>
<p>配置文件</p>
<h3 id="解释反向代理和正向代理"><a href="#解释反向代理和正向代理" class="headerlink" title="解释反向代理和正向代理?"></a>解释反向代理和正向代理?</h3><p>答：正向代理代理客户端，隐藏客户端真实IP(VPN)；反向代理代理服务器，隐藏服务器IP，用于负载均衡、安全等。</p>
<h3 id="Mysql数据库如何优化"><a href="#Mysql数据库如何优化" class="headerlink" title="Mysql数据库如何优化?"></a>Mysql数据库如何优化?</h3><p>答：建立索引、使用JOIN优化、避免全表扫描、合理分区、开启缓存、使用连接池、定期maintenance、SQL语句优化、调整my.cnf参数。</p>
<h3 id="Nginx如何优化"><a href="#Nginx如何优化" class="headerlink" title="Nginx如何优化?"></a>Nginx如何优化?</h3><p>答：启用Gzip压缩、调整Worker进程数、优化内存缓存、使用CDN、启用HTTP&#x2F;2、调整keepalive_timeout、合理配置缓存策略。</p>
<h3 id="Mysql内连接、左连接、右连接是什么意思"><a href="#Mysql内连接、左连接、右连接是什么意思" class="headerlink" title="Mysql内连接、左连接、右连接是什么意思?"></a>Mysql内连接、左连接、右连接是什么意思?</h3><p>答：</p>
<ul>
<li>内连接：返回两表都匹配的数据</li>
<li>左连接：返回左表所有数据，右表无匹配则为NULL</li>
<li>右连接：返回右表所有数据，左表无匹配则为NULL</li>
</ul>
<h3 id="一条完整内连接查询语句"><a href="#一条完整内连接查询语句" class="headerlink" title="一条完整内连接查询语句?"></a>一条完整内连接查询语句?</h3><p>答：<code>SELECT a.id, a.name, b.salary FROM table_a a INNER JOIN table_b b ON a.id = b.user_id WHERE a.status=1 ORDER BY a.id LIMIT 10;</code></p>
<h3 id="Mysql主从复制原理"><a href="#Mysql主从复制原理" class="headerlink" title="Mysql主从复制原理?"></a>Mysql主从复制原理?</h3><p>答：Master生成Binlog → Slave通过I&#x2F;O线程读取Binlog → 写入Relay Log → SQL线程读取Relay Log执行 → 实现数据同步。</p>
<h3 id="ES的倒排索引是怎么做的"><a href="#ES的倒排索引是怎么做的" class="headerlink" title="ES的倒排索引是怎么做的?"></a>ES的倒排索引是怎么做的?</h3><p>答：将文档分词 → 建立词-&gt;文档ID的映射关系。查询时直接查询词映射，快速定位文档，比正排索引快得多。</p>
<h3 id="ES的分片有什么作用"><a href="#ES的分片有什么作用" class="headerlink" title="ES的分片有什么作用?"></a>ES的分片有什么作用?</h3><p>答：分散数据到多个节点，提高查询并发性和速度；支持水平扩展，单个分片大小可控。</p>
<h3 id="ES的副本有什么作用"><a href="#ES的副本有什么作用" class="headerlink" title="ES的副本有什么作用?"></a>ES的副本有什么作用?</h3><p>答：提高数据可用性和容错能力，当节点故障时副本保证数据不丢失；同时提高查询效率(可以从副本查询)。</p>
<h3 id="ES中索引和文档的理解"><a href="#ES中索引和文档的理解" class="headerlink" title="ES中索引和文档的理解?"></a>ES中索引和文档的理解?</h3><p>答：索引是文档的集合，类似数据库中的表；文档是最小的数据单位，是JSON格式，类似数据库中的行。</p>
<h3 id="Prometheus的架构"><a href="#Prometheus的架构" class="headerlink" title="Prometheus的架构?"></a>Prometheus的架构?</h3><p>答：数据流向：Exporter采集指标 → Prometheus Server定时拉取 → 存储时间序列数据 → AlertManager告警 → Grafana可视化。</p>
<h3 id="Nginx负载均衡算法有哪些"><a href="#Nginx负载均衡算法有哪些" class="headerlink" title="Nginx负载均衡算法有哪些?"></a>Nginx负载均衡算法有哪些?</h3><p>答：轮询(round_robin)、加权轮询(weight)、IP哈希(ip_hash)、最少连接(least_conn)、URL哈希(hash)、随机(random)。</p>
<h3 id="Nginx的状态码有哪些"><a href="#Nginx的状态码有哪些" class="headerlink" title="Nginx的状态码有哪些?"></a>Nginx的状态码有哪些?</h3><p>答：2xx成功(200,201,204)、3xx重定向(301,302,304)、4xx客户端错误(400,403,404)、5xx服务器错误(500,502,503)。</p>
<h3 id="Redis持久化方式有哪些"><a href="#Redis持久化方式有哪些" class="headerlink" title="Redis持久化方式有哪些?"></a>Redis持久化方式有哪些?</h3><p>答：</p>
<ul>
<li>RDB：定期生成快照，恢复快但可能丢数据</li>
<li>AOF：记录每条命令，数据安全但文件大，恢复慢</li>
<li>混合模式：结合两者优势</li>
</ul>
<h3 id="Mysql有哪些高可用解决方案"><a href="#Mysql有哪些高可用解决方案" class="headerlink" title="Mysql有哪些高可用解决方案?"></a>Mysql有哪些高可用解决方案?</h3><p>答：主从复制、MHA、Galera Cluster、MySQL Group Replication、中间件(MyCat、Atlas)。</p>
<h3 id="Redis高可用解决方案有哪些"><a href="#Redis高可用解决方案有哪些" class="headerlink" title="Redis高可用解决方案有哪些?"></a>Redis高可用解决方案有哪些?</h3><p>答：主从+Sentinel(自动故障转移)、Redis Cluster(分布式存储)。</p>
<h3 id="MYSQL增删改查关键字和表操作"><a href="#MYSQL增删改查关键字和表操作" class="headerlink" title="MYSQL增删改查关键字和表操作?"></a>MYSQL增删改查关键字和表操作?</h3><p>答：</p>
<ul>
<li>SELECT查询、INSERT插入、UPDATE更新、DELETE删除</li>
<li>表操作：CREATE TABLE创建、ALTER TABLE修改、DROP TABLE删除、TRUNCATE清空</li>
</ul>
<h3 id="Redis哨兵模式和集群模式有什么区别"><a href="#Redis哨兵模式和集群模式有什么区别" class="headerlink" title="Redis哨兵模式和集群模式有什么区别?"></a>Redis哨兵模式和集群模式有什么区别?</h3><p>答：哨兵是主从+自动故障转移，单个Master存储有限，集群模式多Master分片存储，支持真正的水平扩展。</p>
<h3 id="EFK-ELK的架构细节"><a href="#EFK-ELK的架构细节" class="headerlink" title="EFK&#x2F;ELK的架构细节?"></a>EFK&#x2F;ELK的架构细节?</h3><p>答：Elasticsearch存储 ← Logstash&#x2F;Filebeat收集并转换日志 ← 应用日志。Kibana可视化展示。EFK用Filebeat代替Logstash(更轻量)。</p>
<h3 id="ES的常见使用场景"><a href="#ES的常见使用场景" class="headerlink" title="ES的常见使用场景?"></a>ES的常见使用场景?</h3><p>答：日志分析、全文搜索、实时数据分析、应用性能监控(APM)、安全告警。</p>
<h2 id="Kubernetes类"><a href="#Kubernetes类" class="headerlink" title="Kubernetes类"></a>Kubernetes类</h2><h3 id="K8S控制面和工作面的组件"><a href="#K8S控制面和工作面的组件" class="headerlink" title="K8S控制面和工作面的组件?"></a>K8S控制面和工作面的组件?</h3><p>答：</p>
<ul>
<li>控制面：ApiServer(API接口)、Scheduler(调度)、ControllerManager(控制器)、Etcd(数据存储)</li>
<li>工作面：Kubelet(节点代理)、Kube-proxy(网络代理)、Container Runtime(容器运行时)</li>
</ul>
<h3 id="kubectl-run-mypod-image-nginx-latest-port-80后发生什么"><a href="#kubectl-run-mypod-image-nginx-latest-port-80后发生什么" class="headerlink" title="kubectl run mypod -image nginx:latest -port 80后发生什么?"></a>kubectl run mypod -image nginx:latest -port 80后发生什么?</h3><p>答：1.ApiServer验证请求 → 2.Scheduler选择节点 → 3.Kubelet拉取镜像 → 4.创建容器 → 5.配置网络 → 6.Pod运行。</p>
<h3 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期?"></a>Pod生命周期?</h3><p>答：Pending → ContainerCreating → Running → Succeeded&#x2F;Failed&#x2F;Unknown。中间经历initContainer、postStart、preStop等hook。</p>
<h3 id="Pod启动失败的原因"><a href="#Pod启动失败的原因" class="headerlink" title="Pod启动失败的原因?"></a>Pod启动失败的原因?</h3><p>答：镜像不存在&#x2F;拉取失败、资源不足、存储卷挂载失败、权限问题、健康检查失败、配置错误。</p>
<h3 id="Pod网络、Svc网络、节点网络流向"><a href="#Pod网络、Svc网络、节点网络流向" class="headerlink" title="Pod网络、Svc网络、节点网络流向?"></a>Pod网络、Svc网络、节点网络流向?</h3><p>答：Pod流量 → Pod网络(Calico&#x2F;Flannel) → Svc(ClusterIP通过kube-proxy转发) → 后端Pod或节点外通过NodePort。</p>
<h3 id="Calico网络和Flannel网络区别"><a href="#Calico网络和Flannel网络区别" class="headerlink" title="Calico网络和Flannel网络区别?"></a>Calico网络和Flannel网络区别?</h3><p>答：Flannel只提供基础网络，Calico支持网络策略(NetworkPolicy)、BGP路由、更灵活的网络控制，安全性更高。</p>
<h2 id="DevOps类-1"><a href="#DevOps类-1" class="headerlink" title="DevOps类"></a>DevOps类</h2><h3 id="怎么理解DevOps、CI-CD、Jenkins"><a href="#怎么理解DevOps、CI-CD、Jenkins" class="headerlink" title="怎么理解DevOps、CI&#x2F;CD、Jenkins?"></a>怎么理解DevOps、CI&#x2F;CD、Jenkins?</h3><p>答：DevOps是开发和运维的协作文化。CI是持续集成(频繁合并代码)，CD是持续部署(自动发布)。Jenkins是自动化流程编排工具。</p>
<h3 id="具体说说CI和CD的理解"><a href="#具体说说CI和CD的理解" class="headerlink" title="具体说说CI和CD的理解?"></a>具体说说CI和CD的理解?</h3><p>答：CI：代码提交自动触发编译、测试、代码扫描。CD：自动化部署到开发、测试、生产环境，实现快速、频繁、可靠的发布。</p>
<h3 id="详细说配置Pipeline的过程"><a href="#详细说配置Pipeline的过程" class="headerlink" title="详细说配置Pipeline的过程?"></a>详细说配置Pipeline的过程?</h3><p>答：1.代码推送触发webhook → 2.Jenkins拉取代码 → 3.编译构建 → 4.单元测试 → 5.代码质量扫描 → 6.打包镜像 → 7.推送仓库 → 8.发布到K8S&#x2F;物理机。</p>
<h3 id="Jenkins配置Gitlab自动触发编译"><a href="#Jenkins配置Gitlab自动触发编译" class="headerlink" title="Jenkins配置Gitlab自动触发编译?"></a>Jenkins配置Gitlab自动触发编译?</h3><p>答：1.Gitlab生成Access Token → 2.Jenkins配置Gitlab连接 → 3.项目配置webhook → 4.Webhook指向Jenkins URL(<a target="_blank" rel="noopener" href="http://jenkins-ip:8080/project/xxx">http://jenkins-ip:8080/project/xxx</a>) → 5.代码提交自动触发Pipeline。</p>
<h3 id="Jenkins插件安装失败如何解决"><a href="#Jenkins插件安装失败如何解决" class="headerlink" title="Jenkins插件安装失败如何解决?"></a>Jenkins插件安装失败如何解决?</h3><p>答：1.检查网络和DNS → 2.更换插件源(国内源) → 3.手动上传.hpi文件 → 4.检查插件依赖版本 → 5.升级Jenkins版本 → 6.查看日志定位具体错误。</p>
<h2 id="综合类-1"><a href="#综合类-1" class="headerlink" title="综合类"></a>综合类</h2><h3 id="K8S中使用Ingress暴露的应用不能访问如何排查"><a href="#K8S中使用Ingress暴露的应用不能访问如何排查" class="headerlink" title="K8S中使用Ingress暴露的应用不能访问如何排查?"></a>K8S中使用Ingress暴露的应用不能访问如何排查?</h3><p>答：1.检查Ingress是否创建成功(kubectl get ingress) → 2.检查后端Service&#x2F;Pod是否健康 → 3.检查Ingress Controller是否运行 → 4.检查DNS解析 → 5.查看Ingress日志和事件 → 6.检查网络策略是否限制。</p>
<h3 id="若依项目微服务数据流向"><a href="#若依项目微服务数据流向" class="headerlink" title="若依项目微服务数据流向?"></a>若依项目微服务数据流向?</h3><p>答：前端请求 → API网关(路由转发) → 各微服务(认证、授权、业务处理) → 调用其他服务或数据库 → 返回结果 → 前端展示。涉及服务发现、负载均衡、熔断降级。</p>
<h3 id="服务不能访问如何排查"><a href="#服务不能访问如何排查" class="headerlink" title="服务不能访问如何排查?"></a>服务不能访问如何排查?</h3><p>答：1.ping网络是否联通 → 2.telnet端口是否开放 → 3.netstat查看服务是否监听 → 4.查看应用日志 → 5.检查防火墙规则 → 6.检查DNS解析 → 7.检查负载均衡&#x2F;网关配置。</p>
<p>考虑个别还是大部分人的问题 </p>
<p>个人:ping本地(网卡，网卡驱动) ping网关(网络，网线，ip配置问题) ping外网(DNS解析，路由，防火墙)</p>
<p>大部分:报错码，能不能访问网络，浏览器缓存，网络链路，客户端到服务器IP Ping 抓包，防火墙策略，安全组</p>
<p>服务端，服务状态，负载，端口监听，日志（journelctl tail -f），nginx配置，证书配置，I&#x2F;O日志</p>
<h3 id="若依项目后端和前端技术栈及前后端对接"><a href="#若依项目后端和前端技术栈及前后端对接" class="headerlink" title="若依项目后端和前端技术栈及前后端对接?"></a>若依项目后端和前端技术栈及前后端对接?</h3><p>答：</p>
<ul>
<li>后端：Java、Spring Boot、Spring Cloud、Mybatis、MySQL、Redis</li>
<li>前端：Vue.js、Element UI、Webpack</li>
<li>对接：前端调用后端Restful API，通过HTTP&#x2F;HTTPS通信，JSON格式数据交互，前后端分离架构。</li>
</ul>
<h3 id="阿里云产品使用情况"><a href="#阿里云产品使用情况" class="headerlink" title="阿里云产品使用情况?"></a>阿里云产品使用情况?</h3><p>答：ECS(云服务器)、RDS(数据库)、OSS(对象存储)、SLB(负载均衡)、VPC(虚拟网络)、CDN(内容分发)、ACR(容器镜像仓库)、等等。各产品解决云上基础设施问题。</p>
<h3 id="什么是脑裂"><a href="#什么是脑裂" class="headerlink" title="什么是脑裂?"></a>什么是脑裂?</h3><p>答：分布式系统中，多个节点无法通信导致各自选出Leader，形成多个集群。</p>
<p>比如Keepalived中每个集群都有个master(VIP)<br>数据丢失，为什么要奇数节点，3 4个节点容错差不多浪费资源</p>
<h3 id="RAFT算法如何避免脑裂"><a href="#RAFT算法如何避免脑裂" class="headerlink" title="RAFT算法如何避免脑裂?"></a>RAFT算法如何避免脑裂?</h3><p>答：1.Leader定期发送<strong>心跳</strong>保持权威 → 2.Follower<strong>选举</strong>超时后发起新一轮选举 → 3.要求新Leader获得多数票(&gt;N&#x2F;2) → 4.Term机制防止旧Leader继续统治。</p>
<h3 id="运维工程师的一天主要做什么"><a href="#运维工程师的一天主要做什么" class="headerlink" title="运维工程师的一天主要做什么?"></a>运维工程师的一天主要做什么?</h3><p>答：1.早上检查系统健康状况(监控告警) → 2.处理故障和问题 → 3.代码发布和部署 → 4.系统优化和性能调优 → 5.容量规划和扩容 → 6.文档和知识库维护 → 7.值班和应急响应。</p>
<h2 id="微服务类-1"><a href="#微服务类-1" class="headerlink" title="微服务类"></a>微服务类</h2><h3 id="若依微服务项目中使用的技术及作用"><a href="#若依微服务项目中使用的技术及作用" class="headerlink" title="若依微服务项目中使用的技术及作用?"></a>若依微服务项目中使用的技术及作用?</h3><p>答：</p>
<ul>
<li>Spring Cloud：服务注册与发现(Nacos&#x2F;Eureka)、服务调用(OpenFeign&#x2F;Ribbon)、网关(Gateway)</li>
<li>Hystrix：熔断、降级、限流</li>
<li>Sentinel：流量控制和熔断</li>
<li>Seata：分布式事务</li>
<li>Docker+K8S：容器化部署和编排</li>
<li>MQ(RabbitMQ&#x2F;Kafka)：异步通信、解耦</li>
<li>ELK：日志聚合分析</li>
<li>Prometheus+Grafana：监控告警</li>
</ul>
<h3 id="微服务中什么是熔断"><a href="#微服务中什么是熔断" class="headerlink" title="微服务中什么是熔断?"></a>微服务中什么是熔断?</h3><p>答：服务故障或请求失败率过高时，暂停调用该服务，返回降级结果，避免故障扩散。一段时间后自动恢复。</p>
<h3 id="什么是限流"><a href="#什么是限流" class="headerlink" title="什么是限流?"></a>什么是限流?</h3><p>答：限制在单位时间内的请求数量，保护系统不被突发流量压垮。算法有令牌桶、漏桶、计数器等。</p>
<h3 id="什么是流量管控"><a href="#什么是流量管控" class="headerlink" title="什么是流量管控?"></a>什么是流量管控?</h3><p>答：通过权重分配、超时控制、重试策略、优先级划分等手段，管理和调度流量，实现高可用和资源高效利用。</p>
<p>工作过程中遇到的难题：</p>
<p>磁盘100%</p>
<p>OOMKILL</p>
<h1 id="B简历-整合"><a href="#B简历-整合" class="headerlink" title="B简历-整合"></a>B简历-整合</h1><p><strong>BOSS的自我介绍</strong></p>
<ol>
<li></li>
</ol>
<p>您好，我对贵公司有意向，希望能够向贵公司投递简历，本人具备运维工作经验，掌握技能：k8s，CI&#x2F;CD，云平台的使用等，25年全日制本科毕业，政治面貌为正式党员，我看到贵公司的技术栈与我的契合，能否沟通了解下。</p>
<ol start="2">
<li></li>
</ol>
<p>HR您好，我有1年的运维管理经验，熟悉Linux、操作系统、Docker、Kubernetes容器技术、Redis、Mysql数据库、Prometheus+Grafana系统监控、ELK日志平台、自动化运维及Nginx、keepalived、Jenkins、Gitlab等，看了贵公司的招聘信息，我认为可以胜任该岗位的职责，期待与您进一步交流。</p>
<ol start="3">
<li></li>
</ol>
<p>老师您好！我有一定的运维经验，熟悉kubernetes、docker、CI&#x2F;CD、nginx、mysql和redis数据库运维及故障排查，也了解阿里云架构迁移、云平台运维、可视化监控平台搭建。我对这个岗位非常有兴趣，方便沟通了解一下吗？</p>
<p><strong>离职原因</strong> 在省外，由于家里在无锡购置了房子，希望我在离家近一点的地方发展，所以离职回来求职发展。</p>
<p><strong>期望薪资</strong> 岗位介绍范围来（我期望是7k以上）</p>
<p>人在哪 （约面试）看距离来</p>
<h2 id="公司背景调研"><a href="#公司背景调研" class="headerlink" title="公司背景调研"></a>公司背景调研</h2><p><img src="/./imgs/image-20251224104315338.png" alt="image-20251224104315338"></p>
<p><img src="/./imgs/image-20251224105613388.png" alt="image-20251224105613388"></p>
<h2 id="一、自我介绍"><a href="#一、自我介绍" class="headerlink" title="一、自我介绍"></a>一、自我介绍</h2><p>面试官您好！我叫朱鑫烨，是在今年毕业于苏州工学院软件工程专业，学历为全日制本科，有一年的运维实习经历，目前处于离职状态，此次想要应聘贵公司运维工程师岗位。</p>
<p>技术上，我主要专注于Kubernetes和Docker的集群管理和应用这一块。像用 Kubernetes 来搭建和管理容器集群，服务容器化，实现HPA自动扩缩容和快速部署，这些我都有实际的项目经验。为了提升效率，我也对使用 Jenkins、GitLab 这些工具搭建一整套自动化的 CI&#x2F;CD 流程比较了解，让代码从提交到上线能自动完成，减少人工出错。<br>在保证系统高可用方面，我做过 Nginx 的负载均衡、配合 Keepalived 做高可用，也用过云上的负载均衡产品阿里的SLB&#x2F;ALB这些。数据库方面，我对 MySQL 的日常运维、主从搭建、性能调优都比较熟悉，也会用 Redis 来做缓存，给数据库减负，加快访问速度。<br>平时工作中，我习惯用 Prometheus 和 Grafana 这套来做监控，Alertmanager来监控告警，有什么问题能第一时间发现并处理，也搭建过 ELK 日志分析体系，能够实现系统健康监控与快速故障定位。<br>总的来说，我觉得自己有相应的动手能力，解决问题的思路也比较清晰。乐于学习新技术，也很有责任心，希望能在贵公司长期发展，把工作做好。以上是我的简要介绍，谢谢。</p>
<h3 id="二、最近项目介绍"><a href="#二、最近项目介绍" class="headerlink" title="二、最近项目介绍"></a>二、最近项目介绍</h3><p><strong>多少开发，多少人？</strong></p>
<p>我所在的运维团队大概有 5 人，我们的主要工作是配合研发团队，将公司的软件产品（像 HIS 系统、设备管理平台）<strong>部署到客户的服务器或云端</strong>，并负责后续的<strong>巡检和故障处理</strong>。</p>
<p><strong>如果问上家公司？（你在上家公司主要做什么？）</strong></p>
<p>公司是做<strong>行业解决方案交付</strong>的，所在的部门是<strong>技术服务&#x2F;运维部</strong>。<strong>为客户提供技术交付和驻场服务</strong>。</p>
<p><strong>快速谈谈（添加到自我介绍也行）：</strong></p>
<p>在上家公司，我参与了xxx（私立）医院的HIS 系统分布式平台建设项目（他们之前的系统比较老旧卡且容易崩），我主要负责 <strong>本地数据中心 K8s 集群的搭建与管理</strong> 以及 <strong>CI&#x2F;CD 自动化流水线的落地</strong>。 通过 <strong>Docker + K8s</strong> 对系统进行了容器化封装与编排，重点管理了 <strong>门诊挂号（高并发）、电子病历(EMR)、药房进销存、体检套餐管理</strong> 这些微服务模块的部署与运行。 </p>
<p>特别是在医院做‘周年庆’体检促销活动时，我负责通过 HPA 策略对挂号和支付模块进行弹性扩容，保障了系统在高并发下的稳定。</p>
<p>也参与过xxx公司的设备管理平台云原生改造，这是将传统的系统迁移到阿里云的项目，我负责将 <strong>设备状态采集、资产管理、维修工单</strong> 等模块迁移上云，并配置了 <strong>阿里云 SLB</strong> 进行流量分发 。也通过 <strong>ELK (Filebeat+Kafka)</strong> 搭建了日志收集链路 ，帮助开发快速定位设备掉线原因。在这个项目里，我积累了一些公有云的运维经验。</p>
<p>模块详解（挑着讲）：</p>
<h4 id="项目一：HIS系统分布式平台"><a href="#项目一：HIS系统分布式平台" class="headerlink" title="项目一：HIS系统分布式平台"></a><strong>项目一：HIS系统分布式平台</strong></h4><p><strong>1. VIP预约与挂号中心 (VIP Reservation &amp; Registration)</strong></p>
<ul>
<li><strong>业务功能</strong>：支持普通患者挂号，特别是<strong>高端VIP客户的专家预约</strong>、体检套餐的线上抢购。私立医院常有营销活动，这个模块并发压力最大。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>流量控制</strong>：我在 Nginx Ingress 层配置了<strong>限流策略（Rate Limiting）</strong>，防止黄牛或恶意脚本刷号导致系统崩溃。</li>
<li><strong>弹性伸缩</strong>：配置了 Kubernetes HPA（水平自动伸缩），设定当 Pod CPU 使用率超过 50% 时，副本数从 3 个自动扩容到 10 个，应对早间 8 点和活动期间的流量洪峰 。</li>
<li><strong>健康检查</strong>：配置了 Liveness 和 Readiness 探针，一旦某个挂号服务响应超时，K8s 会自动重启该 Pod，确保用户端不会刷出白屏。</li>
</ul>
</li>
</ul>
<p><strong>2. 电子病历模块 (EMR - Electronic Medical Record)</strong></p>
<ul>
<li><strong>业务功能</strong>：医生书写诊断、处方，确保护士和药房能实时看到。私立医院注重隐私，数据安全要求极高。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>存储与备份</strong>：该模块产生大量文本数据，挂载了 <strong>NFS 共享存储</strong> 。我编写了 Shell 脚本，每天凌晨 2 点对 EMR 数据库进行全量备份，并每小时进行 Binlog 增量备份，确保患者病历零丢失 。</li>
<li><strong>慢SQL排查</strong>：医生反映保存病历慢时，我会通过 <strong>Slow Query Log (慢查询日志)</strong> 分析，配合开发优化 SQL 语句，比如给患者 ID 字段加索引。</li>
</ul>
</li>
</ul>
<p><strong>3. 药房进销存与供应链 (Pharmacy &amp; SCM)</strong></p>
<ul>
<li><strong>业务功能</strong>：管理药品库存、耗材采购。私立医院对<strong>成本控制</strong>很严，库存数据的准确性直接影响财务报表。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>数据一致性保障</strong>：这个模块涉及扣减库存，强依赖数据库事务。我负责维护 <strong>MySQL 的主从复制</strong> 状态，通过监控 <code>Seconds_Behind_Master</code> 指标，确保主从延迟在毫秒级，防止药房发药时库存数据不一致 。</li>
<li><strong>分布式锁支持</strong>：协助开发维护 <strong>Redis 集群</strong>，利用 Redis 实现分布式锁，防止在高并发发药时出现“超卖”现象（即库存为 0 还能开出药） 。</li>
</ul>
</li>
</ul>
<p><strong>4. 支付与结算中心 (Payment &amp; Settlement)</strong></p>
<ul>
<li><strong>业务功能</strong>：处理自费支付、医保统筹结算、商保理赔。这是医院的“钱袋子”。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>高可用保障</strong>：这个服务是绝对的核心，我将其调度策略设置为 <code>PodAntiAffinity</code>（Pod反亲和性），强制让支付服务的 Pod 分散运行在不同的物理节点上，防止某台物理机宕机导致无法收费。</li>
<li><strong>日志审计</strong>：搭建了 <strong>ELK + Kafka</strong> 日志链路 ，专门收集支付模块的流水日志。当出现账目不平时，我能通过 Kibana 快速过滤出 <code>order_id</code>，把完整的支付报文拉出来给财务核对。</li>
</ul>
</li>
</ul>
<h4 id="项目二：设备管理平台（公有云-物联网场景）"><a href="#项目二：设备管理平台（公有云-物联网场景）" class="headerlink" title="项目二：设备管理平台（公有云&#x2F;物联网场景）"></a><strong>项目二：设备管理平台（公有云&#x2F;物联网场景）</strong></h4><p><strong>1. 设备状态采集模块 (Device Data Collection)</strong></p>
<ul>
<li><strong>业务功能</strong>：收集全院医疗设备（如呼吸机、监护仪）的实时运行数据，通常是高频写入。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>消息队列维护</strong>：设备上报的数据量很大，直接写库扛不住。我们用了 <strong>Kafka</strong> 做流量削峰。我负责监控 Kafka 的 <strong>Consumer Lag (消费堆积)</strong>，如果堆积严重，我会去阿里云控制台增加消费端 Pod 的数量。</li>
<li><strong>资源隔离</strong>：因为采集服务吃内存，我给这些 Pod 设置了严格的 <code>Requests</code> 和 <code>Limits</code> 资源限制，防止它把节点的内存吃光导致 OOM（内存溢出）影响其他服务 。</li>
</ul>
</li>
</ul>
<p><strong>2. 资产全生命周期管理 (Asset Lifecycle Mgmt)</strong></p>
<ul>
<li><strong>业务功能</strong>：记录设备的采购时间、维保到期日、折旧计算。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>数据库迁移</strong>：在这个项目的云原生改造中，我负责使用工具将本地的 SQL 文件迁移到阿里云 <strong>RDS (MySQL)</strong> 实例中，并配置了白名单，只允许 ACK 集群内的 Pod 访问数据库，保障资产数据安全 。</li>
</ul>
</li>
</ul>
<p><strong>3. 维修工单与巡检 (Maintenance &amp; Inspection)</strong></p>
<ul>
<li><strong>业务功能</strong>：设备报修、工程师接单、巡检打卡。</li>
<li><strong>你的运维职责（详细）</strong>：<ul>
<li><strong>日志分析</strong>：工程师反馈“上传巡检图片失败”，我通过 <strong>Kibana</strong> 查询 Nginx 入口日志，发现是 <code>client_max_body_size</code> 参数限制太小（默认 1M），导致图片上传报 413 错误。我修改 Nginx ConfigMap 配置后解决了这个问题 。</li>
</ul>
</li>
</ul>
<h2 id="三、项目详细介绍"><a href="#三、项目详细介绍" class="headerlink" title="三、项目详细介绍"></a>三、项目详细介绍</h2><p>这是一个非常扎实且必要的准备工作。既然要对标B简历那种细致程度，我们需要把你简历中**“HIS系统分布式平台建设项目”**完全拆解开来。</p>
<p>这个项目是基于私立医院场景，我们将QPS设定在<strong>100-200</strong>之间（这在医疗垂直业务中属于中高频，因为医疗业务逻辑复杂，事务性强，不单纯追求高并发），重点在于**高可用（HA）*<em>和*<em>数据一致性</em></em>。</p>
<p>以下是该项目的<strong>全方位拆解</strong>，请务必熟读，最好能背诵关键数据。</p>
<hr>
<h3 id="项目一：HIS系统分布式平台建设项目"><a href="#项目一：HIS系统分布式平台建设项目" class="headerlink" title="项目一：HIS系统分布式平台建设项目"></a>项目一：HIS系统分布式平台建设项目</h3><h4 id="1-项目背景与业务规模（数据化）"><a href="#1-项目背景与业务规模（数据化）" class="headerlink" title="1. 项目背景与业务规模（数据化）"></a>1. 项目背景与业务规模（数据化）</h4><p>面试时，先用数据把项目的体量立住，让面试官知道你维护的是一个真实的、有流量的系统。</p>
<ul>
<li><strong>医院性质</strong>：中大型私立综合医院（床位约 500-800 张）。</li>
<li><strong>日均门诊量</strong>：2,500 - 3,000 人次。</li>
<li><strong>注册用户数</strong>：约 20 万+（包含小程序端）。</li>
<li><strong>业务峰值 QPS</strong>：<strong>150 - 200 QPS</strong>（主要集中在早间 8:00-9:30 挂号与缴费高峰）。</li>
<li><strong>接口响应要求</strong>：核心业务（挂号、支付） &lt; 200ms，普通查询 &lt; 500ms。</li>
<li><strong>数据规模</strong>：MySQL 核心库总数据量约 300GB，日增量约 500MB（包含病历文本）。</li>
</ul>
<h4 id="2-整体硬件资源规划与配置（物理机-虚拟机）"><a href="#2-整体硬件资源规划与配置（物理机-虚拟机）" class="headerlink" title="2. 整体硬件资源规划与配置（物理机&#x2F;虚拟机）"></a>2. 整体硬件资源规划与配置（物理机&#x2F;虚拟机）</h4><p>参考B简历的表格形式，我们为你设计了一套符合私立医院私有云（本地数据中心）的资源清单。</p>
<p>架构策略：核心数据库用物理机保障IO，应用层用虚拟化&#x2F;容器化保障弹性。</p>
<table>
<thead>
<tr>
<th><strong>服务器角色</strong></th>
<th><strong>节点数量</strong></th>
<th><strong>配置 (CPU &#x2F; 内存 &#x2F; 磁盘)</strong></th>
<th><strong>部署组件&#x2F;用途</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>K8s Master</strong></td>
<td>3 台 (VM)</td>
<td>4核 &#x2F; 8GB &#x2F; 100G SSD</td>
<td>kube-apiserver, controller, etcd</td>
<td>3节点高可用，防止脑裂</td>
</tr>
<tr>
<td><strong>K8s Worker</strong></td>
<td>5 台 (VM)</td>
<td>8核 &#x2F; 16GB &#x2F; 200G SSD</td>
<td>承载所有微服务 Pod (约50-60个Pod)</td>
<td>预留资源做HPA扩容</td>
</tr>
<tr>
<td><strong>数据库主库</strong></td>
<td><strong>1 台 (物理机)</strong></td>
<td>16核 &#x2F; 32GB &#x2F; 1T NVMe SSD</td>
<td>MySQL (Master) - 核心写库</td>
<td>物理机保障高并发写入IO</td>
</tr>
<tr>
<td><strong>数据库从库</strong></td>
<td>2 台 (VM)</td>
<td>8核 &#x2F; 16GB &#x2F; 500G SSD</td>
<td>MySQL (Slave) - 读写分离&#x2F;备份</td>
<td>承担报表统计和查询流量</td>
</tr>
<tr>
<td><strong>缓存中间件</strong></td>
<td>3 台 (VM)</td>
<td>4核 &#x2F; 8GB &#x2F; 50G</td>
<td>Redis Sentinel (1主2从)</td>
<td>哨兵模式，Session共享&#x2F;缓存</td>
</tr>
<tr>
<td><strong>日志与监控</strong></td>
<td>2 台 (VM)</td>
<td>8核 &#x2F; 16GB &#x2F; 500G HDD</td>
<td>ELK Stack, Prometheus, Grafana</td>
<td>独立部署，避免占用业务资源</td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>2 台 (物理机)</td>
<td>4核 &#x2F; 8GB</td>
<td>Nginx + Keepalived</td>
<td>入口流量清洗，VIP漂移</td>
</tr>
<tr>
<td><strong>CI&#x2F;CD服务器</strong></td>
<td>1 台 (VM)</td>
<td>8核 &#x2F; 16GB &#x2F; 500G</td>
<td>GitLab, Jenkins, Harbor, Maven</td>
<td>运维管理节点</td>
</tr>
</tbody></table>
<p><strong>资源规划理由（面试话术）</strong>：</p>
<blockquote>
<p>“我们采用了计算与存储分离的策略。对于 K8s 集群，我们用 3 台 Master 保证控制平面的高可用；对于对 IO 要求极高的 MySQL 主库，我们特意申请了一台物理机，配合 NVMe SSD，防止在早高峰大量写入医嘱和挂号单时出现 IO 瓶颈。Worker 节点预留了约 30% 的资源，专门用于 HPA 自动扩缩容。”</p>
</blockquote>
<h4 id="3-Spring-Cloud-微服务模块拆解"><a href="#3-Spring-Cloud-微服务模块拆解" class="headerlink" title="3. Spring Cloud 微服务模块拆解"></a>3. Spring Cloud 微服务模块拆解</h4><p>这里需要把“HIS系统”拆成具体的服务，对应你简历中提到的 K8s Deployment。</p>
<p>总 Pod 数量：约 60 个（包含业务服务与 Sidecar）。</p>
<p>服务治理：Nacos（注册配置中心）+ Spring Cloud Gateway（网关）。</p>
<table>
<thead>
<tr>
<th><strong>微服务模块</strong></th>
<th><strong>Pod数量</strong></th>
<th><strong>功能描述与运维重点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>gateway-service</strong> (网关)</td>
<td>3</td>
<td><strong>统一入口</strong>：负责路由转发、鉴权过滤。配置了 Hystrix 熔断，防止后端服务挂掉拖垮整个系统。</td>
</tr>
<tr>
<td><strong>auth-service</strong> (认证中心)</td>
<td>2</td>
<td><strong>鉴权</strong>：负责发放 Token (JWT)。这是最基础的服务，必须多副本部署，一旦挂了全院都进不去系统。</td>
</tr>
<tr>
<td><strong>register-service</strong> (挂号)</td>
<td>3-6 (HPA)</td>
<td><strong>高并发点</strong>：处理预约挂号。配置了 HPA，当 CPU &gt; 60% 时自动扩容，应对早高峰抢号。</td>
</tr>
<tr>
<td><strong>outpatient-service</strong> (门诊)</td>
<td>3</td>
<td><strong>医生工作站</strong>：医生开医嘱、写病历。特点是长连接多，需要保证 Session 粘滞性或共享。</td>
</tr>
<tr>
<td><strong>pharmacy-service</strong> (药房)</td>
<td>2</td>
<td><strong>库存强一致</strong>：药品进销存。利用 Redis 分布式锁解决“超卖”问题，运维需监控 Redis 锁超时情况。</td>
</tr>
<tr>
<td><strong>payment-service</strong> (结算)</td>
<td>3</td>
<td><strong>资金安全</strong>：对接支付宝&#x2F;微信&#x2F;医保接口。日志级别设为 INFO，全量采集流水日志，用于对账。</td>
</tr>
<tr>
<td><strong>emr-service</strong> (电子病历)</td>
<td>2</td>
<td><strong>文档存储</strong>：负责病历的结构化存储。挂载了 NFS 共享存储，用于存放患者的 X光片缩略图或PDF。</td>
</tr>
<tr>
<td><strong>report-service</strong> (报表)</td>
<td>1</td>
<td><strong>低优先级</strong>：院长查询报表。限制了资源 Limit，防止报表的大量 SQL 查询把数据库内存吃光。</td>
</tr>
</tbody></table>
<h4 id="4-关键技术细节与运维动作-面试高频"><a href="#4-关键技术细节与运维动作-面试高频" class="headerlink" title="4. 关键技术细节与运维动作 (面试高频)"></a>4. 关键技术细节与运维动作 (面试高频)</h4><p>A. 流量入口的高可用 (Keepalived + Nginx) </p>
<ul>
<li><strong>架构</strong>：两台 Nginx 物理机安装 Keepalived，配置 VRRP 协议。</li>
<li><strong>VIP（虚拟IP）</strong>：绑定了一个内网 VIP (如 192.168.1.100)。</li>
<li><strong>工作原理</strong>：平时 VIP 在主节点。当主 Nginx 进程挂掉（通过脚本每 2 秒检测一次 <code>killall -0 nginx</code>），VIP 能够在一秒内漂移到备节点，用户端几乎无感知。</li>
</ul>
<p>B. 数据库架构 (MySQL 主从 + 读写分离) </p>
<ul>
<li><strong>配置</strong>：一主 (Master) 两从 (Slave)。</li>
<li><strong>读写分离</strong>：业务代码层面通过中间件（或 Sharding-JDBC）配置，写操作走主库，普通的查询（如查药品列表、查排班）走从库。</li>
<li><strong>备份策略</strong>：<ul>
<li><strong>全量备份</strong>：每天凌晨 3:00 使用 <code>mysqldump</code> 进行全库备份。</li>
<li><strong>增量备份</strong>：开启 Binlog，每小时切割一次日志并同步到备份服务器。</li>
<li><strong>数据安全</strong>：我们在运维脚本里写了校验逻辑，定期检查从库的 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 状态都是 <code>Yes</code>。</li>
</ul>
</li>
</ul>
<p>C. 监控告警体系 (Prometheus + Grafana + Alertmanager) </p>
<ul>
<li><strong>监控分层</strong>：<ul>
<li><strong>基础设施层</strong>：Node Exporter 监控 CPU、内存、磁盘 IO。</li>
<li><strong>K8s 组件层</strong>：cAdvisor 监控 Pod 的资源使用率。</li>
<li><strong>业务层</strong>：MySQL Exporter 监控慢查询数；Redis Exporter 监控缓存命中率。</li>
<li><strong>应用层</strong>：配合开发引入 Micrometer，监控 JVM 的堆内存 (Heap Memory) 和 GC 次数。</li>
</ul>
</li>
<li><strong>告警规则</strong>：<ul>
<li><strong>紧急</strong>：节点宕机、MySQL 连接数 &gt; 80%、核心服务 Pod 状态 !&#x3D; Running（电话&#x2F;钉钉通知）。</li>
<li><strong>一般</strong>：磁盘使用率 &gt; 85%（邮件通知）。</li>
</ul>
</li>
</ul>
<p>D. 日志处理 (ELK + Kafka) </p>
<ul>
<li><strong>痛点</strong>：早高峰时日志量大，直接写入 Elasticsearch 会导致 IO 阻塞。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>采集</strong>：Filebeat 以 Sidecar 模式运行在业务 Pod 里，采集 <code>/var/log/app/*.log</code>。</li>
<li><strong>缓冲</strong>：Filebeat 先把日志吐给 <strong>Kafka</strong> 消息队列（Topic: <code>his-logs</code>）。</li>
<li><strong>消费</strong>：Logstash 从 Kafka 慢慢消费日志，进行格式化（过滤敏感信息如身份证号）后写入 ES。</li>
<li><strong>展示</strong>：开发通过 Kibana 根据 <code>trace_id</code> 追踪全链路日志。</li>
</ul>
</li>
</ul>
<h4 id="5-项目中的具体挑战与解决-Storytelling"><a href="#5-项目中的具体挑战与解决-Storytelling" class="headerlink" title="5. 项目中的具体挑战与解决 (Storytelling)"></a>5. 项目中的具体挑战与解决 (Storytelling)</h4><ul>
<li><strong>问题</strong>：在系统上线初期，每天早上 8:30 挂号高峰期，<strong>注册服务 (register-service)</strong> 经常响应变慢，导致 Nginx 报 504 Gateway Timeout。</li>
<li><strong>排查</strong>：通过 Prometheus 监控发现，该服务的 Pod CPU 使用率瞬间飙升到 95%。</li>
<li><strong>解决</strong>：<ol>
<li><strong>临时</strong>：手动扩容副本数从 2 个到 5 个。</li>
<li><strong>永久</strong>：配置 <strong>HPA (Horizontal Pod Autoscaler)</strong>，设定阈值为 CPU 60%。</li>
<li><strong>根因</strong>：后续发现是开发代码中有一个循环查询数据库的操作，配合开发增加了 Redis 缓存，减少数据库压力。</li>
</ol>
</li>
</ul>
<hr>
<p>建议：</p>
<p>这一部分的内容量很大，建议你把**“硬件配置表格”和“微服务模块表格”打印出来或者抄写一遍。面试官问到“你们集群规模多大？”或者“有哪些微服务？”时，你不需要背诵所有数字，但要能脱口而出几个关键的**（比如：3主5从的K8s，核心挂号服务做了HPA，数据库是物理机）。这样显着你非常专业且实操过。</p>
<p>(如果你需要，我可以为你生成一张架构图的描述，辅助你理解这个拓扑结构)</p>
<p><strong>拓扑架构</strong>（可以自己画个图）</p>
<p>我们的架构从上到下分为三层。</p>
<p>最上面是<strong>接入层</strong>，我们用了两台物理机做 <strong>Nginx 加 Keepalived</strong>，通过一个 <strong>VIP</strong> 对外提供服务，保证入口的高可用，任何一台 Nginx 挂了，VIP 一秒内就能漂移。</p>
<p>中间是<strong>应用层</strong>，也就是我们的 <strong>Kubernetes 集群</strong>。有 3 台 Master 做高可用管控，5 台 Worker 跑业务。像我们的挂号服务、门诊服务都跑在 Pod 里。流量通过 K8s 的 Ingress 进来，分发到具体的 Service。</p>
<p>最下面是<strong>数据层</strong>，这是我重点维护的。为了保证 IO 性能，<strong>MySQL 的主库我是部署在高性能物理机上的</strong>，只负责写；另外有两台虚拟机做从库，负责读，实现了读写分离。所有的业务日志，我们会通过 Pod 里的 Filebeat 采集，先吐到 Kafka，再进 ELK，防止高峰期把磁盘写爆。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">【用户层】</span><br><span class="line">   (医生/护士/小程序)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">【接入层：流量入口】</span><br><span class="line">      [ VIP: 192.168.1.100 ] &lt;--- 虚拟IP漂移</span><br><span class="line">         │</span><br><span class="line">    +----+----+    (VRRP心跳)</span><br><span class="line">    |  Nginx  | &lt; - - - - - &gt; |  Nginx  |</span><br><span class="line">    | (Master)|               | (Backup)|</span><br><span class="line">    | 物理机1 |               | 物理机2 |</span><br><span class="line">    +----+----+               +---------+</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">【计算层：Kubernetes 集群】</span><br><span class="line">         │ Ingress (流量分发)</span><br><span class="line">         ▼</span><br><span class="line">   [ K8s Master x3 (VM) ] --- 控制平面 (API/Etcd)</span><br><span class="line">         │</span><br><span class="line">   +-----+---------------------------+</span><br><span class="line">   | K8s Worker Nodes x5 (VM)        |</span><br><span class="line">   |                                 |</span><br><span class="line">   |  [挂号 Pod]  [门诊 Pod]  [支付 Pod] | &lt;--- HPA自动扩缩容</span><br><span class="line">   |      │           │          │    |</span><br><span class="line">   |  (Filebeat)  (Filebeat) (Filebeat)| &lt;--- Sidecar日志采集</span><br><span class="line">   +------+-----------+----------+---+</span><br><span class="line">          │           │          │</span><br><span class="line">          │ (写)      │ (读)     │ (缓存)</span><br><span class="line">          ▼           ▼          ▼</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">【数据层：持久化存储】</span><br><span class="line">   +-----------+  +-------+  +-------+</span><br><span class="line">   | MySQL主库 |-&gt;| 从库1 |  | Redis |</span><br><span class="line">   | (物理机!) |  | (VM)  |  | 哨兵  |</span><br><span class="line">   | SSD高性能 |  |       |  | 集群  |</span><br><span class="line">   +-----------+  +-------+  +-------+【用户层】</span><br><span class="line">   (医生/护士/小程序)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">【接入层：流量入口】</span><br><span class="line">      [ VIP: 192.168.1.100 ] &lt;--- 虚拟IP漂移</span><br><span class="line">         │</span><br><span class="line">    +----+----+    (VRRP心跳)</span><br><span class="line">    |  Nginx  | &lt; - - - - - &gt; |  Nginx  |</span><br><span class="line">    | (Master)|               | (Backup)|</span><br><span class="line">    | 物理机1 |               | 物理机2 |</span><br><span class="line">    +----+----+               +---------+</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">【计算层：Kubernetes 集群】</span><br><span class="line">         │ Ingress (流量分发)</span><br><span class="line">         ▼</span><br><span class="line">   [ K8s Master x3 (VM) ] --- 控制平面 (API/Etcd)</span><br><span class="line">         │</span><br><span class="line">   +-----+---------------------------+</span><br><span class="line">   | K8s Worker Nodes x5 (VM)        |</span><br><span class="line">   |                                 |</span><br><span class="line">   |  [挂号 Pod]  [门诊 Pod]  [支付 Pod] | &lt;--- HPA自动扩缩容</span><br><span class="line">   |      │           │          │    |</span><br><span class="line">   |  (Filebeat)  (Filebeat) (Filebeat)| &lt;--- Sidecar日志采集</span><br><span class="line">   +------+-----------+----------+---+</span><br><span class="line">          │           │          │</span><br><span class="line">          │ (写)      │ (读)     │ (缓存)</span><br><span class="line">          ▼           ▼          ▼</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">【数据层：持久化存储】</span><br><span class="line">   +-----------+  +-------+  +-------+</span><br><span class="line">   | MySQL主库 |-&gt;| 从库1 |  | Redis |</span><br><span class="line">   | (物理机!) |  | (VM)  |  | 哨兵  |</span><br><span class="line">   | SSD高性能 |  |       |  | 集群  |</span><br><span class="line">   +-----------+  +-------+  +-------+</span><br></pre></td></tr></table></figure>

<p>这是一个非常好的策略。如果说上一个 HIS 项目展示了你对 <strong>“高可用、强一致性、私有化部署”</strong> 的掌控能力，那么这个设备管理平台项目就是用来展示你对 <strong>“公有云（阿里云）、高并发吞吐、云原生生态”</strong> 的理解。</p>
<p>面试官通常会认为：<strong>懂公有云运维的应届生，上手速度更快，且具备成本意识。</strong></p>
<p>以下是对 <strong>“设备管理平台云原生改造项目”</strong> 的详细拆解。请同样熟悉这些数据和细节。</p>
<hr>
<h3 id="项目二：设备管理平台云原生改造"><a href="#项目二：设备管理平台云原生改造" class="headerlink" title="项目二：设备管理平台云原生改造"></a>项目二：设备管理平台云原生改造</h3><h4 id="1-项目背景与业务规模（数据化）-1"><a href="#1-项目背景与业务规模（数据化）-1" class="headerlink" title="1. 项目背景与业务规模（数据化）"></a>1. 项目背景与业务规模（数据化）</h4><ul>
<li><strong>项目性质</strong>：将原本跑在几台老旧 ECS 虚拟机上的单体&#x2F;散乱应用，迁移到阿里云 ACK (容器服务) 上。</li>
<li><strong>管理设备量</strong>：约 <strong>5,000 - 8,000 台</strong> 在线设备（如医疗监护仪、呼吸机、温湿度传感器等）。</li>
<li><strong>数据上报频率</strong>：每 30 秒上报一次心跳和状态数据。</li>
<li><strong>吞吐量 (TPS)</strong>：日常写入 TPS 约 <strong>300-500</strong>，高峰期（如早晨设备统一开机自检）可达 <strong>1,000+</strong>。</li>
<li><strong>改造目标</strong>：解决旧系统在早高峰扩容慢的问题（虚拟机扩容要几分钟，K8s 只要几秒），并通过资源密度整合降低 30% 的 IT 成本。</li>
</ul>
<h4 id="2-云资源规划与配置（阿里云-ACK-环境）"><a href="#2-云资源规划与配置（阿里云-ACK-环境）" class="headerlink" title="2. 云资源规划与配置（阿里云 ACK 环境）"></a>2. 云资源规划与配置（阿里云 ACK 环境）</h4><p>与自建机房不同，这里我们强调**“云服务的选型”**。</p>
<table>
<thead>
<tr>
<th><strong>云资源组件</strong></th>
<th><strong>规格&#x2F;数量</strong></th>
<th><strong>配置细节&#x2F;选型理由</strong></th>
<th><strong>运维动作</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ACK 集群 (K8s)</strong></td>
<td><strong>托管版 (Managed)</strong></td>
<td><strong>Master</strong>：阿里云托管（我们不管理） <strong>Worker</strong>：3 台 ECS (8核16G) + 弹性节点</td>
<td>选用托管版是为了省去维护 Etcd 和 API Server 的精力，专注于 Worker 节点运维。</td>
</tr>
<tr>
<td><strong>ECS Node (节点)</strong></td>
<td>3 台 (固定) + N (弹性)</td>
<td><strong>实例类型</strong>：ecs.g6.2xlarge (通用型) <strong>操作系统</strong>：Alibaba Cloud Linux 3</td>
<td>开启了**“自动伸缩组”**，当集群资源不足时，自动购买新的 ECS 加入集群。</td>
</tr>
<tr>
<td><strong>RDS (数据库)</strong></td>
<td>1 套 (主备版)</td>
<td><strong>规格</strong>：MySQL 8.0 高可用版 (4核 8GB) <strong>存储</strong>：ESSD 云盘 PL1</td>
<td>使用阿里云 RDS 就不需要自己搭 MHA 了，自带主备切换和自动备份，省心。</td>
</tr>
<tr>
<td><strong>Redis (缓存)</strong></td>
<td>1 套 (集群版)</td>
<td><strong>规格</strong>：4GB &#x2F; 2分片</td>
<td>用于缓存设备最新的状态（在线&#x2F;离线），减少数据库查询压力。</td>
</tr>
<tr>
<td><strong>SLB (负载均衡)</strong></td>
<td>1 个 (CLB&#x2F;ALB)</td>
<td><strong>类型</strong>：公网 SLB <strong>带宽</strong>：按量付费 (峰值 50Mbps)</td>
<td>作为集群的统一入口，后端挂载 K8s 的 Ingress Controller。</td>
</tr>
<tr>
<td><strong>Kafka (消息队列)</strong></td>
<td>1 套 (云消息队列)</td>
<td><strong>规格</strong>：标准版</td>
<td><strong>关键组件</strong>：用于削峰填谷。设备数据先写 Kafka，再由消费者 Pod 慢慢写入数据库。</td>
</tr>
<tr>
<td><strong>NAT 网关</strong></td>
<td>1 个</td>
<td><strong>功能</strong>：SNAT</td>
<td>让内网的 Pod 能够访问公网（如下载 Docker 镜像、调用第三方接口）。</td>
</tr>
</tbody></table>
<h4 id="3-微服务模块拆解（IoT-场景）"><a href="#3-微服务模块拆解（IoT-场景）" class="headerlink" title="3. 微服务模块拆解（IoT 场景）"></a>3. 微服务模块拆解（IoT 场景）</h4><p>基于设备管理的业务逻辑，我们将服务拆解如下。</p>
<p>总 Pod 数量：约 40-50 个。</p>
<table>
<thead>
<tr>
<th><strong>微服务模块</strong></th>
<th><strong>Pod数量</strong></th>
<th><strong>功能描述与运维重点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>iot-gateway</strong> (设备网关)</td>
<td>3-6 (HPA)</td>
<td><strong>核心入口</strong>：负责接收设备发来的 MQTT&#x2F;HTTP 数据包。<strong>运维重点</strong>：这是流量第一站，配置了最灵敏的 HPA，CPU &gt; 50% 就扩容。</td>
</tr>
<tr>
<td><strong>device-manager</strong> (资产管理)</td>
<td>2</td>
<td><strong>CRUD业务</strong>：管理设备的型号、购买日期、维保信息。流量较平稳。</td>
</tr>
<tr>
<td><strong>data-parser</strong> (数据解析)</td>
<td>4 (HPA)</td>
<td><strong>计算密集型</strong>：消费 Kafka 里的原始报文，解析成 JSON 存入数据库。<strong>风险点</strong>：容易 OOM（内存溢出），限制了 Memory Limit 为 2GB。</td>
</tr>
<tr>
<td><strong>alert-center</strong> (告警中心)</td>
<td>2</td>
<td><strong>实时通知</strong>：如果设备数值异常（如温度过高），发短信&#x2F;邮件给管理员。</td>
</tr>
<tr>
<td><strong>job-scheduler</strong> (任务调度)</td>
<td>1</td>
<td><strong>定时任务</strong>：每天凌晨统计设备在线率报表。使用 K8s CronJob 实现。</td>
</tr>
<tr>
<td><strong>web-admin</strong> (管理后台)</td>
<td>2</td>
<td><strong>前端服务</strong>：给医院管理员用的 Web 界面，Nginx 容器化部署。</td>
</tr>
</tbody></table>
<h4 id="4-架构拓扑图描述（面试画图用）"><a href="#4-架构拓扑图描述（面试画图用）" class="headerlink" title="4. 架构拓扑图描述（面试画图用）"></a>4. 架构拓扑图描述（面试画图用）</h4><p>面试时描述这个架构的逻辑：</p>
<blockquote>
<p>“我们在阿里云上构建了一个典型的云原生架构。</p>
<p>最外层是 SLB (负载均衡)，流量进来后经过 Nginx Ingress 分发到 ACK 集群内部。</p>
<p>核心业务跑在 ACK 的 Worker 节点上。</p>
<p>为了应对物联网设备的高并发写入，我们引入了 Kafka 做缓冲层：设备数据 -&gt; iot-gateway -&gt; Kafka -&gt; data-parser -&gt; RDS。这是一个典型的**‘生产者-消费者’**模型，能有效防止数据库被打挂。</p>
<p>底层数据存储全部使用了阿里云的 PaaS 服务（RDS, Redis），实现了运维的轻量化。”</p>
</blockquote>
<h4 id="5-关键技术细节与运维亮点（针对简历内容）"><a href="#5-关键技术细节与运维亮点（针对简历内容）" class="headerlink" title="5. 关键技术细节与运维亮点（针对简历内容）"></a>5. 关键技术细节与运维亮点（针对简历内容）</h4><p>A. 弹性伸缩 (HPA + Cluster Autoscaler) </p>
<ul>
<li><strong>场景</strong>：每天早上 8:00 是医护人员交接班时间，大量设备同时开机上报状态，流量是平时的 5 倍。</li>
<li><strong>配置</strong>：<ul>
<li><strong>Pod 层面</strong>：配置 HPA，监控指标为 <code>cpu_utilization</code>。当 <code>iot-gateway</code> 的 CPU 使用率超过 50% 时，Pod 数量从 3 个自动涨到 10 个。</li>
<li><strong>节点层面</strong>：配置了 Cluster Autoscaler。如果 Pod 扩容太多，现有的 3 台 ECS 塞不下了，ACK 会自动购买一台新的按量付费 ECS 加入集群，高峰期过后再自动释放，<strong>帮公司省了钱</strong>。</li>
</ul>
</li>
</ul>
<p>B. 镜像仓库清理与 CI&#x2F;CD 优化 </p>
<ul>
<li><strong>痛点</strong>：由于开发迭代快，每天构建十几次，Harbor 仓库里堆积了大量无用的 Tag（如 <code>dev-v1.0.1</code>, <code>dev-v1.0.2</code>），导致磁盘爆满。</li>
<li><strong>解决</strong>：<ul>
<li>我修改了 Jenkinsfile，在构建流程的最后增加了一个 Shell 脚本阶段。</li>
<li>脚本逻辑：保留最近的 5 个版本镜像，使用 API 自动删除更早日期的开发版镜像。</li>
<li><strong>效果</strong>：将镜像仓库的存储占用率从 90% 长期稳定在 40% 左右。</li>
</ul>
</li>
</ul>
<p>C. 日志收集 (Filebeat + ELK) </p>
<ul>
<li><strong>架构</strong>：采用 <strong>Sidecar 模式</strong>。</li>
<li><strong>配置</strong>：在 <code>iot-gateway</code> 的 Pod 里不仅跑业务容器，还伴生一个 Filebeat 容器。</li>
<li><strong>细节</strong>：通过 <code>EmptyDir</code> 共享日志目录。Filebeat 抓取日志后发送到阿里云的 Elasticsearch。</li>
<li><strong>价值</strong>：开发人员以前查问题要 SSH 登服务器，现在直接在 Kibana 上搜设备 ID，效率提升了 10 倍。</li>
</ul>
<p><strong>D. 成本控制 (FinOps 意识)</strong></p>
<ul>
<li><p><strong>面试话术</strong>：</p>
<blockquote>
<p>“在阿里云上运维，我非常关注成本。比如测试环境的集群，我配置了定时开关机策略，晚上 8 点后自动缩容到最小副本数，或者对于非核心的数据解析服务，我们尝试使用了阿里云的 <strong>Spot Instances (抢占式实例)</strong>，成本只有按量付费的 1&#x2F;10。”</p>
</blockquote>
</li>
</ul>
<h4 id="6-可能的面试追问（针对此项目）"><a href="#6-可能的面试追问（针对此项目）" class="headerlink" title="6. 可能的面试追问（针对此项目）"></a>6. 可能的面试追问（针对此项目）</h4><ul>
<li><strong>Q: “你们数据库迁移上云是怎么做的？不停机吗？”</strong> <ul>
<li><strong>A:</strong> “我们使用了阿里云的 <strong>DTS (数据传输服务)</strong>。先进行全量数据同步，然后保持增量同步。在切换当晚，暂停业务写入口 5 分钟，确认主备数据一致后，修改 DNS 指向云上数据库，实现平滑迁移。”</li>
</ul>
</li>
<li><strong>Q: “如果设备上报数据量太大，Kafka 堆积了怎么办？”</strong><ul>
<li><strong>A:</strong> “我会监控 Kafka 的 <code>Consumer Lag</code>。如果堆积，说明消费端 <code>data-parser</code> 处理不过来了。我会直接修改 Deployment 的 Replicas，增加消费者的 Pod 数量，加快消费速度。”</li>
</ul>
</li>
<li><strong>Q: “Pod 里的 Filebeat 挂了怎么办？”</strong><ul>
<li><strong>A:</strong> “K8s 的 Pod 中，如果 Sidecar 容器退出了，整个 Pod 会显示状态异常（如 NotReady），K8s 会尝试重启它。同时我们监控了 Filebeat 的进程存活状态。”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结：两个项目的区别（面试时心中要有数）"><a href="#总结：两个项目的区别（面试时心中要有数）" class="headerlink" title="总结：两个项目的区别（面试时心中要有数）"></a>总结：两个项目的区别（面试时心中要有数）</h3><table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>项目一：HIS 分布式平台</strong></th>
<th><strong>项目二：设备管理平台</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>部署环境</strong></td>
<td>私有云 &#x2F; 物理机 + 虚拟机</td>
<td><strong>公有云 (阿里云 ACK)</strong></td>
</tr>
<tr>
<td><strong>核心痛点</strong></td>
<td><strong>稳定性</strong>、数据不丢、高可用</td>
<td><strong>吞吐量</strong>、弹性伸缩、成本</td>
</tr>
<tr>
<td><strong>关键技术</strong></td>
<td>Keepalived, Nginx, 物理库</td>
<td>SLB, HPA, Kafka, Cloud Ops</td>
</tr>
<tr>
<td><strong>你的角色</strong></td>
<td>基础设施搭建、各种排错</td>
<td>迁移上云、CICD优化、日志</td>
</tr>
</tbody></table>
<p>现在的你，手握这两套详细的“剧本”，无论是传统的稳定性运维，还是现代的云原生运维，都能跟面试官聊得有来有回。加油！</p>
<h2 id="四、项目难点"><a href="#四、项目难点" class="headerlink" title="四、项目难点"></a>四、项目难点</h2><p>这四个难点（每个项目2个）是经过精心设计的。它们脱离了简单的“服务器宕机了重启一下”这种低级运维操作，而是展示了你对<strong>Kubernetes 机制、微服务治理、操作系统底层以及云原生架构</strong>的深度理解。</p>
<p>在面试中讲述这些难点时，请采用 <strong>STAR 原则</strong>：<strong>Situation（情境）、Task（任务）、Action（行动）、Result（结果）</strong>。</p>
<hr>
<h3 id="项目一：HIS-系统分布式平台建设项目"><a href="#项目一：HIS-系统分布式平台建设项目" class="headerlink" title="项目一：HIS 系统分布式平台建设项目"></a>项目一：HIS 系统分布式平台建设项目</h3><p><strong>关键词：数据一致性、优雅停机、微服务雪崩</strong></p>
<h4 id="难点-1：微服务滚动更新时的“流量损耗”问题（502-Bad-Gateway）"><a href="#难点-1：微服务滚动更新时的“流量损耗”问题（502-Bad-Gateway）" class="headerlink" title="难点 1：微服务滚动更新时的“流量损耗”问题（502 Bad Gateway）"></a>难点 1：微服务滚动更新时的“流量损耗”问题（502 Bad Gateway）</h4><ul>
<li><p>情境 (Situation)：</p>
<p>在项目初期，每当我们进行版本更新（Rolling Update）时，Nginx 监控总会出现少量的 502 Bad Gateway 报错。虽然比例不高（约 1%），但在医院场景下，这意味着有几个挂号请求或医嘱提交失败了，医生体验极差。</p>
</li>
<li><p>分析 (Analysis)：</p>
<p>我深入排查后发现，这是K8s Pod 生命周期与 Nacos 注册中心状态不一致导致的。当 K8s 销毁旧 Pod 时，虽然 Pod 状态变成了 Terminating，但 Nacos 注册中心还没来得及把这个实例下线。此时，上游服务（网关）依然会把流量打到这个正在销毁的 Pod 上，导致请求失败。</p>
</li>
<li><p>解决 (Action)：</p>
<p>我设计了一个**“优雅停机（Graceful Shutdown）”**方案：</p>
<ol>
<li><strong>PreStop Hook</strong>：在 K8s Deployment 中配置 <code>preStop</code> 钩子。</li>
<li><strong>操作逻辑</strong>：在容器销毁前，先执行一个脚本 <code>curl -X POST .../deregister</code> 主动向 Nacos 发送注销请求。</li>
<li><strong>缓冲时间</strong>：脚本执行后 <code>sleep 30</code> 秒，让流量排空，确保正在处理的请求处理完，然后再让 K8s 杀掉容器。</li>
</ol>
</li>
<li><p>结果 (Result)：</p>
<p>上线该配置后，我们在白天业务高峰期进行了 10 次无感发布，Nginx 的 502 报错率降为 0，真正实现了业务无损更新。</p>
</li>
<li><p><strong>✨ 亮点</strong>：展示了你懂 <strong>K8s 生命周期钩子</strong> 和 <strong>服务发现原理</strong>，这是高级运维的标志。</p>
</li>
</ul>
<h4 id="难点-2：早高峰数据库连接池“雪崩”效应"><a href="#难点-2：早高峰数据库连接池“雪崩”效应" class="headerlink" title="难点 2：早高峰数据库连接池“雪崩”效应"></a>难点 2：早高峰数据库连接池“雪崩”效应</h4><ul>
<li><p>情境 (Situation)：</p>
<p>某次周一早高峰，系统突然卡顿。监控显示 MySQL 连接数爆满（Too Many Connections），但 CPU 负载并不高。重启服务后没多久又满了。</p>
</li>
<li><p>分析 (Analysis)：</p>
<p>通过链路追踪（SkyWalking&#x2F;Zipkin）发现，是因为挂号服务响应变慢，导致上游的网关服务触发了超时重试机制。网关在短时间内发起了成倍的重试请求（Retry Storm），这些请求全部堆积在数据库层，导致数据库连接池被耗尽，引发了“雪崩”。</p>
</li>
<li><p>解决 (Action)：</p>
<p>我没有盲目调大数据库连接数，而是从微服务治理层面解决：</p>
<ol>
<li><strong>熔断降级</strong>：在网关层配置了 Sentinel 熔断策略。当后端挂号接口错误率超过 20% 时，直接返回“系统繁忙”，不再请求数据库。</li>
<li><strong>限制重试</strong>：将微服务的默认重试次数从 3 次改为 0 次（非幂等写操作）或 1 次（读操作）。</li>
<li><strong>慢 SQL 优化</strong>：定位到挂号接口的一个慢 SQL，缺少联合索引，配合开发加上索引。</li>
</ol>
</li>
<li><p>结果 (Result)：</p>
<p>解决了雪崩隐患，接口平均响应时间从 500ms 恢复到 80ms，数据库连接数稳定在 40% 左右。</p>
</li>
<li><p><strong>✨ 亮点</strong>：展示了你不仅会看监控，还懂<strong>分布式系统的“雪崩效应”</strong>，并且能从架构层面（熔断、索引）解决问题。</p>
</li>
</ul>
<hr>
<h3 id="项目二：设备管理平台云原生改造-1"><a href="#项目二：设备管理平台云原生改造-1" class="headerlink" title="项目二：设备管理平台云原生改造"></a>项目二：设备管理平台云原生改造</h3><p><strong>关键词：OOM 杀手、HPA 滞后、自定义指标</strong></p>
<h4 id="难点-1：Sidecar-容器导致的“幽灵”-OOM-OOM-Killer-误杀"><a href="#难点-1：Sidecar-容器导致的“幽灵”-OOM-OOM-Killer-误杀" class="headerlink" title="难点 1：Sidecar 容器导致的“幽灵” OOM (OOM-Killer 误杀)"></a>难点 1：Sidecar 容器导致的“幽灵” OOM (OOM-Killer 误杀)</h4><ul>
<li><p>情境 (Situation)：</p>
<p>在阿里云 ACK 集群中，我们的核心数据解析 Pod 经常无故重启。查看监控，Pod 整体内存并没有超限，但总是报 OOMKilled。</p>
</li>
<li><p>分析 (Analysis)：</p>
<p>这是一个经典的 K8s 资源隔离（QoS） 问题。我们的 Pod 里有两个容器：业务容器（Java）和日志采集容器（Filebeat Sidecar）。</p>
<p>我深入节点 dmesg 日志发现，是因为 Filebeat 在采集大量日志时内存飙升，但 Filebeat 容器没有设置资源限制（Limit）。当整个 Pod 内存紧张时，Linux 内核的 OOM-Killer 根据 oom_score_adj 评分，错误地杀掉了占用内存最大的 Java 业务容器，而不是罪魁祸首 Filebeat。</p>
</li>
<li><p><strong>解决 (Action)</strong>：</p>
<ol>
<li><strong>资源限制</strong>：给 Filebeat 容器严格加上 <code>resources.limits.memory = 200Mi</code>。</li>
<li><strong>QoS 调整</strong>：确保核心业务容器的 Request 等于 Limit（Guaranteed QoS 级别），让它在内核眼里的优先级最高，不容易被杀。</li>
<li><strong>日志优化</strong>：调整 Filebeat 配置，减小 <code>mem_queue_size</code>，防止吞没内存。</li>
</ol>
</li>
<li><p>结果 (Result)：</p>
<p>调整后，业务 Pod 再未发生异常重启，系统的稳定性（SLA）从 99% 提升到了 99.9%。</p>
</li>
<li><p><strong>✨ 亮点</strong>：展示了你对 <strong>Linux 内核 OOM 机制</strong>、<strong>K8s QoS 等级</strong> 以及 <strong>Sidecar 模式资源竞争</strong> 的深刻理解。</p>
</li>
</ul>
<h4 id="难点-2：解决-IoT-设备“惊群”效应导致的-HPA-扩容滞后"><a href="#难点-2：解决-IoT-设备“惊群”效应导致的-HPA-扩容滞后" class="headerlink" title="难点 2：解决 IoT 设备“惊群”效应导致的 HPA 扩容滞后"></a>难点 2：解决 IoT 设备“惊群”效应导致的 HPA 扩容滞后</h4><ul>
<li><p>情境 (Situation)：</p>
<p>每天早上 8 点设备集中上线，流量瞬间暴涨 10 倍。虽然我们配置了基于 CPU 的 HPA（自动扩容），但扩容总是慢半拍。因为流量先打到 Kafka，积压在消息队列里，此时消费者的 CPU 还没完全升起来，等 CPU 飙升触发扩容时，Kafka 已经积压了上百万条数据，造成数据延迟。</p>
</li>
<li><p>分析 (Analysis)：</p>
<p>单纯依赖 CPU 指标进行扩容，在削峰填谷场景下存在滞后性。我们需要一种更“前置”的指标来触发扩容。</p>
</li>
<li><p>解决 (Action)：</p>
<p>我实施了 基于自定义指标的 HPA：</p>
<ol>
<li><strong>指标导出</strong>：使用 <code>keda</code> (或 prometheus-adapter)，将 Kafka 的 <strong>Consumer Lag (消费积压数)</strong> 暴露为 K8s 的自定义指标。</li>
<li><strong>策略调整</strong>：修改 HPA 规则，不再只看 CPU。规则设定为：只要 Kafka Lag &gt; 5000，或者 CPU &gt; 60%，就立即扩容。</li>
<li><strong>极速模式</strong>：调整 HPA 的 <code>scaleUp</code> 行为，允许一次性扩容 100% 的副本数（比如直接从 2 个变成 4 个，再变成 8 个），而不是慢慢加。</li>
</ol>
</li>
<li><p>结果 (Result)：</p>
<p>早高峰的数据处理延迟从原来的 15 分钟降低到了 1 分钟以内，真正实现了“秒级响应”的弹性伸缩。</p>
</li>
<li><p><strong>✨ 亮点</strong>：这是<strong>云原生的高阶玩法</strong>。从“由于 CPU 高所以扩容”进阶到“由于队列积压所以扩容”，展示了你对 <strong>KEDA &#x2F; Custom Metrics</strong> 的掌握。</p>
</li>
</ul>
<hr>
<h3 id="面试官视角：为什么这会让我“眼前一亮”？"><a href="#面试官视角：为什么这会让我“眼前一亮”？" class="headerlink" title="面试官视角：为什么这会让我“眼前一亮”？"></a>面试官视角：为什么这会让我“眼前一亮”？</h3><ol>
<li><strong>真实性</strong>：这些问题（OOM误杀、Nacos注册延迟）是只有<strong>真正动手做过 K8s 运维</strong>的人才会遇到的坑，背书是背不出来的。</li>
<li><strong>逻辑闭环</strong>：你不仅发现了问题，还分析了根因（Root Cause），并给出了基于配置或架构的解决方案，最后还有数据结果。</li>
<li><strong>技术深度</strong>：你提到了 PreStop Hook、QoS、HPA Custom Metrics、Sentinel 熔断，这些词汇精准地击中了中高级运维的技能点。</li>
</ol>
<p><strong>建议：</strong> 选你理解最深的一两个重点准备，面试时不需要全说，<strong>同一个项目抛出一个这种级别的难点</strong>，就足够证明你的实力了。</p>
<h2 id="五、可能会问的问题"><a href="#五、可能会问的问题" class="headerlink" title="五、可能会问的问题"></a>五、可能会问的问题</h2><p>如果我是面试官，看到你的简历中写着**“HIS系统分布式平台建设项目”<strong>，特别是考虑到你</strong>应届生&#x2F;实习生<strong>的身份，我的心态通常是：</strong>“这项目含金量很高，技术栈很全，但他到底参与了多少？是真懂还是背八股文？”**</p>
<p>因此，我的提问策略会是**“由面到点，层层深挖，甚至设坑”**。</p>
<p>以下是我会问你的问题清单，按<strong>攻击方向</strong>分类，并附带了<strong>面试官的心理活动（想考察什么）</strong>。</p>
<hr>
<h3 id="第一类：架构与宏观设计（考察你是否真的理解全貌）"><a href="#第一类：架构与宏观设计（考察你是否真的理解全貌）" class="headerlink" title="第一类：架构与宏观设计（考察你是否真的理解全貌）"></a>第一类：架构与宏观设计（考察你是否真的理解全貌）</h3><p><strong>Q1: “能否在白板上（或口述）画一下这个HIS系统的整体架构图？从用户发起一个挂号请求开始，流量是怎么一步步流转到数据库的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：别光堆名词，我要看你知不知道 Nginx、Ingress、Service、Pod、数据库之间到底是怎么连起来的。</li>
<li><strong>准备重点</strong>：用户 -&gt; VIP -&gt; Nginx (Keepalived) -&gt; K8s Ingress -&gt; Service -&gt; Pod -&gt; MySQL&#x2F;Redis。</li>
</ul>
<p><strong>Q2: “我看你简历里写数据库用了物理机，K8s用了虚拟机，为什么这么混合部署？全用虚拟机不行吗？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察你对<strong>IO性能瓶颈</strong>的理解。私立医院HIS系统对写操作要求高，全虚拟化可能有IO延迟。</li>
<li><strong>准备重点</strong>：强调“计算与存储分离”，MySQL需要高性能IO，K8s需要弹性。</li>
</ul>
<p><strong>Q3: “在这个项目中，你作为实习生，具体负责的边界在哪里？哪些是架构师定的，哪些是你自己决策的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察<strong>诚实度</strong>。如果你说架构都是你设计的，我会觉得你吹牛。</li>
<li><strong>准备重点</strong>：老实说“架构师定大方案（如选型K8s），我负责落地实施（如写Dockerfile、搭集群、配监控规则）”。</li>
</ul>
<hr>
<h3 id="第二类：Kubernetes-与容器化（考察核心技能）"><a href="#第二类：Kubernetes-与容器化（考察核心技能）" class="headerlink" title="第二类：Kubernetes 与容器化（考察核心技能）"></a>第二类：Kubernetes 与容器化（考察核心技能）</h3><p><strong>Q4: “你提到用HPA解决了早高峰挂号压力，你的HPA阈值是怎么设置的？如果Pod启动很慢，HPA扩容来不及怎么办？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察实战细节。HPA不是万能的，Java应用启动慢是通病。</li>
<li><strong>准备重点</strong>：回答 CPU 60% 扩容；提到 <strong>Readiness Probe (就绪探针)</strong> 确保服务真正启动才接流量；或者提到预留 buffer。</li>
</ul>
<p><strong>Q5: “如果线上一个挂号服务的Pod突然状态变成了 <code>CrashLoopBackOff</code> 或 <code>Pending</code>，你的排查思路是什么？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：这是<strong>必考题</strong>。考察故障排查逻辑。</li>
<li><strong>准备重点</strong>：<code>kubectl describe pod</code> 看事件 -&gt; <code>kubectl logs</code> 看日志 -&gt; 检查资源配额&#x2F;健康检查&#x2F;镜像配置。</li>
</ul>
<p><strong>Q6: “你的简历里写了‘高可用’，如果 K8s 的 Master 节点挂了一台，集群还能工作吗？如果 Nginx 的主节点挂了，VIP 是怎么漂移的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察对 HA (High Availability) 原理的理解，VRRP 协议和 Etcd 的高可用。</li>
<li><strong>准备重点</strong>：Master 3节点挂1台没事（Raft协议）；Keepalived 利用 VRRP 协议竞选 Master。</li>
</ul>
<hr>
<h3 id="第三类：数据库与数据一致性（考察业务保障能力）"><a href="#第三类：数据库与数据一致性（考察业务保障能力）" class="headerlink" title="第三类：数据库与数据一致性（考察业务保障能力）"></a>第三类：数据库与数据一致性（考察业务保障能力）</h3><p><strong>Q7: “HIS系统最怕丢数据。你们的 MySQL 主从复制是异步的还是半同步的？如果主库突然宕机，怎么保证刚挂号的数据不丢失？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察数据安全意识。</li>
<li><strong>准备重点</strong>：提到半同步复制 (Semi-sync) 或者 MHA 的切换机制；或者坦诚说存在极小概率丢失，靠 Binlog 补救。</li>
</ul>
<p><strong>Q8: “你提到药房模块用了 Redis 做缓存，如果 Redis 里的库存和 MySQL 里的库存不一致了（比如 Redis 扣了，数据库没扣），怎么处理？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察缓存一致性这个经典难题。</li>
<li><strong>准备重点</strong>：提到“最终一致性”，或者“缓存双删策略”，或者“以数据库为准，定期刷新缓存”。</li>
</ul>
<hr>
<h3 id="第四类：监控与日志（考察运维敏感度）"><a href="#第四类：监控与日志（考察运维敏感度）" class="headerlink" title="第四类：监控与日志（考察运维敏感度）"></a>第四类：监控与日志（考察运维敏感度）</h3><p><strong>Q9: “你用 Prometheus 监控，在这个项目中，你觉得最有价值的一个告警规则是什么？发生过什么真实的告警吗？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：看你是不是真的在用监控，还是只是搭起来好看。</li>
<li><strong>准备重点</strong>：讲一个具体的例子，比如“慢SQL告警”或者“磁盘剩余空间不足10%告警”，并讲出你是怎么处理的。</li>
</ul>
<p><strong>Q10: “早高峰的时候日志量很大，Filebeat 采集日志会占用业务 Pod 的 CPU 吗？你们是怎么限制的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察资源隔离和 Sidecar 模式的副作用。</li>
<li><strong>准备重点</strong>：提到给 Filebeat 容器设置 <code>resources.limits</code>，防止它抢占业务资源。</li>
</ul>
<hr>
<h3 id="第五类：CI-CD-与-脚本（考察效率工具）"><a href="#第五类：CI-CD-与-脚本（考察效率工具）" class="headerlink" title="第五类：CI&#x2F;CD 与 脚本（考察效率工具）"></a>第五类：CI&#x2F;CD 与 脚本（考察效率工具）</h3><p><strong>Q11: “你搭建的 CI&#x2F;CD 流水线，如果新发的版本有严重 Bug，怎么在 1 分钟内回滚？Jenkins 里是怎么配置的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：发布很重要，回滚更重要（尤其是医院系统）。</li>
<li><strong>准备重点</strong>：提到 K8s 的 <code>rollout undo</code> 命令，或者在 Jenkins 里保留上一个版本的镜像 Tag，一键重新部署旧 Tag。</li>
</ul>
<hr>
<h3 id="第六类：压力测试与情景题（终极考验）"><a href="#第六类：压力测试与情景题（终极考验）" class="headerlink" title="第六类：压力测试与情景题（终极考验）"></a>第六类：压力测试与情景题（终极考验）</h3><p><strong>Q12: “这是一个私立医院项目，假设某天医院搞‘免费义诊’活动，流量预计是平时的 10 倍，作为运维你需要做哪些准备工作？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察<strong>运维规划能力</strong>。</li>
<li><strong>准备重点</strong>：<ol>
<li>提前扩容（修改 ReplicaSet）。</li>
<li>对非核心服务（如报表）进行降级（限制资源或暂停）。</li>
<li>检查数据库磁盘空间。</li>
<li>全员待命，盯着监控大屏。</li>
</ol>
</li>
</ul>
<p><strong>Q13: “你在项目中遇到过最难解决的问题是什么？你是怎么发现根因的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：这也是<strong>必考题</strong>。别说“没遇到问题”，那说明你没干活。</li>
<li><strong>准备重点</strong>：可以用我之前给你的**“Sidecar版本不一致导致Service调度失败”<strong>或者</strong>“Filebeat导致OOM”**的案例。</li>
</ul>
<hr>
<h3 id="给朱鑫烨的备战建议："><a href="#给朱鑫烨的备战建议：" class="headerlink" title="给朱鑫烨的备战建议："></a>给朱鑫烨的备战建议：</h3><ol>
<li><strong>别被吓到</strong>：上面这些问题看着难，但你只要把我之前给你的“详细拆解”看熟，80% 都能答上来。</li>
<li><strong>引导话题</strong>：如果问到你不懂的（比如数据库底层算法），你就往你懂的地方引（比如：“数据库内核参数我调整得少，但我主要通过 Prometheus 监控它的慢查询指标……”）。</li>
<li><strong>强调“协助”与“学习”</strong>：遇到实在太深的问题，就说：“当时架构师主要负责这块的设计，我主要负责实施和监控，但我事后去了解了一下，原理大概是……”</li>
</ol>
<p><strong>你要我现在针对某一个具体问题（比如 Q5 排查思路 或 Q12 活动保障），给你写一个满分回答范例吗？</strong></p>
<p>针对你的第二个项目**“设备管理平台云原生改造”<strong>，作为面试官，我会把重点放在</strong>“云原生落地能力”、“阿里云产品熟悉度”<strong>以及</strong>“IoT高并发场景下的运维思维”**上。</p>
<p>因为你是实习生，我会侧重考察你对<strong>基础概念的理解</strong>以及<strong>解决具体问题的思路</strong>，而不是让你设计一个复杂的分布式架构。</p>
<p>以下是我会问你的问题清单，按考察维度分类，附带了面试官的考察点（心理活动）。</p>
<hr>
<h3 id="第一维度：云原生与Kubernetes实战（核心考察点）"><a href="#第一维度：云原生与Kubernetes实战（核心考察点）" class="headerlink" title="第一维度：云原生与Kubernetes实战（核心考察点）"></a>第一维度：云原生与Kubernetes实战（核心考察点）</h3><p><strong>Q1. “你在简历里说负责将虚拟机服务迁移到 ACK 集群，能不能详细说一下你们是怎么迁移的？比如在这个过程中，怎么保证服务不中断？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：我想看你是不是真的参与了迁移，还是只接手了维护。看你是否懂“灰度发布”或“滚动更新”的概念。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>先在测试环境验证 Dockerfile 和 K8s YAML。</li>
<li>上线时利用 SLB 的权重控制，或者 K8s 的 Service 选择器，先切一小部分流量到容器，观察日志没报错，再逐步全量切换。</li>
<li><strong>关键点</strong>：如果答不上来复杂的，就说“利用 K8s Deployment 的 RollingUpdate 策略，旧 Pod 销毁前新 Pod 必须 Ready”。</li>
</ul>
</li>
</ul>
<p><strong>Q2. “你提到了使用 HPA（水平自动伸缩），你的触发指标是什么？如果业务应用启动需要 2 分钟，HPA 扩容来不及怎么办？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：HPA 是 K8s 的标配，但Java应用启动慢是通病。我想看你是否遇到过“扩容了但服务还没活，反而把节点拖死”的情况。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>指标通常是 CPU 利用率（如 &gt;60%）。</li>
<li><strong>应对启动慢</strong>：配置 <strong>Readiness Probe（就绪探针）</strong>。只有探针通过了，Service 才会把流量转发给新 Pod，防止请求打到正在启动的 Pod 上报错。</li>
<li>还可以提到“预留 Buffer”，比如设置 <code>minReplicas</code> 稍微大一点。</li>
</ul>
</li>
</ul>
<p><strong>Q3. “在这个项目中，你维护了 ConfigMap 和 Secret。如果我更新了 ConfigMap 里的配置文件，Pod 里的配置会自动更新吗？还是需要重启？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察 K8s 的配置热更新机制，这是运维高频操作。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>默认情况下，如果是挂载为 Volume，文件会更新，但应用能不能读到取决于应用本身有没有“热加载”功能。</li>
<li>通常我们需要手动重启 Pod（<code>kubectl rollout restart</code>）来让配置生效，确保状态一致。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二维度：阿里云产品与网络（环境熟悉度）"><a href="#第二维度：阿里云产品与网络（环境熟悉度）" class="headerlink" title="第二维度：阿里云产品与网络（环境熟悉度）"></a>第二维度：阿里云产品与网络（环境熟悉度）</h3><p><strong>Q4. “你们用了阿里云的 SLB、Ingress 和 Service，能解释一下这三者在你们项目里的关系吗？流量是怎么进来的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：看你分不分得清四层负载（SLB）和七层负载（Ingress）。很多新手会混淆。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>用户&#x2F;设备 -&gt; 阿里云 SLB（公网入口）-&gt; K8s Ingress Controller（七层路由，根据域名分发）-&gt; K8s Service（集群内服务发现）-&gt; Pod。</li>
<li>这展示了你对<strong>1</strong>中提到的接入层流量调度的理解。</li>
</ul>
</li>
</ul>
<p><strong>Q5. “你简历提到优化了 Jenkinsfile 脚本来清理镜像，为什么要做这个？阿里云的 ACR（容器镜像服务）本身没有清理功能吗？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察你是否关注过<strong>2</strong>中提到的“无用镜像清理”细节，以及你是否有动手写 Shell&#x2F;Pipeline 的能力。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>开发提交频繁，产生了大量 tag。虽然 ACR 有生命周期管理，但我们希望在构建端就控制好，或者说为了节省存储成本（FinOps）。</li>
<li>我在 Pipeline 最后加了一段脚本，只保留最新的 5 个版本，旧的自动调 API 删除。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第三维度：IoT-业务场景与故障排查（解决问题能力）"><a href="#第三维度：IoT-业务场景与故障排查（解决问题能力）" class="headerlink" title="第三维度：IoT 业务场景与故障排查（解决问题能力）"></a>第三维度：IoT 业务场景与故障排查（解决问题能力）</h3><p><strong>Q6. “设备管理平台会有很多设备同时上报数据，如果某天 Kafka 消息堆积了（Lag 很高），你怎么排查？怎么处理？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：IoT 必问 Kafka。考察你对“生产者-消费者”模型的理解。</li>
<li><strong>参考回答方向</strong>：<ul>
<li><strong>排查</strong>：先看 Prometheus 监控，是生产速度暴增（设备故障&#x2F;攻击），还是消费速度变慢（数据库锁死&#x2F;程序Bug）。</li>
<li><strong>处理</strong>：如果是消费慢，利用 K8s 的优势，<strong>手动扩容消费端 Pod 的副本数</strong>（比如从 2 改到 6），加快消费速度。</li>
</ul>
</li>
</ul>
<p><strong>Q7. “你简历里写了‘协助开发定位接口超时问题’。具体是怎么定位的？用到了哪些工具？”</strong></p>
<p>- </p>
<p>  <strong>面试官心理</strong>：考察<strong>3</strong>提到的 ELK 和 Prometheus 的联动使用。</p>
<ul>
<li><p><strong>参考回答方向</strong>：</p>
<ul>
<li>先看 Prometheus 的接口响应时间指标（Latency），确认是哪个接口慢。</li>
<li>再去 Kibana 搜该接口的日志，结合 <code>trace_id</code> 看调用链，发现是 SQL 慢查询，还是 Redis 链接超时，或者是死锁。</li>
</ul>
</li>
</ul>
<p><strong>Q8. “在 Pod 容器化部署中，经常遇到 OOMKilled（内存溢出被杀），你遇到过吗？你是怎么设置 Resources Limit 的？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察资源规划能力。乱设资源限制是新手大忌。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>遇到过（特别是数据解析服务）。</li>
<li>我会用压测数据做参考，Request 设置为正常运行所需的量，Limit 设置为 Request 的 1.2-1.5 倍（或者 2 倍），防止无限吃内存影响节点稳定性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第四维度：开放性-软技能问题（态度与潜力）"><a href="#第四维度：开放性-软技能问题（态度与潜力）" class="headerlink" title="第四维度：开放性&#x2F;软技能问题（态度与潜力）"></a>第四维度：开放性&#x2F;软技能问题（态度与潜力）</h3><p><strong>Q9. “相比于你自己搭建 K8s（像你上一个 HIS 项目），你觉得使用阿里云 ACK 最大的好处是什么？有什么坏处吗？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：看你是否有对比思维，不仅仅是“会用”，而是“懂选型”。</li>
<li><strong>参考回答方向</strong>：<ul>
<li><strong>好处</strong>：省去了维护 Master 节点和 Etcd 的麻烦，扩容节点非常快（弹性伸缩），SLB 集成度高。</li>
<li><strong>坏处</strong>：要花钱（成本），可能会被云厂商绑定，不仅要懂 K8s 还要懂云产品的 API。</li>
</ul>
</li>
</ul>
<p><strong>Q10. “如果让你给现在的设备管理平台做进一步优化，你会做什么？”</strong></p>
<ul>
<li><strong>面试官心理</strong>：考察你的职业规划 4 和学习意愿。</li>
<li><strong>参考回答方向</strong>：<ul>
<li>“我想引入 <strong>Service Mesh (Istio)</strong> 来做更细粒度的流量控制和熔断，因为现在微服务多了，服务间调用关系复杂。”</li>
<li>或者 “我想进一步推进 <strong>FinOps</strong>，利用 Spot 实例（抢占式实例）来跑非核心的计算任务，进一步降低成本。”</li>
</ul>
</li>
</ul>
<hr>
<h3 id="💡-这里的“必杀技”建议："><a href="#💡-这里的“必杀技”建议：" class="headerlink" title="💡 这里的“必杀技”建议："></a>💡 这里的“必杀技”建议：</h3><p>如果面试官问了 Q6（Kafka 堆积）或者 Q2（HPA），你在回答完技术细节后，补一句：</p>
<blockquote>
<p><strong>“其实在这个项目中，我也意识到了公有云成本控制的重要性。通过合理的 HPA 策略和镜像清理，我帮团队节省了不少存储和计算的开销。”</strong></p>
</blockquote>
<p>这句话会非常加分，因为它展示了你<strong>不仅是技术执行者，还是一个替公司省钱的好员工</strong>。</p>
<h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><p>学习迭代”持续跟进DevOps和AIOps趋势，抽空考取CKA&#x2F;阿里云ACE认证”，希望往架构方向走</p>
<p>希望能有机会与团队深入探讨运维体系优化方案，再次感谢您的时间</p>
<h1 id="技术关键词"><a href="#技术关键词" class="headerlink" title="技术关键词"></a>技术关键词</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Felix</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/">http://example.com/2025/10/14/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E2%80%94%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8C%81%E7%BB%AD%E7%A7%AF%E7%B4%AF%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/">学习过程中持续积累的面试题</a></div><div class="post-share"><div class="social-share" data-image="/imgs/adater.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/15/Git/" title="Git的学习与使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Git的学习与使用</div></div><div class="info-2"><div class="info-item-1">Git一、初识Git它允许您保存不同版本的作品，而无需创建多个文件。您可以轻松地回到任何以前的版本，或创建备用时间线（我们称之为“分支”）来尝试不同的想法。 1.1 git初始化初始化Git储存库 1git init   1.2 git的不同状态查看git状态 1git status     “分支主”：将分支想象成时间线。“主”是项目的主要时间线。 “尚未提交”：提交就像视频游戏中的保存点。我们还没有做出任何保存点。 “nothing to commit”：Git 没有要记录的更改，因为我们还没有创建任何文件。     添加文件后会显示文件未跟踪  使用add命令后告诉git我需要保存这个文件时间点，即git开始跟踪文件 1git add message.txt   执行提交commit后，git暂存区清空，文件传输到git仓库中 1git commit -m &quot;send a message to the future&quot;   1.3 查看git日志1git log    展示的几条信息：  提交的唯一标识符（一长串字母和数字） 谁提交了 提交时间 我们编写的...</div></div></div></a><a class="pagination-related" href="/2025/10/14/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" title="Linux常见命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Linux常见命令</div></div><div class="info-2"><div class="info-item-1">Linux的目录结构与常见命令一、引言了解Linux命令前，首先要知道输入命令的工具shell是什么，命令有哪些命令? Shellshell是Linux系统中后台运行的一种特殊程序也可以理解成一种特殊的软件，提供了用户与内核进行交互操作的一种接口。通俗讲，用户使用应用程序发布命令（比如使用浏览器访问网页），Shell去通知操作系统需要进行什么操作（相当于解释层）。 命令种类shell 分为内部命令和外部命令 内部命令：在系统启动时就调入内存中，是常驻内存的，执行效率非常高。 外部命令：是系统软件的功能，用户需要时才从硬盘读取到内存中。 一般先执行内部命令再执行外部命令（别名最大）。 二、目录结构了解完使用命令的工具，其次就需要了解Linux系统中，什么目录是做什么的，存放什么内容。 Linux的目录结构如下图：  1)    &#x2F; (根目录)  ⭐ 整个文件系统的起点 2)    &#x2F;bin ⭐ 存放基本的系统命令，如ls, cp, mv 3)    &#x2F;boot 包含引导加载程序文件和内核 4)    &#x2F;dev ⭐ 设备文件目录，如硬盘、键盘等...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/imgs/adater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Felix</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/falsezxy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text">docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s"><span class="toc-number">2.</span> <span class="toc-text">k8s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ansible-prometheus-elk"><span class="toc-number">3.</span> <span class="toc-text">ansible prometheus elk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ansible-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">ansible 面试题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prometheus"><span class="toc-number">3.2.</span> <span class="toc-text">prometheus:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.</span> <span class="toc-text">日志分析系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CI-CD"><span class="toc-number">4.</span> <span class="toc-text">CI&#x2F;CD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88"><span class="toc-number"></span> <span class="toc-text">云计算相关知识整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="toc-number">0.1.</span> <span class="toc-text">一、整体框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">0.2.</span> <span class="toc-text">二、技术栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Linux"><span class="toc-number">0.2.1.</span> <span class="toc-text">1、Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">0.2.1.1.</span> <span class="toc-text">（1）基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%96%87%E4%BB%B6%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C-The-Basics"><span class="toc-number">0.2.1.1.1.</span> <span class="toc-text">基础文件与命令操作 (The Basics)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B5%84%E6%BA%90-System-Resource-Status"><span class="toc-number">0.2.1.1.2.</span> <span class="toc-text">系统状态与性能资源 (System &amp; Resource Status)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E6%97%A5%E5%BF%97-Process-Logs"><span class="toc-number">0.2.1.1.3.</span> <span class="toc-text">进程管理与日志 (Process &amp; Logs)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BD%91%E7%BB%9C-Storage-Network"><span class="toc-number">0.2.1.1.4.</span> <span class="toc-text">存储与网络 (Storage &amp; Network)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9A%E9%AB%98%E8%B4%9F%E8%BD%BD%E4%B8%8E%E6%85%A2%E5%93%8D%E5%BA%94-High-Load-Slow-Response"><span class="toc-number">0.2.1.1.5.</span> <span class="toc-text">场景一：高负载与慢响应 (High Load &amp; Slow Response)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9A%E9%87%8D%E5%A4%A7%E6%95%85%E9%9A%9C%EF%BC%9AOOMKilled-Out-of-Memory-Killed"><span class="toc-number">0.2.1.1.6.</span> <span class="toc-text">场景二：重大故障：OOMKilled (Out of Memory Killed)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%EF%BC%9A%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E7%88%86%E6%BB%A1-Disk-Full"><span class="toc-number">0.2.1.1.7.</span> <span class="toc-text">场景三：磁盘空间爆满 (Disk Full)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#tcpdump"><span class="toc-number">0.2.1.1.8.</span> <span class="toc-text">tcpdump</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#telnet%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%B9%B3%E6%97%B6%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96%E7%BD%91%E7%BB%9C%E7%9A%84%E7%9B%91%E6%8E%A7%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-number">0.2.1.1.9.</span> <span class="toc-text">telnet的作用？平时怎么抓取网络的监控数据的?</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Shell-%E8%84%9A%E6%9C%AC"><span class="toc-number">0.2.1.2.</span> <span class="toc-text">（2）Shell 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9Ashell%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">0.2.1.2.1.</span> <span class="toc-text">案例：shell构建系统监视器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%A0%B8%E5%BF%83%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">0.2.1.3.</span> <span class="toc-text">（3）核心的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#OOM-KILL"><span class="toc-number">0.2.1.3.1.</span> <span class="toc-text">OOM KILL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8E%8B%E5%8A%9B%E8%BF%87%E5%A4%A7"><span class="toc-number">0.2.1.3.2.</span> <span class="toc-text">网络压力过大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.2.2.</span> <span class="toc-text">2、应用服务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89LVS-keepalived-Nginx-%E4%BD%93%E7%B3%BB"><span class="toc-number">0.2.2.1.</span> <span class="toc-text">（1）LVS + keepalived + Nginx 体系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Spring-cloud-boot-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.2.2.2.</span> <span class="toc-text">（2）Spring cloud&#x2F;boot 微服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%BC%93%E5%86%B2%E5%B1%82"><span class="toc-number">0.2.2.3.</span> <span class="toc-text">（3）中间件缓冲层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%94%AF%E6%8C%81%E3%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">0.2.3.</span> <span class="toc-text">3、支持、管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ELK-%E4%BD%93%E7%B3%BB"><span class="toc-number">0.2.3.1.</span> <span class="toc-text">(1) ELK 体系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1"><span class="toc-number">0.2.3.2.</span> <span class="toc-text">(2) 监控服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83"><span class="toc-number">0.2.4.</span> <span class="toc-text">4、云原生基础环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E7%AF%87"><span class="toc-number">0.2.4.1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">0.2.4.2.</span> <span class="toc-text">虚拟化&#x2F;容器技术</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">0.2.5.</span> <span class="toc-text">5、资源管理器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%A4%8D%E8%A6%81%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%BB%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">反复要讲清楚的主题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%92%8CShell%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Linux和Shell类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8-Nginx"><span class="toc-number">1.1.</span> <span class="toc-text">1. 网络高并发场景 (Web 服务器 &#x2F; Nginx)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E8%B4%9F%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%BA%E6%99%AF-MySQL-PostgreSQL-Redis"><span class="toc-number">1.2.</span> <span class="toc-text">2. 高负载数据库场景 (MySQL &#x2F; PostgreSQL &#x2F; Redis)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Java-%E5%BA%94%E7%94%A8%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%9C%BA%E6%99%AF-JVM-Kafka"><span class="toc-number">1.3.</span> <span class="toc-text">3. Java 应用与中间件场景 (JVM &#x2F; Kafka)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%B9%E5%99%A8%E5%8C%96%E5%9C%BA%E6%99%AF-Docker-Kubernetes"><span class="toc-number">1.4.</span> <span class="toc-text">4. 容器化场景 (Docker &#x2F; Kubernetes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">5. 通用基础优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.6.</span> <span class="toc-text">总结建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">网络类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">虚拟化技术类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">中间件类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubenetes%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">kubenetes类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E4%B8%80%E4%B8%AA-Pod-%E5%86%85%E7%9A%84%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1%EF%BC%88Loopback%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">1. 同一个 Pod 内的容器通信（Loopback）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8C%E4%B8%80%E8%8A%82%E7%82%B9%E4%B8%8A%E7%9A%84-Pod-%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88Bridge%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">2. 同一节点上的 Pod 间通信（Bridge）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%A8%E8%8A%82%E7%82%B9%E7%9A%84-Pod-%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88Overlay-Routing%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">3. 跨节点的 Pod 间通信（Overlay &#x2F; Routing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Pod-%E8%AE%BF%E9%97%AE-Service-Svc-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.4.</span> <span class="toc-text">4. Pod 访问 Service (Svc 网络)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%89%E7%B1%BB%E7%BD%91%E7%BB%9C%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="toc-number">5.5.</span> <span class="toc-text">5. 总结：三类网络的职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">1. 核心原理与模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94"><span class="toc-number">5.7.</span> <span class="toc-text">2. 详细对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5-NetworkPolicy-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.8.</span> <span class="toc-text">3. 网络策略 (NetworkPolicy) 的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%81%E9%87%8F%E8%B7%AF%E5%BE%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.</span> <span class="toc-text">4. 流量路径的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">5. 如何选型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DevOps%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">DevOps类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CI-Continuous-Integration-%E2%80%94%E2%80%94-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><span class="toc-number">6.1.</span> <span class="toc-text">1. CI (Continuous Integration) —— 持续集成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CD-%E2%80%94%E2%80%94-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">6.2.</span> <span class="toc-text">2. CD —— 持续交付与持续部署</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CD-Continuous-Delivery-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98"><span class="toc-number">6.2.1.</span> <span class="toc-text">CD - Continuous Delivery (持续交付)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CD-Continuous-Deployment-%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">6.2.2.</span> <span class="toc-text">CD - Continuous Deployment (持续部署)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E5%BC%A0%E8%A1%A8%E6%80%BB%E7%BB%93-CI-%E4%B8%8E-CD-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">6.3.</span> <span class="toc-text">3. 一张表总结 CI 与 CD 的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%88%E4%BB%A5%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84-Nginx-%E9%A1%B9%E7%9B%AE%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">4. 一个真实的例子（以你常用的 Nginx 项目为例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%E4%B8%8E%E8%A7%A6%E5%8F%91%EF%BC%88Trigger%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">1. 环境准备与触发（Trigger）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E6%A3%80%E5%87%BA%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5-Checkout-Init"><span class="toc-number">6.6.</span> <span class="toc-text">2. 阶段一：检出与环境检查 (Checkout &amp; Init)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%8E%E6%B5%8B%E8%AF%95-Build-Test-%E2%80%94%E2%80%94-CI-%E6%A0%B8%E5%BF%83"><span class="toc-number">6.7.</span> <span class="toc-text">3. 阶段二：构建与测试 (Build &amp; Test) —— CI 核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E4%B8%8E%E6%8E%A8%E9%80%81-Docker-Build-Push"><span class="toc-number">6.8.</span> <span class="toc-text">4. 阶段三：镜像制作与推送 (Docker Build &amp; Push)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%B6%E6%AE%B5%E5%9B%9B%EF%BC%9A%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2-Deploy-%E2%80%94%E2%80%94-CD-%E6%A0%B8%E5%BF%83"><span class="toc-number">6.9.</span> <span class="toc-text">5. 阶段四：自动化部署 (Deploy) —— CD 核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%98%B6%E6%AE%B5%E4%BA%94%EF%BC%9A%E9%80%9A%E7%9F%A5%E4%B8%8E%E6%B8%85%E7%90%86-Post-Actions"><span class="toc-number">6.10.</span> <span class="toc-text">6. 阶段五：通知与清理 (Post Actions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%80%E4%BB%BD%E5%AE%8C%E6%95%B4%E7%9A%84-Jenkinsfile-%E7%BB%93%E6%9E%84"><span class="toc-number">6.11.</span> <span class="toc-text">总结：一份完整的 Jenkinsfile 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9AJenkins-%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%87%86%E5%A4%87"><span class="toc-number">6.12.</span> <span class="toc-text">第一步：Jenkins 安装插件与准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9AJenkins-%E4%BE%A7%E9%85%8D%E7%BD%AE-Pipeline-%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.13.</span> <span class="toc-text">第二步：Jenkins 侧配置 Pipeline 任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9AGitLab-%E4%BE%A7%E9%85%8D%E7%BD%AE-Webhook"><span class="toc-number">6.14.</span> <span class="toc-text">第三步：GitLab 侧配置 Webhook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9APipeline-%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99-Jenkinsfile"><span class="toc-number">6.15.</span> <span class="toc-text">第四步：Pipeline 脚本编写 (Jenkinsfile)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">综合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%8F%E8%A7%82%E8%AF%B7%E6%B1%82%E6%B5%81%E5%90%91%EF%BC%9A%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">7.1.</span> <span class="toc-text">1. 宏观请求流向：从浏览器到数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%B4%E6%B5%81%E5%90%91%EF%BC%88%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">2. 微服务间流向（内部调用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="toc-number">7.3.</span> <span class="toc-text">3. 组件间的数据交互关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%A6%E7%BB%86%E7%9A%84%E8%AE%A4%E8%AF%81%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91%EF%BC%88%E7%89%B9%E8%89%B2%E7%8E%AF%E8%8A%82%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">4. 详细的认证数据流向（特色环节）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">7.5.</span> <span class="toc-text">5. 总结：数据流转的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%9A%E7%A8%B3%E3%80%81%E5%87%86%E3%80%81%E5%BF%AB%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">一、 后端技术栈（重点：稳、准、快）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%9A%E4%BA%A4%E4%BA%92%E3%80%81%E5%9B%BE%E8%A1%A8%E3%80%81%E9%80%82%E9%85%8D%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">二、 前端技术栈（重点：交互、图表、适配）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E7%9A%84%EF%BC%9F%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E9%97%AE%EF%BC%89"><span class="toc-number">7.8.</span> <span class="toc-text">三、 前后端是如何对接的？（面试必问）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%EF%BC%88%E7%BA%A6%E5%AE%9A%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">7.8.1.</span> <span class="toc-text">1. 接口定义（约定阶段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BD%91%E5%85%B3%E5%88%86%E5%8F%91%EF%BC%88%E8%B7%AF%E7%94%B1%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">7.8.2.</span> <span class="toc-text">2. 网关分发（路由阶段）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%89%B4%E6%9D%83%E5%AF%B9%E6%8E%A5%EF%BC%88%E6%A0%B8%E5%BF%83%E7%8E%AF%E8%8A%82%EF%BC%89"><span class="toc-number">7.8.3.</span> <span class="toc-text">3. 鉴权对接（核心环节）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86%EF%BC%88Cors%EF%BC%89"><span class="toc-number">7.8.4.</span> <span class="toc-text">4. 跨域处理（Cors）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">7.8.5.</span> <span class="toc-text">5. 数据转换（交互阶段）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E7%AE%80%E5%8E%86%E4%BA%AE%E7%82%B9%E6%8F%8F%E8%BF%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.9.</span> <span class="toc-text">四、 简历亮点描述示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%EF%BC%88%E6%A0%B8%E5%BF%83%E6%89%BF%E8%BD%BD%EF%BC%89"><span class="toc-number">7.10.</span> <span class="toc-text">1. 计算与容器服务（核心承载）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88%E6%B5%81%E9%87%8F%E5%85%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">7.11.</span> <span class="toc-text">2. 网络与负载均衡（流量入口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E7%BC%93%E5%AD%98%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%95%E5%BA%A7%EF%BC%89"><span class="toc-number">7.12.</span> <span class="toc-text">3. 数据存储与缓存（数据底座）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E6%B6%88%E6%81%AF%EF%BC%88%E8%A7%A3%E8%80%A6%E5%BC%82%E6%AD%A5%EF%BC%89"><span class="toc-number">7.13.</span> <span class="toc-text">4. 中间件与消息（解耦异步）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%89%E5%85%A8%E4%B8%8E%E7%9B%91%E6%8E%A7%EF%BC%88%E7%A8%B3%E5%AE%9A%E4%BF%9D%E9%9A%9C%EF%BC%89"><span class="toc-number">7.14.</span> <span class="toc-text">5. 安全与监控（稳定保障）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%9C%A8%E7%AE%80%E5%8E%86%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E8%BF%99%E6%AE%B5%E8%AF%9D%EF%BC%9F"><span class="toc-number">7.15.</span> <span class="toc-text">总结：在简历中如何组织这段话？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%91%E8%A3%82%EF%BC%9F"><span class="toc-number">7.16.</span> <span class="toc-text">1. 什么是脑裂？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RAFT-%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%84%91%E8%A3%82%EF%BC%9F"><span class="toc-number">7.17.</span> <span class="toc-text">2. RAFT 算法如何避免脑裂？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E8%BF%87%E5%8D%8A%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6%EF%BC%88Quorum%EF%BC%89"><span class="toc-number">7.17.1.</span> <span class="toc-text">① 过半投票机制（Quorum）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E4%BB%BB%E6%9C%9F%E7%BC%96%E5%8F%B7%EF%BC%88Term%EF%BC%89"><span class="toc-number">7.17.2.</span> <span class="toc-text">② 任期编号（Term）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E9%A2%84%E6%8A%95%E7%A5%A8%E6%9C%BA%E5%88%B6%EF%BC%88Pre-Vote%EF%BC%89%E2%80%94%E2%80%94-%E8%BF%9B%E9%98%B6%E4%BC%98%E5%8C%96"><span class="toc-number">7.17.3.</span> <span class="toc-text">③ 预投票机制（Pre-Vote）—— 进阶优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E9%80%89%E7%A5%A8%E5%8F%AA%E8%83%BD%E6%8A%95%E4%B8%80%E6%AC%A1"><span class="toc-number">7.17.4.</span> <span class="toc-text">④ 选票只能投一次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%98%AF-2-%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E9%9B%86%E7%BE%A4%E5%91%A2%EF%BC%9F"><span class="toc-number">7.18.</span> <span class="toc-text">3. 特殊情况：如果是 2 个节点的集群呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%88%86%E7%82%B9%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%80%9C%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB%E2%80%9D%E4%B8%AD%E7%9A%84%E8%84%91%E8%A3%82%EF%BC%9F"><span class="toc-number">7.19.</span> <span class="toc-text">💡 面试加分点：如何解决“线性一致性读”中的脑裂？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">微服务类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">1. 核心框架与基础架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%BB%84%E4%BB%B6-%E5%85%B3%E9%94%AE"><span class="toc-number">8.2.</span> <span class="toc-text">2. 微服务治理组件 (关键)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Nacos-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">8.2.1.</span> <span class="toc-text">Nacos (注册中心 + 配置中心)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Cloud-Gateway-%E7%BD%91%E5%85%B3"><span class="toc-number">8.2.2.</span> <span class="toc-text">Spring Cloud Gateway (网关)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sentinel-%E6%B5%81%E9%87%8F%E9%98%B2%E5%8D%AB%E5%85%B5"><span class="toc-number">8.2.3.</span> <span class="toc-text">Sentinel (流量防卫兵)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">8.3.</span> <span class="toc-text">3. 通信与中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenFeign-%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">8.3.1.</span> <span class="toc-text">OpenFeign (声明式调用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">8.3.2.</span> <span class="toc-text">Redis (分布式缓存)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RabbitMQ-RocketMQ-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">8.3.3.</span> <span class="toc-text">RabbitMQ &#x2F; RocketMQ (消息队列)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9D%83%E9%99%90%E4%B8%8E%E5%AE%89%E5%85%A8"><span class="toc-number">8.4.</span> <span class="toc-text">4. 权限与安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-JSON-Web-Token"><span class="toc-number">8.4.1.</span> <span class="toc-text">JWT (JSON Web Token)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%B1%82"><span class="toc-number">8.5.</span> <span class="toc-text">5. 数据持久层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%90%E7%BB%B4%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">8.6.</span> <span class="toc-text">6. 运维与监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.7.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%99%90%E6%B5%81-Rate-Limiting-%E2%80%94%E2%80%94-%E2%80%9C%E6%8E%A7%E5%88%B6%E5%85%A5%E5%8F%A3%E6%B0%B4%E9%87%8F%E2%80%9D"><span class="toc-number">8.7.1.</span> <span class="toc-text">1. 限流 (Rate Limiting) —— “控制入口水量”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%86%94%E6%96%AD-Circuit-Breaking-%E2%80%94%E2%80%94-%E2%80%9C%E5%AE%B6%E9%87%8C%E7%9A%84%E4%BF%9D%E9%99%A9%E4%B8%9D%E2%80%9D"><span class="toc-number">8.7.2.</span> <span class="toc-text">2. 熔断 (Circuit Breaking) —— “家里的保险丝”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B5%81%E9%87%8F%E7%AE%A1%E6%8E%A7-Traffic-Control-Governance-%E2%80%94%E2%80%94-%E2%80%9C%E4%BA%A4%E8%AD%A6%E6%8C%87%E6%8C%A5%E4%BA%A4%E9%80%9A%E2%80%9D"><span class="toc-number">8.7.3.</span> <span class="toc-text">3. 流量管控 (Traffic Control &#x2F; Governance) —— “交警指挥交通”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">8.7.4.</span> <span class="toc-text">💡 三者对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E9%99%8D%E7%BA%A7%E2%80%9D-Fallback-%EF%BC%9F"><span class="toc-number">8.7.5.</span> <span class="toc-text">4. 什么是“降级” (Fallback)？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%92%8CDevOps%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">Linux和DevOps工程师面试题库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Linux系统类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Linux系统的启动过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.</span> <span class="toc-text">工作中常使用的Linux命令有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BCPU%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E7%A3%81%E7%9B%98%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.3.</span> <span class="toc-text">查看CPU、内存、磁盘、进程的Linux命令有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVM%E6%89%A9%E5%B1%95%E6%A0%B9%E5%88%86%E5%8C%BA%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">LVM扩展根分区的过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE7%E5%A4%A9%E5%89%8D%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">如何查找7天前修改的文件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E5%A4%A7%E4%BA%8E10M%E5%B0%8F%E4%BA%8E100M%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">如何查找文件大小大于10M小于100M的文件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0-tmp"><span class="toc-number">1.7.</span> <span class="toc-text">如何查找属于某个用户的文件，并复制到&#x2F;tmp?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%85%8D%E7%BD%AE%E8%BF%87%E5%93%AA%E4%BA%9BLinux%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text">工作中配置过哪些Linux系统优化?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell%E8%84%9A%E6%9C%AC%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Shell脚本类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">2.1.</span> <span class="toc-text">$?代表什么意思?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-1-N%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">2.2.</span> <span class="toc-text">$@和$1..$N代表什么意思?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">shell中如何获取字符串的长度?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%88%AA%E5%8F%96%E4%B8%80%E6%AE%B5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.4.</span> <span class="toc-text">如何截取一段字符串?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E4%B8%AD%E9%83%BD%E6%9C%89%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.5.</span> <span class="toc-text">shell中都有用过哪些循环?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">shell中什么是函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%88%B0%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2"><span class="toc-number">2.7.</span> <span class="toc-text">shell脚本的参数如何传递到函数里面?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.8.</span> <span class="toc-text">shell中如何并发执行代码块?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%B1%BB-1"><span class="toc-number">3.</span> <span class="toc-text">网络类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">TCP和UDP协议区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">OSI七层网络模型?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">TCP的三次握手和四次挥手过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E7%AB%99%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E9%94%AE%E8%83%8C%E5%90%8E%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.</span> <span class="toc-text">在浏览器中输入网站按下回车键背后发生什么?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E7%B1%BB-1"><span class="toc-number">4.</span> <span class="toc-text">虚拟化技术类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">怎么理解容器和虚拟化?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-run%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">Docker run常见参数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.3.</span> <span class="toc-text">Dockerfile关键字?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY%E5%92%8CADD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">COPY和ADD的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD%E5%92%8CENTRYPOINT%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.</span> <span class="toc-text">CMD和ENTRYPOINT的区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B1%BB-1"><span class="toc-number">5.</span> <span class="toc-text">中间件类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">解释反向代理和正向代理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">Mysql数据库如何优化?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">Nginx如何优化?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">5.4.</span> <span class="toc-text">Mysql内连接、左连接、右连接是什么意思?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1%E5%AE%8C%E6%95%B4%E5%86%85%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.5.</span> <span class="toc-text">一条完整内连接查询语句?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">Mysql主从复制原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">5.7.</span> <span class="toc-text">ES的倒排索引是怎么做的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%9A%84%E5%88%86%E7%89%87%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">5.8.</span> <span class="toc-text">ES的分片有什么作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%9A%84%E5%89%AF%E6%9C%AC%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">5.9.</span> <span class="toc-text">ES的副本有什么作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E4%B8%AD%E7%B4%A2%E5%BC%95%E5%92%8C%E6%96%87%E6%A1%A3%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.10.</span> <span class="toc-text">ES中索引和文档的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prometheus%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">5.11.</span> <span class="toc-text">Prometheus的架构?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.12.</span> <span class="toc-text">Nginx负载均衡算法有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.13.</span> <span class="toc-text">Nginx的状态码有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.14.</span> <span class="toc-text">Redis持久化方式有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.15.</span> <span class="toc-text">Mysql有哪些高可用解决方案?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.16.</span> <span class="toc-text">Redis高可用解决方案有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MYSQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">5.17.</span> <span class="toc-text">MYSQL增删改查关键字和表操作?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.18.</span> <span class="toc-text">Redis哨兵模式和集群模式有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EFK-ELK%E7%9A%84%E6%9E%B6%E6%9E%84%E7%BB%86%E8%8A%82"><span class="toc-number">5.19.</span> <span class="toc-text">EFK&#x2F;ELK的架构细节?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES%E7%9A%84%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.20.</span> <span class="toc-text">ES的常见使用场景?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">Kubernetes类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K8S%E6%8E%A7%E5%88%B6%E9%9D%A2%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9D%A2%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">K8S控制面和工作面的组件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubectl-run-mypod-image-nginx-latest-port-80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">6.2.</span> <span class="toc-text">kubectl run mypod -image nginx:latest -port 80后发生什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.3.</span> <span class="toc-text">Pod生命周期?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.4.</span> <span class="toc-text">Pod启动失败的原因?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E7%BD%91%E7%BB%9C%E3%80%81Svc%E7%BD%91%E7%BB%9C%E3%80%81%E8%8A%82%E7%82%B9%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%91"><span class="toc-number">6.5.</span> <span class="toc-text">Pod网络、Svc网络、节点网络流向?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calico%E7%BD%91%E7%BB%9C%E5%92%8CFlannel%E7%BD%91%E7%BB%9C%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">Calico网络和Flannel网络区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DevOps%E7%B1%BB-1"><span class="toc-number">7.</span> <span class="toc-text">DevOps类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3DevOps%E3%80%81CI-CD%E3%80%81Jenkins"><span class="toc-number">7.1.</span> <span class="toc-text">怎么理解DevOps、CI&#x2F;CD、Jenkins?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AF%B4%E8%AF%B4CI%E5%92%8CCD%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.2.</span> <span class="toc-text">具体说说CI和CD的理解?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E9%85%8D%E7%BD%AEPipeline%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">详细说配置Pipeline的过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jenkins%E9%85%8D%E7%BD%AEGitlab%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91%E7%BC%96%E8%AF%91"><span class="toc-number">7.4.</span> <span class="toc-text">Jenkins配置Gitlab自动触发编译?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jenkins%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">7.5.</span> <span class="toc-text">Jenkins插件安装失败如何解决?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E7%B1%BB-1"><span class="toc-number">8.</span> <span class="toc-text">综合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K8S%E4%B8%AD%E4%BD%BF%E7%94%A8Ingress%E6%9A%B4%E9%9C%B2%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="toc-number">8.1.</span> <span class="toc-text">K8S中使用Ingress暴露的应用不能访问如何排查?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91"><span class="toc-number">8.2.</span> <span class="toc-text">若依项目微服务数据流向?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="toc-number">8.3.</span> <span class="toc-text">服务不能访问如何排查?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%A5%E4%BE%9D%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E5%92%8C%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88%E5%8F%8A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AF%B9%E6%8E%A5"><span class="toc-number">8.4.</span> <span class="toc-text">若依项目后端和前端技术栈及前后端对接?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">8.5.</span> <span class="toc-text">阿里云产品使用情况?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%91%E8%A3%82"><span class="toc-number">8.6.</span> <span class="toc-text">什么是脑裂?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAFT%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%84%91%E8%A3%82"><span class="toc-number">8.7.</span> <span class="toc-text">RAFT算法如何避免脑裂?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%B8%80%E5%A4%A9%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">8.8.</span> <span class="toc-text">运维工程师的一天主要做什么?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B1%BB-1"><span class="toc-number">9.</span> <span class="toc-text">微服务类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8B%A5%E4%BE%9D%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">若依微服务项目中使用的技术及作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%86%94%E6%96%AD"><span class="toc-number">9.2.</span> <span class="toc-text">微服务中什么是熔断?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%99%90%E6%B5%81"><span class="toc-number">9.3.</span> <span class="toc-text">什么是限流?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%E9%87%8F%E7%AE%A1%E6%8E%A7"><span class="toc-number">9.4.</span> <span class="toc-text">什么是流量管控?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B%E7%AE%80%E5%8E%86-%E6%95%B4%E5%90%88"><span class="toc-number"></span> <span class="toc-text">B简历-整合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%8F%B8%E8%83%8C%E6%99%AF%E8%B0%83%E7%A0%94"><span class="toc-number">1.</span> <span class="toc-text">公司背景调研</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">一、自我介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">二、最近项目介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%80%EF%BC%9AHIS%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">项目一：HIS系统分布式平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BA%8C%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%85%AC%E6%9C%89%E4%BA%91-%E7%89%A9%E8%81%94%E7%BD%91%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">项目二：设备管理平台（公有云&#x2F;物联网场景）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%A1%B9%E7%9B%AE%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">三、项目详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%80%EF%BC%9AHIS%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.1.</span> <span class="toc-text">项目一：HIS系统分布式平台建设项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF%E4%B8%8E%E4%B8%9A%E5%8A%A1%E8%A7%84%E6%A8%A1%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8C%96%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 项目背景与业务规模（数据化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B4%E4%BD%93%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%BA%90%E8%A7%84%E5%88%92%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E7%89%A9%E7%90%86%E6%9C%BA-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 整体硬件资源规划与配置（物理机&#x2F;虚拟机）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Spring-Cloud-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%8B%86%E8%A7%A3"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. Spring Cloud 微服务模块拆解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E4%B8%8E%E8%BF%90%E7%BB%B4%E5%8A%A8%E4%BD%9C-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 关键技术细节与运维动作 (面试高频)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%85%B7%E4%BD%93%E6%8C%91%E6%88%98%E4%B8%8E%E8%A7%A3%E5%86%B3-Storytelling"><span class="toc-number">3.1.5.</span> <span class="toc-text">5. 项目中的具体挑战与解决 (Storytelling)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BA%8C%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E4%BA%91%E5%8E%9F%E7%94%9F%E6%94%B9%E9%80%A0"><span class="toc-number">3.2.</span> <span class="toc-text">项目二：设备管理平台云原生改造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF%E4%B8%8E%E4%B8%9A%E5%8A%A1%E8%A7%84%E6%A8%A1%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8C%96%EF%BC%89-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 项目背景与业务规模（数据化）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%91%E8%B5%84%E6%BA%90%E8%A7%84%E5%88%92%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91-ACK-%E7%8E%AF%E5%A2%83%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 云资源规划与配置（阿里云 ACK 环境）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%8B%86%E8%A7%A3%EF%BC%88IoT-%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 微服务模块拆解（IoT 场景）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9E%B6%E6%9E%84%E6%8B%93%E6%89%91%E5%9B%BE%E6%8F%8F%E8%BF%B0%EF%BC%88%E9%9D%A2%E8%AF%95%E7%94%BB%E5%9B%BE%E7%94%A8%EF%BC%89"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. 架构拓扑图描述（面试画图用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E4%B8%8E%E8%BF%90%E7%BB%B4%E4%BA%AE%E7%82%B9%EF%BC%88%E9%92%88%E5%AF%B9%E7%AE%80%E5%8E%86%E5%86%85%E5%AE%B9%EF%BC%89"><span class="toc-number">3.2.5.</span> <span class="toc-text">5. 关键技术细节与运维亮点（针对简历内容）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%8F%AF%E8%83%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%EF%BC%88%E9%92%88%E5%AF%B9%E6%AD%A4%E9%A1%B9%E7%9B%AE%EF%BC%89"><span class="toc-number">3.2.6.</span> <span class="toc-text">6. 可能的面试追问（针对此项目）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%A4%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E6%97%B6%E5%BF%83%E4%B8%AD%E8%A6%81%E6%9C%89%E6%95%B0%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">总结：两个项目的区别（面试时心中要有数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">四、项目难点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%80%EF%BC%9AHIS-%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B8%83%E5%BC%8F%E5%B9%B3%E5%8F%B0%E5%BB%BA%E8%AE%BE%E9%A1%B9%E7%9B%AE"><span class="toc-number">4.1.</span> <span class="toc-text">项目一：HIS 系统分布式平台建设项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9-1%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E2%80%9C%E6%B5%81%E9%87%8F%E6%8D%9F%E8%80%97%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%88502-Bad-Gateway%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">难点 1：微服务滚动更新时的“流量损耗”问题（502 Bad Gateway）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9-2%EF%BC%9A%E6%97%A9%E9%AB%98%E5%B3%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E2%80%9C%E9%9B%AA%E5%B4%A9%E2%80%9D%E6%95%88%E5%BA%94"><span class="toc-number">4.1.2.</span> <span class="toc-text">难点 2：早高峰数据库连接池“雪崩”效应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BA%8C%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E4%BA%91%E5%8E%9F%E7%94%9F%E6%94%B9%E9%80%A0-1"><span class="toc-number">4.2.</span> <span class="toc-text">项目二：设备管理平台云原生改造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9-1%EF%BC%9ASidecar-%E5%AE%B9%E5%99%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E2%80%9C%E5%B9%BD%E7%81%B5%E2%80%9D-OOM-OOM-Killer-%E8%AF%AF%E6%9D%80"><span class="toc-number">4.2.1.</span> <span class="toc-text">难点 1：Sidecar 容器导致的“幽灵” OOM (OOM-Killer 误杀)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9-2%EF%BC%9A%E8%A7%A3%E5%86%B3-IoT-%E8%AE%BE%E5%A4%87%E2%80%9C%E6%83%8A%E7%BE%A4%E2%80%9D%E6%95%88%E5%BA%94%E5%AF%BC%E8%87%B4%E7%9A%84-HPA-%E6%89%A9%E5%AE%B9%E6%BB%9E%E5%90%8E"><span class="toc-number">4.2.2.</span> <span class="toc-text">难点 2：解决 IoT 设备“惊群”效应导致的 HPA 扩容滞后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E8%A7%86%E8%A7%92%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%BC%9A%E8%AE%A9%E6%88%91%E2%80%9C%E7%9C%BC%E5%89%8D%E4%B8%80%E4%BA%AE%E2%80%9D%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">面试官视角：为什么这会让我“眼前一亮”？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">五、可能会问的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%EF%BC%9A%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%8F%E8%A7%82%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%80%83%E5%AF%9F%E4%BD%A0%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%85%A8%E8%B2%8C%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">第一类：架构与宏观设计（考察你是否真的理解全貌）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%EF%BC%9AKubernetes-%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%88%E8%80%83%E5%AF%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E8%83%BD%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">第二类：Kubernetes 与容器化（考察核心技能）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%B1%BB%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88%E8%80%83%E5%AF%9F%E4%B8%9A%E5%8A%A1%E4%BF%9D%E9%9A%9C%E8%83%BD%E5%8A%9B%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">第三类：数据库与数据一致性（考察业务保障能力）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%B1%BB%EF%BC%9A%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%97%A5%E5%BF%97%EF%BC%88%E8%80%83%E5%AF%9F%E8%BF%90%E7%BB%B4%E6%95%8F%E6%84%9F%E5%BA%A6%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">第四类：监控与日志（考察运维敏感度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%B1%BB%EF%BC%9ACI-CD-%E4%B8%8E-%E8%84%9A%E6%9C%AC%EF%BC%88%E8%80%83%E5%AF%9F%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">第五类：CI&#x2F;CD 与 脚本（考察效率工具）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%B1%BB%EF%BC%9A%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%83%85%E6%99%AF%E9%A2%98%EF%BC%88%E7%BB%88%E6%9E%81%E8%80%83%E9%AA%8C%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">第六类：压力测试与情景题（终极考验）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E6%9C%B1%E9%91%AB%E7%83%A8%E7%9A%84%E5%A4%87%E6%88%98%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">5.7.</span> <span class="toc-text">给朱鑫烨的备战建议：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BB%B4%E5%BA%A6%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9F%E4%B8%8EKubernetes%E5%AE%9E%E6%88%98%EF%BC%88%E6%A0%B8%E5%BF%83%E8%80%83%E5%AF%9F%E7%82%B9%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">第一维度：云原生与Kubernetes实战（核心考察点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BB%B4%E5%BA%A6%EF%BC%9A%E9%98%BF%E9%87%8C%E4%BA%91%E4%BA%A7%E5%93%81%E4%B8%8E%E7%BD%91%E7%BB%9C%EF%BC%88%E7%8E%AF%E5%A2%83%E7%86%9F%E6%82%89%E5%BA%A6%EF%BC%89"><span class="toc-number">5.9.</span> <span class="toc-text">第二维度：阿里云产品与网络（环境熟悉度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%BB%B4%E5%BA%A6%EF%BC%9AIoT-%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%EF%BC%88%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%83%BD%E5%8A%9B%EF%BC%89"><span class="toc-number">5.10.</span> <span class="toc-text">第三维度：IoT 业务场景与故障排查（解决问题能力）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%BB%B4%E5%BA%A6%EF%BC%9A%E5%BC%80%E6%94%BE%E6%80%A7-%E8%BD%AF%E6%8A%80%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%88%E6%80%81%E5%BA%A6%E4%B8%8E%E6%BD%9C%E5%8A%9B%EF%BC%89"><span class="toc-number">5.11.</span> <span class="toc-text">第四维度：开放性&#x2F;软技能问题（态度与潜力）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E8%BF%99%E9%87%8C%E7%9A%84%E2%80%9C%E5%BF%85%E6%9D%80%E6%8A%80%E2%80%9D%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">5.12.</span> <span class="toc-text">💡 这里的“必杀技”建议：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92"><span class="toc-number">6.</span> <span class="toc-text">职业规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number"></span> <span class="toc-text">技术关键词</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/18/CI%20CD%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90Ruo-Yi%E9%A1%B9%E7%9B%AE/" title="CI/CD持续集成Ruo-Yi项目">CI/CD持续集成Ruo-Yi项目</a><time datetime="2025-12-18T11:27:44.000Z" title="Created 2025-12-18 19:27:44">2025-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/17/Kubernets-network_rbac_hpa/" title="Kubernetes 网络、RBAC 和 HPA 相关知识">Kubernetes 网络、RBAC 和 HPA 相关知识</a><time datetime="2025-12-17T10:34:40.000Z" title="Created 2025-12-17 18:34:40">2025-12-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/16/Kubernetes-Ingress%E6%9C%8D%E5%8A%A1/" title="Kubernetes-Ingress服务">Kubernetes-Ingress服务</a><time datetime="2025-12-16T10:12:58.000Z" title="Created 2025-12-16 18:12:58">2025-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/16/Kubernetes%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="Kubernetes存储管理">Kubernetes存储管理</a><time datetime="2025-12-16T01:35:04.000Z" title="Created 2025-12-16 09:35:04">2025-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/15/Kubernetes%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" title="Kubernetes 配置资源管理">Kubernetes 配置资源管理</a><time datetime="2025-12-15T02:54:40.000Z" title="Created 2025-12-15 10:54:40">2025-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/imgs/background_footer.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Felix</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>