<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker--草稿 | Felix的个人博客</title><meta name="author" content="Felix"><meta name="copyright" content="Felix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker一、初识Docker 容器：一个轻量级、独立且可执行的包，包含运行软件所需的一切。 镜像：将其视为容器的模板或蓝图。它包含创建容器所需的所有说明。 Docker Hub：与 GitHub 类似，但对于 Docker 镜像 - 您可以在其中查找和共享容器镜像。 Docker 引擎：在机器上运行和管理容器的核心技术。  下面是一个简单的图表，可帮助可视化这些概念如何协同工作：  此图显示：">
<meta property="og:type" content="article">
<meta property="og:title" content="docker--草稿">
<meta property="og:url" content="http://example.com/2025/10/28/docker/index.html">
<meta property="og:site_name" content="Felix的个人博客">
<meta property="og:description" content="Docker一、初识Docker 容器：一个轻量级、独立且可执行的包，包含运行软件所需的一切。 镜像：将其视为容器的模板或蓝图。它包含创建容器所需的所有说明。 Docker Hub：与 GitHub 类似，但对于 Docker 镜像 - 您可以在其中查找和共享容器镜像。 Docker 引擎：在机器上运行和管理容器的核心技术。  下面是一个简单的图表，可帮助可视化这些概念如何协同工作：  此图显示：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/imgs/adater.jpg">
<meta property="article:published_time" content="2025-10-28T00:54:40.000Z">
<meta property="article:modified_time" content="2025-11-07T06:01:26.575Z">
<meta property="article:author" content="Felix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/adater.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker--草稿",
  "url": "http://example.com/2025/10/28/docker/",
  "image": "http://example.com/imgs/adater.jpg",
  "datePublished": "2025-10-28T00:54:40.000Z",
  "dateModified": "2025-11-07T06:01:26.575Z",
  "author": [
    {
      "@type": "Person",
      "name": "Felix",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/10/28/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker--草稿',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/imgs/background_header.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Felix的个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">docker--草稿</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">docker--草稿</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-10-28T00:54:40.000Z" title="Created 2025-10-28 08:54:40">2025-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-07T06:01:26.575Z" title="Updated 2025-11-07 14:01:26">2025-11-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、初识Docker"><a href="#一、初识Docker" class="headerlink" title="一、初识Docker"></a>一、初识Docker</h2><ol>
<li><strong>容器</strong>：一个轻量级、独立且可执行的包，包含运行软件所需的一切。</li>
<li><strong>镜像</strong>：将其视为容器的模板或蓝图。它包含创建容器所需的所有说明。</li>
<li><strong>Docker Hub</strong>：与 GitHub 类似，但对于 Docker 镜像 - 您可以在其中查找和共享容器镜像。</li>
<li><strong>Docker 引擎</strong>：在机器上运行和管理容器的核心技术。</li>
</ol>
<p>下面是一个简单的图表，可帮助可视化这些概念如何协同工作：</p>
<p><img src="/./imgs/image-20251028085807302.png" alt="image-20251028085807302"></p>
<p>此图显示：</p>
<ul>
<li>Docker 引擎运行容器</li>
<li>镜像用于创建容器</li>
<li>Docker Hub 存储镜像</li>
<li>Docker 引擎可以从 Docker Hub 拉取镜像，并将镜像推送到 Docker Hub</li>
</ul>
<h3 id="1-1-运行容器"><a href="#1-1-运行容器" class="headerlink" title="1.1 运行容器"></a>1.1 运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028090258818.png" alt="image-20251028090258818"></p>
<blockquote>
<p>让我们分解一下这个命令的作用：</p>
<p>docker：这是与 Docker 引擎交互的命令。<br>run：此子命令告诉 Docker 创建并启动一个新容器。<br>hello-world：这是我们要运行的镜像的名称。<br>运行此命令时，后台会发生几件事：</p>
<p>Docker 检查映像是否在本地可用。hello-world<br>如果没有，它会自动从 Docker Hub 下载（或“拉取”）映像。<br>Docker 基于此镜像创建一个新容器。<br>容器运行，显示消息，然后退出。</p>
</blockquote>
<p>此输出解释了 Docker 运行容器所经历的过程。让我们来分解一下：<code>hello-world</code></p>
<ol>
<li>Docker 客户端（您运行的命令）联系了 Docker 守护程序（管理计算机上 Docker 的后台服务）。</li>
<li>守护程序从 Docker Hub 中提取了“hello-world”映像，因为它在本地不可用。</li>
<li>守护程序从该镜像创建一个新容器并运行它。</li>
<li>集装箱的输出已发送回您的终端。</li>
</ol>
<p><strong>查看正在运行的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028092927589.png" alt="image-20251028092927589"></p>
<h3 id="1-2-查看本地可用镜像"><a href="#1-2-查看本地可用镜像" class="headerlink" title="1.2 查看本地可用镜像"></a>1.2 查看本地可用镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028090712123.png" alt="image-20251028090712123"></p>
<blockquote>
<p>让我们分解一下每列的含义：</p>
<ul>
<li><code>REPOSITORY</code>：镜像的名称。在本例中，它是“hello-world”。</li>
<li><code>TAG</code>：镜像的版本。如果未指定“latest”，则为默认标记。</li>
<li><code>IMAGE ID</code>：镜像的唯一标识符。当需要引用特定镜像时，这很有用。</li>
<li><code>CREATED</code>：创建镜像的时间。这可以帮助了解是否拥有最新版本。</li>
<li><code>SIZE</code>：磁盘上镜像的大小。Docker 镜像被设计为轻量级，这就是为什么 hello-world 镜像只有 13.3kB 的原因。</li>
</ul>
</blockquote>
<p>该镜像现在存储在本地系统上。这意味着，如果再次运行，Docker 将不需要从 Docker Hub 下载镜像。它将使用本地副本，使过程更快。<code>hello-world``docker run hello-world</code></p>
<h3 id="1-3-Docker-Hub"><a href="#1-3-Docker-Hub" class="headerlink" title="1.3 Docker Hub"></a>1.3 Docker Hub</h3><p>Docker Hub 是一种基于云的注册表服务，Docker 用户和组织可以在其中存储和分发他们的 Docker 映像。它就像 Docker 镜像的 GitHub，充当中央存储库，您可以在其中查找、共享和管理 Docker 镜像。</p>
<p>比如搜索hello word的镜像</p>
<p><img src="/./imgs/image-20251028091242761.png" alt="image-20251028091242761"></p>
<blockquote>
<p>在图片页面，您可以看到：</p>
<ul>
<li>镜像描述</li>
<li>使用说明</li>
<li>镜像的拉取（下载）次数</li>
<li>可用的标签（版本）</li>
</ul>
<p>Docker Hub 是 Docker 在运行命令时查找镜像的地方，并且该镜像在本地不可用。这就是为什么即使您事先没有显式下载镜像，也能够运行 hello-world 容器。<code>docker run</code></p>
</blockquote>
<p>关于 Docker Hub 的一些要点：</p>
<ol>
<li><strong>官方图片</strong>：这些由 Docker 策划，通常维护良好并记录在案。对于初学者来说，它们是一个不错的选择。</li>
<li><strong>标签</strong>：镜像可以有多个版本，称为标签。例如，您可能会看到“latest”、“1.0”、“2.1”等标签。当您不指定标签时（就像我们所做的那样），Docker 会假设您需要“latest”标签。<code>docker run hello-world</code></li>
<li><strong>拉取命令</strong>：在每个镜像的页面上，您会看到一个“拉取命令”。这是您用来手动下载镜像而不运行容器的方法。 例如：<code>docker pull hello-world</code></li>
<li><strong>Dockerfile</strong>：Docker Hub 上的许多镜像都会有一个指向其 Dockerfile 的链接，这是用于构建镜像的脚本。如果您想了解图像是如何创建的，这会很有帮助。</li>
</ol>
<h2 id="二、使用docker镜像"><a href="#二、使用docker镜像" class="headerlink" title="二、使用docker镜像"></a>二、使用docker镜像</h2><h3 id="2-1-从Docker-Hub拉取镜像并使用"><a href="#2-1-从Docker-Hub拉取镜像并使用" class="headerlink" title="2.1 从Docker Hub拉取镜像并使用"></a>2.1 从Docker Hub拉取镜像并使用</h3><h4 id="①从Docker-Hub拉取镜像"><a href="#①从Docker-Hub拉取镜像" class="headerlink" title="①从Docker Hub拉取镜像"></a>①从Docker Hub拉取镜像</h4><p>例如拉取nginx的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028093831685.png" alt="image-20251028093831685"></p>
<blockquote>
<p>让我们来分析一下这里发生的事情：</p>
<ol>
<li>“使用默认标记：latest” - 未指定版本时，Docker 会假定需要最新版本。</li>
<li>接下来的几行显示 Docker 下载映像的不同“层”。每一层代表一组文件系统更改。</li>
<li>“摘要”是此图像确切版本的唯一标识符。</li>
<li>最后一行确认图像已成功下载。</li>
</ol>
</blockquote>
<h4 id="②检查是否下载成功"><a href="#②检查是否下载成功" class="headerlink" title="②检查是否下载成功"></a>②检查是否下载成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028094035022.png" alt="image-20251028094035022"></p>
<h4 id="③运行容器"><a href="#③运行容器" class="headerlink" title="③运行容器"></a>③运行容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run nginx</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>要在启动 Docker 容器时在 Docker 容器内运行命令</strong></p>
<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run docker/whalesay cowsay <span class="string">&quot;Ahoy, Docker&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-运行不同版本的镜像"><a href="#2-2-运行不同版本的镜像" class="headerlink" title="2.2 运行不同版本的镜像"></a>2.2 运行不同版本的镜像</h3><p>以python为例</p>
<p><strong>拉取最新python镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull python</span><br></pre></td></tr></table></figure>

<p><strong>拉取特定版本的python</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull python:3.7</span><br></pre></td></tr></table></figure>

<p><strong>查看你不同版本的镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images python</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028094847773.png" alt="image-20251028094847773"></p>
<p><strong>运行不同版本镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> python:latest python --version</span><br><span class="line">docker run python:3.7 python --version</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028095225041.png" alt="image-20251028095225041"></p>
<h3 id="2-3-列出和删除镜像"><a href="#2-3-列出和删除镜像" class="headerlink" title="2.3 列出和删除镜像"></a>2.3 列出和删除镜像</h3><p><strong>列出所有镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028100834157.png" alt="image-20251028100834157"></p>
<p><strong>删除镜像</strong> </p>
<p><strong>docker rmi 镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi python:3.7</span><br></pre></td></tr></table></figure>

<p>由于python3.7正在运行，无法删除</p>
<p><img src="/./imgs/image-20251028101609538.png" alt="image-20251028101609538"></p>
<p><strong>删除容器</strong></p>
<p><strong>docker rm 容器id</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器id</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028101740950.png" alt="image-20251028101740950"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> d8f040176404</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028102006926.png" alt="image-20251028102006926"></p>
<p><strong>删除容器后，即可对镜像删除</strong></p>
<p><img src="/./imgs/image-20251028103312831.png" alt="image-20251028103312831"></p>
<p><img src="/./imgs/image-20251028103342815.png" alt="image-20251028103342815"></p>
<p>可以看见，已经没有python3.7的镜像了</p>
<h3 id="2-4-镜像图层"><a href="#2-4-镜像图层" class="headerlink" title="2.4 镜像图层"></a>2.4 镜像图层</h3><p>Docker 镜像是使用分层文件系统构建的。每一层代表一组文件系统更改。这种分层方法使 Docker 能够高效地使用存储和网络。</p>
<p><strong><code>docker inspect</code> 命令用于获取 Docker 对象（容器、镜像、卷、网络等）的详细信息。</strong></p>
<p><strong><code>docker inspect</code> 命令返回 JSON 格式的详细信息，可以帮助用户了解对象的配置和状态。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.RootFS.Layers&#125;&#125;&#x27;</span> nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028104830282.png" alt="image-20251028104830282"></p>
<p>这些长字符串中的每一个（称为 SHA256 哈希）都代表图像中的一个层。每一层对应于 Dockerfile 中用于构建映像的命令。</p>
<p>为了更好地理解图层，让我们创建一个简单的自定义图像。首先，创建一个在当前目录中命名的新文件：<code>Dockerfile</code></p>
<p>在文件中添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &quot;Hello from custom layer&quot; &gt; /usr/share/nginx/html/hello.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 Dockerfile 做两件事：</p>
<ol>
<li>它从我们之前拉取的 Nginx 镜像（<code>FROM nginx</code>)</li>
<li>它向图像（<code>RUN echo...</code>)</li>
</ol>
</blockquote>
<p><strong>构建镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t custom-nginx ./</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028104547406.png" alt="image-20251028104547406"></p>
<p>此命令基于我们的 Dockerfile 构建一个新镜像，并将其标记为 .末尾的 告诉 Docker 在当前目录中查找 Dockerfile。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.RootFS.Layers&#125;&#125;&#x27;</span> custom-nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028104814789.png" alt="image-20251028104814789"></p>
<p>此镜像比原始 Nginx 镜像多一层。这个附加层表示我们的命令所做的更改。<code>RUN</code></p>
<p>了解层至关重要，因为：</p>
<ol>
<li>缓存图层，加快相似图像的构建速度</li>
<li>图层在镜像之间共享，节省磁盘空间</li>
<li>推送或拉取镜像时，只需传输更改的图层</li>
</ol>
<h3 id="2-5-在-Docker-Hub-上搜索镜像"><a href="#2-5-在-Docker-Hub-上搜索镜像" class="headerlink" title="2.5 在 Docker Hub 上搜索镜像"></a>2.5 在 Docker Hub 上搜索镜像</h3><p>Docker Hub 托管大量镜像。虽然您可以在 Docker Hub 网站上搜索镜像，但 Docker 还提供了一个命令行工具，可以<strong>直接从终端搜索镜像</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028105517205.png" alt="image-20251028105517205"></p>
<blockquote>
<p>这将返回与 Nginx 相关的图像列表。输出包括几列：</p>
<ul>
<li>NAME：图像的名称</li>
<li>描述：图像的简要描述</li>
<li>STARS：映像在 Docker Hub 上的星数（表示受欢迎程度）</li>
<li>官方：这是否是 Docker 维护的官方镜像</li>
<li>AUTOMATED：此映像是否从 GitHub 存储库自动生成</li>
</ul>
</blockquote>
<p><strong>注意：</strong></p>
<p>Docker 搜索不支持搜索特定标签（如 3.8）。相反，它将搜索名称或描述中带有“python：3.8”的镜像。</p>
<p>要查找镜像的特定版本，通常最好：</p>
<ol>
<li>搜索通用镜像名称（例如<code>docker search python</code>)</li>
<li>访问 Docker Hub 网站了解更多详细信息</li>
<li>用于下载镜像，然后在本地检查它<code>docker pull</code></li>
</ol>
<p>请记住，docker search是查找镜像的快速方法，但要获取更多详细信息，Docker Hub 网站通常更有用。</p>
<h3 id="2-6-保存和加载镜像"><a href="#2-6-保存和加载镜像" class="headerlink" title="2.6 保存和加载镜像"></a>2.6 保存和加载镜像</h3><p>Docker 允许您将映像保存为 tar 文件并稍后加载它们。这对于在不使用注册表的情况下在系统之间传输映像或备份映像非常有用。</p>
<p><strong>将镜像保存到文件中</strong>save</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save nginx &gt; nginx.tar</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028111130263.png" alt="image-20251028111130263"></p>
<p>此命令将 Nginx 映像保存到当前目录中命名的文件中。该符号用于将命令的输出重定向到文件。<code>nginx.tar``&gt;``docker save</code></p>
<p><strong>模拟没有该镜像(删除)</strong></p>
<p><img src="/./imgs/image-20251028111318973.png" alt="image-20251028111318973"></p>
<p><strong>加载镜像</strong>load</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; nginx.tar</span><br></pre></td></tr></table></figure>

<p>&lt;该符号用于将文件的内容重定向为命令的输入。</p>
<p><img src="/./imgs/image-20251028111635309.png" alt="image-20251028111635309"></p>
<p><img src="/./imgs/image-20251028111656697.png" alt="image-20251028111656697"></p>
<p>保存和加载图像的过程非常有用：</p>
<ul>
<li>将图像传输到无法访问互联网的系统</li>
<li>备份特定版本的映像</li>
<li>与他人共享自定义映像，无需使用注册表</li>
</ul>
<h3 id="2-7-镜像标记基础知识"><a href="#2-7-镜像标记基础知识" class="headerlink" title="2.7 镜像标记基础知识"></a>2.7 镜像标记基础知识</h3><p>标记是一种为 Docker 映像创建别名的方法。它通常用于版本控制和组织图像。</p>
<p><strong>为镜像创建标签</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest my-nginx:v1</span><br></pre></td></tr></table></figure>

<p>此命令创建一个新标记，该标记指向与nginx:latest相同的镜像。</p>
<blockquote>
<ul>
<li><code>nginx:latest</code>是源图像和标签</li>
<li><code>my-nginx</code>是我们正在创建的新镜像名称</li>
<li><code>v1</code>是我们分配的新标签</li>
</ul>
</blockquote>
<p><img src="/./imgs/image-20251028112146618.png" alt="image-20251028112146618"></p>
<p>在列表中看到nginx:latest和my-nginx:v1。请注意，它们具有相同的镜像 ID - 这是因为它们实际上是相同的镜像，只是名称不同。</p>
<p><strong>使用标签来运行容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-nginx-container my-nginx:v1</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028112254291.png" alt="image-20251028112254291"></p>
<blockquote>
<p>此命令执行以下作：</p>
<ul>
<li><code>-d</code>以分离模式运行容器（在后台）</li>
<li><code>--name my-nginx-container</code>为我们的新容器命名</li>
<li><code>my-nginx:v1</code>是我们用于创建容器的图像和标签</li>
</ul>
</blockquote>
<p><img src="/./imgs/image-20251028112342999.png" alt="image-20251028112342999"></p>
<p>标记很有用，原因如下：</p>
<ol>
<li>版本控制：您可以使用版本号（v1、v2 等）标记图像</li>
<li>环境分离：可以标记不同环境（开发、暂存、生产）的映像</li>
<li>可读性：自定义标签可以更清楚地表明图像的用途</li>
</ol>
<p>请记住，标签只是别名 - 它们不会创建新图像，它们只是创建指向现有图像的新名称。</p>
<h2 id="三、docker进阶"><a href="#三、docker进阶" class="headerlink" title="三、docker进阶"></a>三、docker进阶</h2><h3 id="3-1-以不同模式运行容器"><a href="#3-1-以不同模式运行容器" class="headerlink" title="3.1 以不同模式运行容器"></a>3.1 以不同模式运行容器</h3><p>Docker 允许以不同的模式运行容器以适应各种用例。</p>
<p><strong>两种常见模式：分离模式和交互模式。</strong></p>
<p>在<strong>分离模式</strong>下运行容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-detached nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028151933399.png" alt="image-20251028151933399"></p>
<blockquote>
<p>选项作用：</p>
<ul>
<li><code>-d</code>：以**分离模式（在后台）**运行容器</li>
<li><code>--name nginx-detached</code>：为容器分配名称“nginx-detached”</li>
<li><code>nginx</code>：指定要使用的镜像（如果本地不可用，则将从 Docker Hub 中提取镜像）</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器状态</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028152037390.png" alt="image-20251028152037390"></p>
<p>在<strong>交互模式</strong>下运行容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name ubuntu-interactive ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028152428177.png" alt="image-20251028152428177"></p>
<p>此命令执行以下操作：</p>
<ul>
<li><code>-it</code>：使用伪 TTY 以交互模式运行容器</li>
<li><code>--name ubuntu-interactive</code>：为容器分配名称“ubuntu-interactive”</li>
<li><code>ubuntu</code>：指定要使用的镜像</li>
<li><code>/bin/bash</code>：要在容器内运行的命令（在本例中为 bash shell）</li>
</ul>
<p><img src="/./imgs/image-20251028152440400.png" alt="image-20251028152440400"></p>
<h3 id="3-2-管理容器生命周期"><a href="#3-2-管理容器生命周期" class="headerlink" title="3.2 管理容器生命周期"></a>3.2 管理容器生命周期</h3><p><strong>停止容器 docker stop 容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docekr stop nginx-detached</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028152605461.png" alt="image-20251028152605461"></p>
<p><strong>打开容器</strong>start</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker start nginx-detached</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028152941776.png" alt="image-20251028152941776"></p>
<p><strong>重新启动容器</strong>restart</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启</span></span><br><span class="line">docker restart nginx-detached</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028153128968.png" alt="image-20251028153128968"></p>
<p><strong>删除容器</strong>rm</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> ubuntu-interactive</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028153308642.png" alt="image-20251028153308642"></p>
<p>可以看到ubuntu容器被删除</p>
<h3 id="3-3-查看容器的详细信息inspect"><a href="#3-3-查看容器的详细信息inspect" class="headerlink" title="3.3 查看容器的详细信息inspect"></a>3.3 查看容器的详细信息inspect</h3><p>Docker提供了命令<strong>inspect</strong>来价差容器的详细信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx-detached</span><br></pre></td></tr></table></figure>

<p>此命令输出一个 <strong>JSON 数组</strong>，其中包含有关容器的详细信息。</p>
<p><img src="/./imgs/image-20251028153619779.png" alt="image-20251028153619779"></p>
<p>可以使用选项&#x2F;过滤器等来获取特定信息</p>
<p>比如：</p>
<p><strong>获取容器的IP地址</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> nginx-detached</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028153931837.png" alt="image-20251028153931837"></p>
<blockquote>
<p><strong>命令结构：</strong></p>
<ul>
<li><code>docker inspect</code> — Docker 的检查命令，用于获取容器或镜像的详细信息</li>
<li><code>-f</code> — 指定输出格式（format 的缩写）</li>
<li><code>&#39;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39;</code> — <strong>Go 模板语法</strong>，定义输出格式</li>
<li><code>nginx-detached</code> — 容器名称或 ID</li>
</ul>
<p><strong>模板语法解析：</strong></p>
<ul>
<li><code>&#123;&#123;range .NetworkSettings.Networks&#125;&#125;</code> — 遍历容器的所有网络配置</li>
<li><code>&#123;&#123;.IPAddress&#125;&#125;</code> — 取出每个网络的 IP 地址</li>
<li><code>&#123;&#123;end&#125;&#125;</code> — 结束循环</li>
</ul>
<p><strong>执行结果：</strong> 运行这个命令会输出 <code>nginx-detached</code> 容器所连接的所有网络的 IP 地址。</p>
</blockquote>
<p><strong>查看容器的当前状态</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> nginx-detached</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028154156280.png" alt="image-20251028154156280"></p>
<p><strong>⭐检查端口映射port</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port nginx-detached</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>端口映射的作用</strong></p>
<p>端口映射是容器与外部通信的重要机制。它将主机系统上的端口关联到容器内的端口，使得外部网络可以访问容器内运行的服务。</p>
</blockquote>
<p><strong>在我们的例子中</strong></p>
<p>由于 nginx-detached 容器在创建时没有明确映射任何端口，所以即使容器内部运行了 nginx 服务，外部也无法直接访问。这时候某些显示端口信息的命令将不会产生输出。</p>
<p>为了演示端口映射,创建一个带有端口映射的新 Nginx 容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-with-port -p 8080:80 nginx</span><br></pre></td></tr></table></figure>

<p>此命令将主机上的端口 8080 映射到容器中的端口 80。</p>
<blockquote>
<p>-p指定端口映射</p>
</blockquote>
<p>现在我们再检查端口映射：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port nginx-with-port</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028154632055.png" alt="image-20251028154632055"></p>
<p>这意味着到主机上端口 8080 的流量将被转发到容器中的端口 80，Nginx 正在其中侦听。</p>
<h3 id="3-4-容器日志logs"><a href="#3-4-容器日志logs" class="headerlink" title="3.4 容器日志logs"></a>3.4 容器日志logs</h3><p><strong>查看容器日志docker logs</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 nginx 容器的日志</span></span><br><span class="line">docker logs nginx-detached</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028155103330.png" alt="image-20251028155103330"></p>
<p>这显示了从容器开始的所有日志。</p>
<p><strong>仅查看最新日志</strong>–tail</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示最后 10 行日志行</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 10 nginx-detached</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028155301089.png" alt="image-20251028155301089"></p>
<p><strong>实时跟踪日志</strong>-f(类似linux tail -f)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f nginx-detached</span><br></pre></td></tr></table></figure>

<p><strong>获取日志的时间戳</strong>–timestamps</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --timestamps nginx-detached</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028155550224.png" alt="image-20251028155550224"></p>
<p>这对于调试时间敏感的问题特别有用</p>
<h3 id="3-5-在正在运行的容器中执行命令exec"><a href="#3-5-在正在运行的容器中执行命令exec" class="headerlink" title="3.5 在正在运行的容器中执行命令exec"></a>3.5 在正在运行的容器中执行命令exec</h3><p>Docker 允许通过<strong>exec</strong>在正在运行的容器内执行命令，这对于调试和维护非常有用。</p>
<p><strong>在nginx容器中执行echo</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> nginx-detached <span class="built_in">echo</span> <span class="string">&quot;Hello from inside the container&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028155947029.png" alt="image-20251028155947029"></p>
<p><strong>在容器内获取一个交互式shell</strong>（-it interactive）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx-detached /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028160438357.png" alt="image-20251028160438357"></p>
<h3 id="3-6-将文件复制到容器或从容器复制文件"><a href="#3-6-将文件复制到容器或从容器复制文件" class="headerlink" title="3.6 将文件复制到容器或从容器复制文件"></a>3.6 将文件复制到容器或从容器复制文件</h3><p>Docker 提供了一种在主机系统和容器之间复制文件的方法。这对于更新配置文件或检索日志等任务非常有用。</p>
<p>在主机系统上创建一个简单的 HTML 文件，作为演示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from host&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span> &gt; hello.html</span><br></pre></td></tr></table></figure>

<p><strong>将主机文件复制到容器中docker cp</strong></p>
<p>docker cp 主机文件 容器名称:文件路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制</span></span><br><span class="line">docker <span class="built_in">cp</span> hello.html nginx-detached:/usr/share/nginx/html/hello.html</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">docker <span class="built_in">exec</span> nginx-detached <span class="built_in">cat</span> /usr/share/nginx/html/hello.html</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028161558592.png" alt="image-20251028161558592"></p>
<p><strong>将容器文件复制到主机中</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制</span></span><br><span class="line">docker <span class="built_in">cp</span> nginx-detached:/etc/nginx/nginx.conf ~/project/nginx.conf</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028162031628.png" alt="image-20251028162031628"></p>
<h3 id="3-7-在容器中设置环境变量"><a href="#3-7-在容器中设置环境变量" class="headerlink" title="3.7 在容器中设置环境变量"></a>3.7 在容器中设置环境变量</h3><p>环境变量是配置在容器中运行的应用程序的关键方法。</p>
<p><strong>运行一个带有环境变量的新容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name env-test -e MY_VAR=<span class="string">&quot;Hello, Environment&quot;</span> -d ubuntu <span class="built_in">sleep</span> infinity</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此命令执行以下操作：</p>
<ul>
<li><code>--name env-test</code>：将容器命名为“env-test”</li>
<li><code>-e MY_VAR=&quot;Hello, Environment&quot;</code>：设置名为 MY_VAR 的环境变量</li>
<li><code>-d</code>：以分离模式运行容器</li>
<li><code>ubuntu</code>：使用 Ubuntu 映像</li>
<li><code>sleep infinity</code>：使容器无限期运行</li>
<li><strong><code>sleep infinity</code></strong> — 保持容器运行<ul>
<li>让容器持续运行而不会立即退出</li>
<li><code>sleep infinity</code> 意为无限休眠</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>验证环境变量是否已设置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> env-test <span class="built_in">env</span> | grep MY_VAR</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028163213470.png" alt="image-20251028163213470"></p>
<p><strong>使用文件设置环境变量</strong></p>
<p>创建文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano env_file</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">ANOTHER_VAR=From a file</span><br><span class="line">YET_ANOTHER_VAR=Also from the file</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用文件启动容器，设置环境变量</span></span><br><span class="line">docker run --name env-file-test --env-file env_file -d ubuntu <span class="built_in">sleep</span> infinity</span><br><span class="line"><span class="comment"># 验证环境变量</span></span><br><span class="line">docker <span class="built_in">exec</span> env-file-test <span class="built_in">env</span> | grep -E <span class="string">&quot;ANOTHER_VAR|YET_ANOTHER_VAR&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028163508567.png" alt="image-20251028163508567"></p>
<h3 id="3-8-限制容器资源"><a href="#3-8-限制容器资源" class="headerlink" title="3.8 限制容器资源"></a>3.8 限制容器资源</h3><p>Docker 允许您限制容器可以使用的资源（CPU 和内存）。这对于管理多容器环境中的资源分配至关重要。</p>
<p><strong>启动一个具有内存和 CPU 限制的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name limited-nginx -d --memory=512m --cpus=0.5 nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此命令执行以下操作：</p>
<ul>
<li><code>--name limited-nginx</code>：将容器命名为“limited-nginx”</li>
<li><code>-d</code>：以分离模式运行容器</li>
<li><code>--memory=512m</code>：将容器限制为 512 兆字节的内存</li>
<li><code>--cpus=0.5</code>：限制容器最多使用一半的 CPU 内核</li>
<li><code>nginx</code>：使用 Nginx 镜像</li>
</ul>
</blockquote>
<p><strong>验证限制</strong></p>
<p>使用inspect验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.HostConfig.Memory&#125;&#125;&#x27;</span> limited-nginx</span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.HostConfig.NanoCpus&#125;&#125;&#x27;</span> limited-nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251028164024253.png" alt="image-20251028164024253"></p>
<p><strong>⭐要实时查看这些限制如何影响容器，可以使用以下命令stats：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats limited-nginx</span><br></pre></td></tr></table></figure>

<p>这将显示资源使用情况统计信息的实时流。</p>
<p><img src="/./imgs/image-20251028164138880.png" alt="image-20251028164138880"></p>
<h2 id="四、Docker-Run命令参数"><a href="#四、Docker-Run命令参数" class="headerlink" title="四、Docker Run命令参数"></a>四、Docker Run命令参数</h2><h3 id="4-1-容器命名–name"><a href="#4-1-容器命名–name" class="headerlink" title="4.1 容器命名–name"></a>4.1 容器命名–name</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my-nginx nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251103201338333.png" alt="image-20251103201338333"></p>
<h3 id="4-2-端口映射-p"><a href="#4-2-端口映射-p" class="headerlink" title="4.2 端口映射 -p"></a>4.2 端口映射 -p</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-mapped -p 8080:80 nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>-p 8080:80</code>：这会将主机上的端口 8080 映射到容器中的端口 80。格式始终为 .<code>host_port:container_port</code></li>
</ul>
</blockquote>
<p><img src="/./imgs/image-20251103201900491.png" alt="image-20251103201900491"></p>
<p><img src="/./imgs/image-20251103202012499.png" alt="image-20251103202012499"></p>
<h3 id="4-3-卷挂载-投放自定义页面-v"><a href="#4-3-卷挂载-投放自定义页面-v" class="headerlink" title="4.3 卷挂载(投放自定义页面) -v"></a>4.3 卷挂载(投放自定义页面) -v</h3><p>参数 -v 允许我们挂载卷，在主机和容器之间共享数据。这对于持久化数据或向容器提供配置文件非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-volume -p 8081:80 -v ~/project/nginx-data:/usr/share/nginx/html nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-v会将目录<code>nginx-data</code>从主机挂载到容器中的<code>/usr/share/nginx/html</code>目录。这是 Nginx 寻找要服务的内容的地方。</p>
</blockquote>
<p><img src="/./imgs/image-20251103202408031.png" alt="image-20251103202408031"></p>
<p>这种将主机目录挂载到容器的方法称为<strong>绑定挂载</strong>。这是在主机和容器之间共享文件的一种简单方法。以下是需要记住的几个关键点：</p>
<ol>
<li>主机目录路径必须是绝对路径。</li>
<li>如果主机目录不存在，Docker 将自动创建它。</li>
<li>对此目录（主机或容器中）中的文件所做的任何更改都将立即对主机和容器可见。</li>
<li>小心权限：默认情况下，容器以 root 身份运行，这可能会创建主机用户无法修改的文件。</li>
</ol>
<h3 id="4-4-环境变量-e"><a href="#4-4-环境变量-e" class="headerlink" title="4.4 环境变量 -e"></a>4.4 环境变量 -e</h3><p>docker允许我们在容器中设置环境变量。这对于配置在容器中运行的应用程序而不更改其代码非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-env -e NGINX_HOST=mywebsite.com -e NGINX_PORT=80 nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-e NGINX_HOST=mywebsite.com</code>：这将设置一个名为<code>NGINX_HOST</code>的环境变量 。另一个同理</p>
</blockquote>
<p><img src="/./imgs/image-20251103203049474.png" alt="image-20251103203049474"></p>
<p>环境变量是容器内运行的进程可以访问的键值对。许多 Docker 镜像设计为使用特定的环境变量进行配置。</p>
<h3 id="4-5-资源限制"><a href="#4-5-资源限制" class="headerlink" title="4.5 资源限制"></a>4.5 资源限制</h3><p>Docker 允许您使用中的各种参数对容器设置资源约束。这对于管理主机系统的性能和稳定性至关重要，尤其是在运行多个容器时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-limited --memory 256m --cpus 0.5 nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>--memory 256m</code>：这将容器限制为 256 兆字节的内存。“m”代表兆字节。您也可以使用“g”表示千兆字节。</li>
<li><code>--cpus 0.5</code>：这限制容器最多使用一半的 CPU 内核。</li>
</ul>
</blockquote>
<p><img src="/./imgs/image-20251103203832562.png" alt="image-20251103203832562"></p>
<blockquote>
<p>第一个命令应输出（256MB 字节），第二个命令应输出（0.5 CPU 纳米单位）。</p>
</blockquote>
<p>注意：将资源限制设置得太低可能会导致容器性能不佳，甚至崩溃。如果容器出现问题，请尝试提高这些限制。</p>
<h3 id="4-6-网络设置–network"><a href="#4-6-网络设置–network" class="headerlink" title="4.6 网络设置–network"></a>4.6 网络设置–network</h3><p>docker中的参数允许您将容器连接到网络。这对于容器到容器通信以及隔离容器组非常有用。</p>
<p>创建一个自定义桥接网络，桥接网络是 Docker 中最常见的网络类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-custom-network</span><br></pre></td></tr></table></figure>

<p>通过–network连接到上面创建的网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-networked --network my-custom-network nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251104092826499.png" alt="image-20251104092826499"></p>
<p>同一网络上的容器可以使用其容器名称作为主机名相互通信。这使得将服务链接在一起变得容易。</p>
<h3 id="4-7-重启策略–restart"><a href="#4-7-重启策略–restart" class="headerlink" title="4.7 重启策略–restart"></a>4.7 重启策略–restart</h3><p>docker中的参数允许您为容器指定重启策略。这对于确保容器保持运行非常有用，即使它们崩溃或 Docker 守护进程重新启动也是如此。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-restart --restart unless-stopped nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–restart该选项将重启策略设置为“unless-stopped”，这意味着容器将自动重启，除非用户显式停止。</p>
<p>其他重启策略包括：</p>
<ul>
<li><code>no</code>：默认值。不要自动重启容器。</li>
<li><code>on-failure</code>：仅当容器以非零状态退出时才重新启动。</li>
<li><code>always</code>：无论退出状态如何，始终重新启动容器。</li>
</ul>
</blockquote>
<p><img src="/./imgs/image-20251104094514809.png" alt="image-20251104094514809"></p>
<h3 id="4-8-工作目录和命令-w"><a href="#4-8-工作目录和命令-w" class="headerlink" title="4.8 工作目录和命令-w"></a>4.8 工作目录和命令-w</h3><p>-w可以在容器内设置工作目录并在容器启动时运行自定义命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx-custom -w /app nginx sh -c &quot;mkdir -p /app &amp;&amp; touch newfile.txt &amp;&amp; nginx -g &#x27;daemon off;&#x27;&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分解一下这个命令：</p>
<ul>
<li><code>-d</code>：在分离模式下运行容器（在后台）。</li>
<li><code>-w /app</code>：将容器内的工作目录设置为 。<code>/app</code></li>
<li><code>sh -c &quot;...&quot;</code>：运行 shell 命令。<ul>
<li><code>mkdir -p /app</code>：如果目录不存在，则创建该目录。<code>/app</code></li>
<li><code>touch newfile.txt</code>：创建一个名为 的空文件。<code>newfile.txt</code></li>
<li><code>nginx -g &#39;daemon off;&#39;</code>：在前台启动 Nginx，保持容器运行。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/./imgs/image-20251104095016953.png" alt="image-20251104095016953"></p>
<h2 id="五、自定义Docker镜像"><a href="#五、自定义Docker镜像" class="headerlink" title="五、自定义Docker镜像"></a>五、自定义Docker镜像</h2><h3 id="5-1-创建简单的docker镜像"><a href="#5-1-创建简单的docker镜像" class="headerlink" title="5.1 创建简单的docker镜像"></a>5.1 创建简单的docker镜像</h3><p>创建文件dockerfile并添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">COPY index.html /usr/share/nginx/html/</span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build -t my-nginx .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>了解 Dockerfile：<br>①FROM nginx：此行指定我们从中构建的基础镜像。在本例中，我们使用的是官方 Nginx 镜像。<br>②COPY index.html &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;：这一行将我们的index.html文件复制到容器的 Web 根目录中。</p>
</blockquote>
<p><img src="/./imgs/image-20251104150157904.png" alt="image-20251104150157904"></p>
<p>通过docker images可以看见创建好的镜像my-nginx</p>
<h3 id="5-2-运行和测试自定义映像"><a href="#5-2-运行和测试自定义映像" class="headerlink" title="5.2 运行和测试自定义映像"></a>5.2 运行和测试自定义映像</h3><p>启动自定义镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 --name my-nginx-container my-nginx</span><br><span class="line"><span class="comment"># 验证是否运行</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看网页内容</span></span><br><span class="line">curl http://localhost:8080</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251104151828197.png" alt="image-20251104151828197"></p>
<h3 id="5-3-将自定义软件添加到镜像"><a href="#5-3-将自定义软件添加到镜像" class="headerlink" title="5.3 将自定义软件添加到镜像"></a>5.3 将自定义软件添加到镜像</h3><p>修改dockerfile，比如添加curl：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl</span><br><span class="line">COPY index.html /usr/share/nginx/html/</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>RUN apt-get update &amp;&amp; apt-get install -y curl</code>：此行更新包列表 ，然后安装 curl 。-y在安装过程中自动回答任何提示“是”。</p>
</blockquote>
<p>重构镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-nginx-curl</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251104152550777.png" alt="image-20251104152550777"></p>
<h3 id="5-4-使用curl测试自定义镜像"><a href="#5-4-使用curl测试自定义镜像" class="headerlink" title="5.4 使用curl测试自定义镜像"></a>5.4 使用curl测试自定义镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行容器并测试程序</span></span><br><span class="line">docker run -d --name curl-container my-nginx-curl</span><br><span class="line"><span class="comment"># 打开容器交互界面</span></span><br><span class="line">docker <span class="built_in">exec</span> -it curl-container bash</span><br><span class="line"><span class="comment"># 进行curl测试</span></span><br><span class="line">curl http://localhost</span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251104152856925.png" alt="image-20251104152856925"></p>
<h3 id="5-6-在镜像中使用环境变量"><a href="#5-6-在镜像中使用环境变量" class="headerlink" title="5.6 在镜像中使用环境变量"></a>5.6 在镜像中使用环境变量</h3><p>修改dockerfile添加上环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">ENV NGINX_PORT 9000</span><br><span class="line">RUN sed -i <span class="string">&quot;s/listen[[:space:]]*80;/listen <span class="variable">$NGINX_PORT</span>;/g&quot;</span> /etc/nginx/conf.d/default.conf</span><br><span class="line">COPY index.html /usr/share/nginx/html/</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>ENV NGINX_PORT 9000</code>：这将设置一个值为 .<code>NGINX_PORT``9000</code></li>
<li><code>RUN sed -i &quot;s/listen[[:space:]]*80;/listen $NGINX_PORT;/g&quot; /etc/nginx/conf.d/default.conf</code>：这用于将默认端口 （80） 替换为 Nginx 配置文件中的环境变量。<code>sed</code></li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重建镜像</span></span><br><span class="line">docker build -t my-nginx-env .</span><br><span class="line"><span class="comment"># 运行容器并测试</span></span><br><span class="line">docker run -d -p 9000:9000 --name env-container my-nginx-env</span><br><span class="line">curl http://localhost:9000</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251104153620282.png" alt="image-20251104153620282"></p>
<h3 id="5-7-在-Dockerfile-中使用-ENTRYPOINT"><a href="#5-7-在-Dockerfile-中使用-ENTRYPOINT" class="headerlink" title="5.7 在 Dockerfile 中使用 ENTRYPOINT"></a>5.7 在 Dockerfile 中使用 ENTRYPOINT</h3><p>在 Dockerfile 中使用 ENTRYPOINT 指令并使用不同的端口 （9100）。</p>
<p>修改dockerfile</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">COPY index.html /usr/share/nginx/html/</span><br><span class="line">COPY start.sh /start.sh</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /start.sh</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/start.sh&quot;</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此 Dockerfile 删除环境变量和命令。相反，我们将使用脚本在运行时处理配置。这使得我们的形象更加灵活。</p>
</blockquote>
<p>同时在本地目录，创建start.sh脚本，进行端口配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set a default port <span class="keyword">if</span> NGINX_PORT is not <span class="built_in">set</span></span></span><br><span class="line">export NGINX_PORT=$&#123;NGINX_PORT:-9100&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replace the port <span class="keyword">in</span> the nginx configuration</span></span><br><span class="line">sed -i &quot;s/listen[[:space:]]*80;/listen $NGINX_PORT;/g&quot; /etc/nginx/conf.d/default.conf</span><br><span class="line">echo &quot;Starting Nginx on port $NGINX_PORT&quot;</span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此脚本设置默认端口，在容器启动时修改 Nginx 配置，打印一条消息，显示 Nginx 将在哪个端口上运行，然后启动 Nginx。</p>
</blockquote>
<p>重构镜像并运行容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重构</span></span><br><span class="line">docker build -t my-nginx-entrypoint .</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">docker run -d -p 9100:9100 -e NGINX_PORT=9100 --name entrypoint-container my-nginx-entrypoint</span><br><span class="line"><span class="comment"># 检查日志</span></span><br><span class="line">docker logs entrypoint-container</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">curl http://localhost:9100</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251104161325724.png" alt="image-20251104161325724"></p>
<p>可以看到运行容器同时执行了sh脚本修改了端口号</p>
<h2 id="六、Dockerfile进阶"><a href="#六、Dockerfile进阶" class="headerlink" title="六、Dockerfile进阶"></a>六、Dockerfile进阶</h2><h3 id="6-1-了解Dockerfile"><a href="#6-1-了解Dockerfile" class="headerlink" title="6.1 了解Dockerfile"></a>6.1 了解Dockerfile</h3><p>案例:使用flask为Python web构建镜像</p>
<p>准备工作</p>
<p>创建app.py</p>
<p><img src="/./imgs/image-20251105084736459.png" alt="image-20251105084736459"></p>
<p>创建依赖文件requirements.txt</p>
<p><img src="/./imgs/image-20251105084808964.png" alt="image-20251105084808964"></p>
<p><strong>创建对应的Dockerfile</strong></p>
<p><img src="/./imgs/image-20251105085245102.png" alt="image-20251105085245102"></p>
<blockquote>
<ul>
<li><code>FROM python:3.9-slim</code>：这始终是第一个指令。它指定了我们从中构建的基础映像。这将创建映像的第一层，其中包括 Python 运行时。</li>
<li><code>WORKDIR /app</code>：这将为后续指令设置工作目录。它不会创建新图层，但会影响遵循说明的行为方式。</li>
<li><code>ENV ENVIRONMENT=production</code>：这将设置一个环境变量。环境变量不会创建新层，但它们存储在图像元数据中。</li>
<li><code>COPY requirements.txt .</code>：这会将需求文件从主机复制到映像中。这将创建一个仅包含此文件的新图层。</li>
<li><code>RUN pip install --no-cache-dir -r requirements.txt</code>：这会在生成过程中在容器中运行命令。它安装我们的 Python 依赖项。这将创建一个包含所有已安装包的新层。</li>
<li><code>COPY app.py .</code>：这会将我们的应用程序代码复制到映像中，从而创建另一层。</li>
<li><code>CMD [&quot;python&quot;, &quot;app.py&quot;]</code>：指定容器启动时要运行的命令。它不会创建图层，但会设置容器的默认命令。</li>
<li><code>EXPOSE 5000</code>：这实际上只是一种文档形式。它告诉 Docker 容器将在运行时侦听此端口，但实际上不会发布该端口。它不会创建图层。</li>
<li><code>LABEL ...</code>：这些将元数据添加到图像中。与 ENV 指令一样，它们不会创建新层，而是存储在图像元数据中。</li>
</ul>
</blockquote>
<p>Dockerfile 中的每个RUN、COPY和ADD指令都会创建一个新层。层是 Docker 中的一个基本概念，允许高效存储和传输图像。当您对 Dockerfile 进行更改并重新构建映像时，Docker 将重用未更改的缓存层，从而加快构建过程。</p>
<p><strong>构建镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t advanced-flask-app .</span><br></pre></td></tr></table></figure>

<p>docker build会寻找Dockerfile构建一个新的 Docker 镜像，可以看见每个步骤如何对应于 Dockerfile 中的指令，以及 Docker 如何提及“使用缓存”，以表示在多次运行生成命令时未更改的步骤。</p>
<p><strong>运行容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --name flask-container advanced-flask-app</span><br><span class="line"><span class="comment"># 查看运行容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">curl http://localhost:5000</span><br><span class="line"><span class="comment"># 查询故障日志</span></span><br><span class="line">docker logs flask-container</span><br></pre></td></tr></table></figure>

<p><strong>遇到问题</strong></p>
<p>docker run后docker ps无法查看到容器状态</p>
<p>原因</p>
<p>app.py运行出现问题直接导致容器exit</p>
<p>app.py缩进问题要注意</p>
<p>解决后截图：</p>
<p><img src="/./imgs/image-20251105100054046.png" alt="image-20251105100054046"></p>
<h3 id="6-2-多阶段构建"><a href="#6-2-多阶段构建" class="headerlink" title="6.2 多阶段构建"></a>6.2 多阶段构建</h3><p>多阶段构建允许您在 Dockerfile 中使用多个 FROM 语句。</p>
<p>修改Dockerfile添加多个FROM</p>
<p><img src="/./imgs/image-20251105091505414.png" alt="image-20251105091505414"></p>
<blockquote>
<ol>
<li>我们从一个阶段开始：<code>builder</code><ul>
<li>我们使用 Python 3.9-slim 镜像作为基础，从一开始就保持小。</li>
<li>我们在此阶段使用 安装 Python 依赖项。这会在用户的主目录中安装包。<code>pip install --user</code></li>
</ul>
</li>
<li>然后我们进入最后阶段：<ul>
<li>我们从另一个 Python 3.9 超薄映像重新开始。</li>
<li>我们只从舞台复制已安装的包，特别是从放置它们的位置复制。<code>builder``/root/.local``pip install --user</code></li>
<li>我们复制我们的应用程序代码。</li>
<li>我们将本地 bin 目录添加到 PATH 中，以便 Python 可以找到已安装的软件包。</li>
<li>我们像以前一样设置了容器的其余部分（ENV、CMD、EXPOSE、LABEL）。</li>
</ul>
</li>
</ol>
</blockquote>
<p>这里的主要优点是，我们的最终映像不包含任何来自 pip 安装过程的构建工具或缓存。它只包含最终的、必要的工件。这应该会导致图像变小。</p>
<p><strong>构建并比较</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t multi-stage-flask-app .</span><br><span class="line"><span class="comment"># 比较</span></span><br><span class="line">docker images | grep flask-app</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251105175815421.png" alt="image-20251105175815421"></p>
<p>可以发现多阶段构建的镜像要更小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行</span></span><br><span class="line">docker run -d -p 5001:5000 --name multi-stage-container multi-stage-flask-app</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">curl http://localhost:5001</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251105180130727.png" alt="image-20251105180130727"></p>
<p>了解单级和多级镜像之间区别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> advanced-flask-app</span><br><span class="line">docker <span class="built_in">history</span> multi-stage-flask-app</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251105180739126.png" alt="image-20251105180739126"></p>
<p>多阶段构建是创建高效 Docker 镜像的强大技术。它们允许您在构建过程中使用工具和文件，而不会使最终镜像膨胀。这对于具有复杂构建过程的编译语言或应用程序特别有用。</p>
<h3 id="6-3-dockerignore文件"><a href="#6-3-dockerignore文件" class="headerlink" title="6.3 .dockerignore文件"></a>6.3 .dockerignore文件</h3><p>构建 Docker 镜像时，Docker 会将目录中的所有文件发送到 Docker 守护进程。如果您有构建映像不需要的大文件，这可能会减慢构建过程。.dockerignore文件允许您指定在构建 Docker 映像时应排除的文件和目录。</p>
<p>比如：创建advanced-dockerfile.dockerignore</p>
<p><img src="/./imgs/image-20251106193751035.png" alt="image-20251106193751035"></p>
<blockquote>
<ul>
<li><code>**/.git</code>：忽略 .git 目录及其所有内容，无论它出现在目录结构中的哪个位置。</li>
<li><code>**/.gitignore</code>：忽略 .gitignore 文件。</li>
<li><code>**/__pycache__</code>：忽略 Python 的缓存目录。</li>
<li><code>**/*.pyc</code>， ， ： 忽略编译的 Python 文件。<code>**/*.pyo``**/*.pyd</code></li>
<li><code>**/.Python</code>：忽视。Python 文件（通常由虚拟环境创建）。</li>
<li><code>**/env</code>， ， ： 忽略虚拟环境目录。<code>**/venv``**/ENV</code></li>
<li><code>**/env.bak</code>， ：忽略虚拟环境目录的备份副本。<code>**/venv.bak</code></li>
</ul>
</blockquote>
<p>模拟环境：</p>
<p><img src="/./imgs/image-20251106194553633.png" alt="image-20251106194553633"></p>
<p>构建镜像会发现并没有考虑上面的这些文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建</span></span><br><span class="line">docker build -t ignored-flask-app .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证忽略文件</span></span><br><span class="line">docker history ignored-flask-app</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251106195019806.png" alt="image-20251106195019806"></p>
<h3 id="6-4-高阶Dockerfile"><a href="#6-4-高阶Dockerfile" class="headerlink" title="6.4 高阶Dockerfile"></a>6.4 高阶Dockerfile</h3><p>主要了解其中的USER、ENTRYPOINT、HEALTHCHECK 和 ARG 等附加指令（RUN CMD等都需要了解）</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ===== 构建阶段 =====</span></span><br><span class="line"><span class="comment"># 使用官方 Python 3.9 精简版镜像作为构建基础</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="comment"># 在构建阶段安装所有依赖包到用户本地目录（--user）</span></span><br><span class="line"><span class="comment"># --no-cache-dir 避免缓存占用空间</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --user --no-cache-dir -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 最终阶段（运行时镜像）=====</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 安全性配置 ---</span></span><br><span class="line"><span class="comment"># 创建非 root 用户，提升容器安全性</span></span><br><span class="line"><span class="comment"># -m 标志为用户创建主目录 /home/appuser</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m appuser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 curl 工具（用于健康检查）</span></span><br><span class="line"><span class="comment"># 同时清理 apt 缓存以减小镜像体积</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- Python 环境配置 ---</span></span><br><span class="line"><span class="comment"># 动态检测 Python 版本（3.9），并计算 site-packages 路径</span></span><br><span class="line"><span class="comment"># 为 appuser 创建该路径，并设置正确的目录权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> PYTHON_VERSION=$(python -c <span class="string">&#x27;import sys; print(f&quot;&#123;sys.version_info.major&#125;.&#123;sys.version_info.minor&#125;&quot;)&#x27;</span>) &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    SITE_PACKAGES_PATH=<span class="string">&quot;/home/appuser/.local/lib/python<span class="variable">$&#123;PYTHON_VERSION&#125;</span>/site-packages&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;SITE_PACKAGES_PATH&#125;</span>&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chown</span> -R appuser:appuser /home/appuser/.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 从构建阶段复制依赖 ---</span></span><br><span class="line"><span class="comment"># 将第一阶段安装的 Python 包复制到最终镜像中的正确位置</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /root/.local/lib/python3.9/site-packages <span class="string">&quot;<span class="variable">$&#123;SITE_PACKAGES_PATH&#125;</span>&quot;</span></span></span><br><span class="line"><span class="comment"># 将构建阶段生成的可执行脚本（如 pip、flask 等）复制过来</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /root/.local/bin /home/appuser/.local/bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制应用程序代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 环境变量设置 ---</span></span><br><span class="line"><span class="comment"># 将用户本地 bin 目录加入 PATH，使得可执行脚本可被直接调用</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=/home/appuser/.local/bin:$PATH</span><br><span class="line"><span class="comment"># 标识当前运行环境为生产环境</span></span><br><span class="line"><span class="keyword">ENV</span> ENVIRONMENT=production</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 权限与执行配置 ---</span></span><br><span class="line"><span class="comment"># 切换到非 root 用户运行容器（安全最佳实践）</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动命令</span></span><br><span class="line"><span class="comment"># ENTRYPOINT 定义主程序：python</span></span><br><span class="line"><span class="comment"># CMD 提供默认参数：app.py</span></span><br><span class="line"><span class="comment"># 用户可直接运行容器执行 app.py，也可覆盖 CMD 运行其他脚本</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;app.py&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 网络与监控 ---</span></span><br><span class="line"><span class="comment"># 暴露应用程序监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置容器健康检查</span></span><br><span class="line"><span class="comment"># 每 30 秒检查一次，单次检查超时时间 3 秒</span></span><br><span class="line"><span class="comment"># 通过 curl 访问本地 5000 端口的根路径</span></span><br><span class="line"><span class="comment"># 若访问失败（非 200 响应），容器被标记为不健康</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=30s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost:5000/ || <span class="built_in">exit</span> 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 元数据标签 ---</span></span><br><span class="line"><span class="comment"># 构建参数：允许构建时通过 --build-arg BUILD_VERSION=x.x 传入</span></span><br><span class="line"><span class="keyword">ARG</span> BUILD_VERSION</span><br><span class="line"><span class="comment"># 设置镜像标签信息，便于版本管理和文档</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Your Name &lt;your.email@example.com&gt;&quot;</span></span></span><br><span class="line"><span class="comment"># 版本号：使用传入的参数，默认为 1.0</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;<span class="variable">$&#123;BUILD_VERSION:-1.0&#125;</span>&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;Flask app demo with advanced Dockerfile techniques&quot;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Dockerfile 中的几个关键概念说明如下：</p>
<p><strong>用户管理与安全</strong></p>
<p><code>RUN useradd -m appuser</code> 在容器中创建一个名为 <code>appuser</code> 的新用户。其中 <code>-m</code> 标志会为该用户创建主目录。以非 root 用户身份运行应用程序是一项安全最佳实践，能够限制应用程序被入侵时的潜在风险。</p>
<p><strong>依赖安装与镜像优化</strong></p>
<p><code>RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</code> 安装 curl 包（这是 HEALTHCHECK 指令所需的工具），并清理 apt 缓存以减小镜像体积。</p>
<p><strong>Python 环境配置</strong></p>
<p><code>RUN PYTHON_VERSION=$(python -c &#39;import sys; print(f&quot;&#123;sys.version_info.major&#125;.&#123;sys.version_info.minor&#125;&quot;)&#39;) &amp;&amp; ...</code> 动态检测容器中的 Python 版本，据此配置 <code>site-packages</code> 路径，并为 <code>appuser</code> 用户的本地目录设置适当的权限。</p>
<p><strong>包和脚本复制</strong></p>
<p><code>COPY --from=builder /root/.local/lib/python3.9/site-packages &quot;$&#123;SITE_PACKAGES_PATH&#125;&quot;</code> 从构建阶段将已安装的 Python 包复制到最终镜像的动态确定路径，确保 <code>appuser</code> 用户能够正确访问。</p>
<p><code>COPY --from=builder /root/.local/bin /home/appuser/.local/bin</code> 将构建阶段生成的可执行脚本（如 pip 工具或 Flask CLI）复制到 <code>appuser</code> 的本地 bin 目录。</p>
<p><strong>容器启动配置</strong></p>
<p><code>ENTRYPOINT [&quot;python&quot;]</code> 与 <code>CMD [&quot;app.py&quot;]</code> 配合使用，定义容器的主可执行文件为 python，默认参数为 app.py。这种模式提供了灵活性：用户可以直接运行容器执行 app.py，也可以覆盖 CMD 来运行其他 Python 脚本或命令。</p>
<p><strong>健康检查</strong></p>
<p><code>HEALTHCHECK</code> 指令配置容器的运行状况检查。Docker 会定期执行指定命令（如 <code>curl -f http://localhost:5000/</code>）以判断容器是否正常运行。<code>--interval=30s</code> 和 <code>--timeout=3s</code> 分别设定检查间隔和超时时间。若命令返回非零退出码，容器被标记为不健康。</p>
<p><strong>构建参数与标签</strong></p>
<p><code>ARG BUILD_VERSION</code> 定义一个构建参数，允许在构建时向 Docker 镜像传入值。</p>
<p><code>LABEL version=&quot;$&#123;BUILD_VERSION:-1.0&#125;&quot;</code> 在镜像上设置一个版本标签，引用 BUILD_VERSION 参数。若构建时指定了该参数，则使用其值；否则默认为 1.0（使用 <code>:-</code> 语法实现默认值）。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建</span></span><br><span class="line">docker build -t advanced-flask-app-v2 --build-arg BUILD_VERSION=2.0 .</span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">docker images | grep advanced-flask-app-v2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–build-arg允许我们在镜像构建过程中传递构建参数的值。</p>
<p><code>BUILD_VERSION=2.0</code>此值将用于在 Docker 映像中设置标签</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行</span></span><br><span class="line">docker run -d -p 5002:5000 --name advanced-container-v2 advanced-flask-app-v2</span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">docker ps | grep advanced-container-v2</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251106200149908.png" alt="image-20251106200149908"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查其日志是否有错误</span></span><br><span class="line">docker logs advanced-container-v2</span><br><span class="line"><span class="comment"># 检查它的健康状态</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.State.Health.Status&#125;&#125;&#x27;</span> advanced-container-v2</span><br><span class="line"><span class="comment"># 验证构建版本标签是否已正确应用</span></span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.Config.Labels.version&#125;&#125;&#x27;</span> advanced-flask-app-v2</span><br><span class="line"><span class="comment"># 发送请求验证</span></span><br><span class="line">curl http://localhost:5002</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251106200308552.png" alt="image-20251106200308552"></p>
<p>如何编写dockerfile参考练习从基础知识到多阶段构建</p>
<h2 id="七、Docker网络基础知识"><a href="#七、Docker网络基础知识" class="headerlink" title="七、Docker网络基础知识"></a>七、Docker网络基础知识</h2><h3 id="7-1-网络类型"><a href="#7-1-网络类型" class="headerlink" title="7.1 网络类型"></a>7.1 网络类型</h3><p>Docker 提供了几个内置的网络驱动程序。</p>
<p>在终端中，运行以下命令以列出所有可用的 Docker 网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251106232732347.png" alt="image-20251106232732347"></p>
<blockquote>
<p><strong><code>bridge</code></strong>：Docker 的默认网络驱动程序。当容器启动时如果未指定网络，会自动连接到桥接网络。同一桥接网络中的容器可以通过 IP 地址互相通信。</p>
<p><strong><code>host</code></strong>：此驱动程序让容器直接共享主机的网络命名空间，消除了容器与主机之间的网络隔离。容器会直接使用主机的 IP 地址和端口。这在某些需要性能优化的场景中特别有用。</p>
<p><strong><code>none</code></strong>：此驱动程序完全禁用容器的网络功能。使用此驱动程序的容器无法连接外部网络，也无法与其他容器通信。当需要对容器进行完全隔离时可以使用。</p>
</blockquote>
<h3 id="7-2-默认桥接网络"><a href="#7-2-默认桥接网络" class="headerlink" title="7.2 默认桥接网络"></a>7.2 默认桥接网络</h3><h4 id="检查桥接网络"><a href="#检查桥接网络" class="headerlink" title="检查桥接网络"></a>检查桥接网络</h4><p>运行以下命令检查网桥网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure>

<p>此命令提供有关桥接网络的详细信息，包括其子网、网关和连接的容器。</p>
<p><img src="/./imgs/image-20251106233129603.png" alt="image-20251106233129603"></p>
<blockquote>
<p>Subnet：网络中分配给容器的子网段为 172.17.0.0&#x2F;16。容器将从这个 IP 地址范围内获得 IP 地址。<br>Gateway：网络的网关地址为 172.17.0.1。容器通过这个网关 IP 地址与外部网络通信。<br>Containers：此字段为空，说明目前还没有容器连接到这个网络。<br>Options：这些是桥接网络的配置参数。例如，enable_icc 设置为 true 时，表示允许该网络中的容器相互通信。</p>
</blockquote>
<p>在解决网络问题或需要配置容器以与特定 IP 范围通信时，了解此信息至关重要。</p>
<h4 id="创建自定义桥接网络"><a href="#创建自定义桥接网络" class="headerlink" title="创建自定义桥接网络"></a>创建自定义桥接网络</h4><p>虽然默认桥接网络能满足大多数使用场景，但创建自定义网络能提供更好的隔离性和可控性。当需要将相关容器组织在一起，或对容器间的通信权限进行精细控制时，自定义网络就显得尤为重要。</p>
<p>案例：</p>
<p><strong>创建一个名为my-network的网络</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge my-network</span><br></pre></td></tr></table></figure>

<p>此命令将创建一个新的桥接网络。虽然 <code>--driver bridge</code> 选项是可选的（因为桥接驱动程序是默认值），但为了代码的可读性，通常会明确指定。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span> <span class="comment"># 查看网络</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251106233628072.png" alt="image-20251106233628072"></p>
<h3 id="7-3-将docker容器连接到网络"><a href="#7-3-将docker容器连接到网络" class="headerlink" title="7.3 将docker容器连接到网络"></a>7.3 将docker容器连接到网络</h3><p>现在有了自定义网络，创建两个容器并将它们连接到它。</p>
<h4 id="使用选项–network来指定容器连接到哪个网络"><a href="#使用选项–network来指定容器连接到哪个网络" class="headerlink" title="使用选项–network来指定容器连接到哪个网络"></a><strong>使用选项–network来指定容器连接到哪个网络</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建容器并指定网络</span></span><br><span class="line">docker run -d --name container1 --network my-network nginx</span><br><span class="line">docker run -d --name container2 --network my-network nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251106233914347.png" alt="image-20251106233914347"></p>
<h4 id="测试容器之间的通信"><a href="#测试容器之间的通信" class="headerlink" title="测试容器之间的通信"></a><strong>测试容器之间的通信</strong></h4><p>Docker 网络的主要优势之一是同一网络上的容器可以使用其<strong>容器名称作为主机名相互通信</strong>。这使得在服务之间设置通信变得容易，而无需知道它们的 IP 地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送请求 容器1请求容器2</span></span><br><span class="line">docker <span class="built_in">exec</span> container1 curl -s container2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>docker exec</code></strong>：在运行中的容器内执行命令。</p>
<p><strong><code>container1</code></strong>：目标容器的名称，即要执行命令的容器。</p>
<p><strong><code>curl -s container2</code></strong>：在容器内执行的命令。向 <code>container2</code> 发送 GET 请求，其中 <code>-s</code> 标志表示以静默模式运行 curl（不输出进度信息）。</p>
</blockquote>
<p><img src="/./imgs/image-20251106234310154.png" alt="image-20251106234310154"></p>
<p>这个成功的响应表明容器可以通过容器名称进行通信。Docker 的内置 DNS 服务器会将容器名称解析为其在网络中对应的 IP 地址。</p>
<h3 id="7-4-公开容器端口"><a href="#7-4-公开容器端口" class="headerlink" title="7.4 公开容器端口"></a>7.4 公开容器端口</h3><p>默认情况下，自定义网络中的容器可以互相通信，但外部无法访问它们。要使容器能从主机或外部网络访问，需要公开其端口。</p>
<p>创建一个具有公开端口的新容器示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name exposed-container -p 8080:80 --network my-network nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>-d</code></strong>：以分离模式运行容器（后台运行）。</p>
<p><strong><code>--name exposed-container</code></strong>：将容器命名为 <code>exposed-container</code>。</p>
<p><strong><code>-p 8080:80</code></strong>：将容器内的端口 80 映射到主机的端口 8080。</p>
<p><strong><code>--network my-network</code></strong>：将容器连接到自定义网络 <code>my-network</code>。</p>
<p><strong><code>nginx</code></strong>：使用 Nginx 镜像。</p>
</blockquote>
<p>此命令创建一个名为 <code>exposed-container</code> 的容器，将其内部端口 80 映射到主机端口 8080，并将其连接到 <code>my-network</code> 网络。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line">curl localhost:8080</span><br></pre></td></tr></table></figure>

<p>可以通过打开 Web 浏览器并导航到localhost:8080或使用 curl 从主机访问此容器的 Nginx 服务器</p>
<p><img src="/./imgs/image-20251107000105106.png" alt="image-20251107000105106"></p>
<h3 id="7-5-使用主机网络（host）"><a href="#7-5-使用主机网络（host）" class="headerlink" title="7.5 使用主机网络（host）"></a>7.5 使用主机网络（host）</h3><p>对于需要容器共享主机网络堆栈的场景，可以使用主机网络驱动程序。这种方式消除了容器与主机之间的网络隔离，适合某些特定应用，但由于可能产生端口冲突，应谨慎使用。</p>
<p>下面使用主机网络创建一个容器示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name host-networked --network host nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此命令创建一个使用主机网络的新容器，命名为 <code>host-networked</code>。注意，<code>-p</code> 选项不能与主机网络驱动程序一起使用，因为容器已直接使用主机的网络接口。</p>
</blockquote>
<p>验证容器是否使用主机（host）网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.HostConfig.NetworkMode&#125;&#125;&#x27;</span> host-networked</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107000339309.png" alt="image-20251107000339309"></p>
<p>使用主机网络时，容器共享主机的 IP 地址，可以直接访问主机的所有网络接口。这对性能优化很有帮助，但同时也意味着容器占用的任何端口都会直接在主机上打开，容易产生端口冲突。</p>
<h2 id="八、深入了解Docker网络"><a href="#八、深入了解Docker网络" class="headerlink" title="八、深入了解Docker网络"></a>八、深入了解Docker网络</h2><h3 id="8-1-自定义桥接网络"><a href="#8-1-自定义桥接网络" class="headerlink" title="8.1 自定义桥接网络"></a>8.1 自定义桥接网络</h3><p>过程类似7.2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建自定义桥接网络</span></span><br><span class="line">docker network create my-custom-bridge</span><br><span class="line"><span class="comment"># 查看网络情况</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 运行指定自定义网络的nginx容器</span></span><br><span class="line">docker run --network=my-custom-bridge --name container1 -d nginx</span><br><span class="line">docker run --network=my-custom-bridge --name container2 -d nginx</span><br><span class="line"><span class="comment"># 在容器中安装ping服务</span></span><br><span class="line">docker <span class="built_in">exec</span> container1 apt-get update &amp;&amp; docker <span class="built_in">exec</span> container1 apt-get install -y iputils-ping</span><br><span class="line">docker <span class="built_in">exec</span> container2 apt-get update &amp;&amp; docker <span class="built_in">exec</span> container2 apt-get install -y iputils-ping</span><br><span class="line"><span class="comment"># 检查容器之间的通信</span></span><br><span class="line">docker <span class="built_in">exec</span> container1 ping -c 4 container2</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107085107492.png" alt="image-20251107085107492"></p>
<p><img src="/./imgs/image-20251107085121473.png" alt="image-20251107085121473"></p>
<p><strong>删除网络</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 断开网络连接后或者无网络连接可进行删除</span></span><br><span class="line">docker network <span class="built_in">rm</span> 网络名称</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107095602348.png" alt="image-20251107095602348"></p>
<h3 id="8-2-跨网络容器连接"><a href="#8-2-跨网络容器连接" class="headerlink" title="8.2 跨网络容器连接"></a>8.2 跨网络容器连接</h3><p>Docker 允许容器连接到多个网络，从而实现不同网络上容器之间的通信。当需要隔离某些容器，但仍允许它们之间进行特定通信时，这种方式特别有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建自定义网络</span></span><br><span class="line">docker network create my-second-bridge</span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107085308101.png" alt="image-20251107085308101"></p>
<p><strong>连接到新网络⭐</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-second-bridge container2</span><br></pre></td></tr></table></figure>

<p>此命令将 <code>container2</code> 添加到 <code>my-second-bridge</code> 网络，同时<strong>保持</strong>其与 <code>my-custom-bridge</code> 网络的连接。</p>
<p>在第二个网络新建容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --network=my-second-bridge --name container3 -d nginx</span><br><span class="line">docker <span class="built_in">exec</span> container3 apt-get update &amp;&amp; docker <span class="built_in">exec</span> container3 apt-get install -y iputils-ping</span><br></pre></td></tr></table></figure>

<p><strong>测试所有容器之间的通信</strong></p>
<p><img src="/./imgs/image-20251107085630354.png" alt="image-20251107085630354"></p>
<p>可以发现</p>
<ul>
<li><code>container1</code> 可以与 <code>container2</code> 通信（两者在同一网络上）。</li>
<li><code>container1</code> 无法与 <code>container3</code> 通信（两者位于不同网络上）。</li>
<li><code>container2</code> 可以与 <code>container1</code> 和 <code>container3</code> 通信（它连接到两个网络）。</li>
</ul>
<p><strong>断开网络连接</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect 网络 容器</span><br></pre></td></tr></table></figure>

<h3 id="8-3-主机（host）网络模式"><a href="#8-3-主机（host）网络模式" class="headerlink" title="8.3 主机（host）网络模式"></a>8.3 主机（host）网络模式</h3><p>主机网络模式消除了容器与 Docker 主机之间的网络隔离，允许容器直接使用主机的网络。这对性能优化很有帮助，但会降低容器的隔离性，存在安全风险。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用主机网络创建容器</span></span><br><span class="line">docker run --network host --name host-container -d nginx</span><br><span class="line"><span class="comment"># 验证 ls不会看到此容器的新网络，因为它直接使用主机的网络</span></span><br><span class="line">docker network <span class="built_in">ls</span> </span><br><span class="line"><span class="comment"># 验证容器正在使用主机的网络</span></span><br><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;.HostConfig.NetworkMode&#125;&#125;&#x27;</span> host-container</span><br><span class="line"><span class="comment"># 访问页面</span></span><br><span class="line">curl localhost:80</span><br></pre></td></tr></table></figure>

<p>应该会看到 Nginx 欢迎页面。这之所以有效，是因为容器使用了主机的网络，Nginx 直接监听主机网络接口的端口 80。</p>
<p>**注意：**如果主机的端口 80 上已有其他服务运行，此步骤可能会失败。此时需要先停止该服务。</p>
<h3 id="8-4-无网络（none）模式"><a href="#8-4-无网络（none）模式" class="headerlink" title="8.4 无网络（none）模式"></a>8.4 无网络（none）模式</h3><p>“无”网络模式创建没有网络接口的容器，将其与网络完全隔离。这对于实现最大程度的<strong>安全隔离</strong>很有用，但意味着容器完全<strong>无法进行网络通信</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建没有网络的容器</span></span><br><span class="line">docker run --network none --name isolated-container -d alpine <span class="built_in">sleep</span> infinity</span><br><span class="line"><span class="comment"># 验证当前网络列表</span></span><br><span class="line">docker network <span class="built_in">ls</span> </span><br></pre></td></tr></table></figure>

<p>不会看到此容器的新网络，因为它未连接到任何网络</p>
<p><img src="/./imgs/image-20251107091425391.png" alt="image-20251107091425391"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证容器是否没有网络接口</span></span><br><span class="line">docker <span class="built_in">exec</span> isolated-container ip addr</span><br><span class="line"><span class="comment"># 尝试从隔离容器中 ping Google</span></span><br><span class="line">docker <span class="built_in">exec</span> isolated-container ping -c 2 google.com</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107091523126.png" alt="image-20251107091523126"></p>
<p>因为是无网络所以只看到环回接口 （lo），不会有任何 eth0 或其他网络接口。</p>
<h3 id="8-5-网络别名和服务发现"><a href="#8-5-网络别名和服务发现" class="headerlink" title="8.5 网络别名和服务发现"></a>8.5 网络别名和服务发现</h3><p>Docker 网络支持通过网络别名进行服务发现，这对构建弹性、可扩展的应用程序很有帮助。此功能允许多个容器响应同一个 DNS 名称，从而实现基本的负载均衡。</p>
<p>案例：</p>
<p><strong>构建桥接网络</strong>并验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create service-network</span><br><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107092004449.png" alt="image-20251107092004449"></p>
<p>创建两个具有<strong>相同网络别名的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network service-network --network-alias myservice --name service1 nginx</span><br><span class="line">docker run -d --network service-network --network-alias myservice --name service2 nginx</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107092218938.png" alt="image-20251107092218938"></p>
<p>创建一个<strong>客户端</strong>容器用于<strong>解析服务</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --network service-network appropriate/curl nslookup myservice</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>--rm</code></strong>：容器退出后自动删除，不保留容器。</p>
<p><strong><code>--network service-network</code></strong>：将容器连接到 <code>service-network</code> 网络。</p>
<p><strong><code>appropriate/curl</code></strong>：使用的镜像，包含 curl 和 nslookup 工具。</p>
<p><strong><code>nslookup myservice</code></strong>：在容器内执行的命令，用于查询 DNS 以解析 <code>myservice</code> 的 IP 地址。</p>
</blockquote>
<p>会看到返回两个容器的 IP 地址，这表明 Docker 的内置 DNS 服务器正在这两个容器之间进行<strong>负载均衡</strong>。</p>
<p><img src="/./imgs/image-20251107092511520.png" alt="image-20251107092511520"></p>
<p>多次测试访问服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..4&#125;; <span class="keyword">do</span> docker run --<span class="built_in">rm</span> --network service-network appropriate/curl ping -c 1 myservice; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107092711164.png" alt="image-20251107092711164"></p>
<p>应该会看到来自两个容器的响应，演示基本的<strong>负载均衡</strong>。Docker 的 DNS 服务器在解析 <code>myservice</code> 时会在两个 IP 地址之间<strong>轮流切换</strong>。</p>
<p>注意：了解负载均衡，参考nginx中讲解的负载均衡</p>
<h3 id="网络小结"><a href="#网络小结" class="headerlink" title="网络小结"></a>网络小结</h3><p>Docker 的高级网络功能为多容器应用程序提供了强大的工具，可精确控制容器间的通信和隔离。掌握这些概念对设计高效、安全和可扩展的容器化应用至关重要。</p>
<p>在设计容器网络架构时，应重视安全考虑，遵循最小权限原则，仅公开必要的端口和服务。这些网络概念在编排复杂应用和微服务架构中极具价值。</p>
<h2 id="九、Docker-卷管理"><a href="#九、Docker-卷管理" class="headerlink" title="九、Docker 卷管理"></a>九、Docker 卷管理</h2><h3 id="9-1-Docker存储选项"><a href="#9-1-Docker存储选项" class="headerlink" title="9.1 Docker存储选项"></a>9.1 Docker存储选项</h3><p>Docker 主要提供三种数据存储机制：</p>
<ol>
<li><strong>卷</strong>：在 Docker 中持久化数据的首选机制。</li>
<li><strong>绑定挂载</strong>：将主机的特定路径直接连接到容器。</li>
<li><strong>tmpfs 挂载</strong>：将数据临时存储在主机内存中。</li>
</ol>
<p>其中卷是 Docker 中管理数据最灵活、最推荐的选项。</p>
<p><strong>列出系统上的当前卷</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107131245481.png" alt="image-20251107131245481"></p>
<p>此命令列出系统上所有的 Docker 卷。输出显示卷驱动程序（通常为”local”）和卷名称。根据是否已创建卷，输出可能显示现有卷列表，或为空。</p>
<h3 id="9-2-创建和管理命名卷"><a href="#9-2-创建和管理命名卷" class="headerlink" title="9.2 创建和管理命名卷"></a>9.2 创建和管理命名卷</h3><p>命名卷是显式创建并指定特定名称的卷。这种方式便于后续引用和管理。</p>
<p><strong>创建卷</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_data</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107131445885.png" alt="image-20251107131445885"></p>
<p>docker volume create的卷数据存储在主机系统上，通常位于 <code>/var/lib/docker/volumes/</code> 目录</p>
<p><strong>获取卷的详细信息inspect</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my_data</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107131600479.png" alt="image-20251107131600479"></p>
<blockquote>
<p>此输出显示卷的以下信息：</p>
<ul>
<li><strong>创建时间</strong>：卷创建的时间戳。</li>
<li><strong>驱动程序</strong>：卷使用的存储驱动程序（本例中为 local）。</li>
<li><strong>挂载点</strong>：卷在主机系统上的实际存储位置。</li>
<li><strong>卷名</strong>：指定给卷的名称。</li>
</ul>
</blockquote>
<h3 id="9-3-将卷与容器一起使用"><a href="#9-3-将卷与容器一起使用" class="headerlink" title="9.3 将卷与容器一起使用"></a>9.3 将卷与容器一起使用</h3><p>现在我们已创建了卷，接下来将其与容器一起使用。</p>
<p><strong>启动一个新容器并将卷挂载到它</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container -v mu_data:/app/data ubuntu:latest <span class="built_in">sleep</span> infinity</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker run：运行一个新容器。<br>-d：以分离模式（后台）运行容器。<br>–name my_container：为容器指定名称，便于后续引用。<br>-v my_data:&#x2F;app&#x2F;data：将卷 my_data 挂载到容器内的 &#x2F;app&#x2F;data 目录。<br>ubuntu:latest：容器使用的镜像。<br>sleep infinity：容器运行的命令，使容器持续运行。</p>
</blockquote>
<p><img src="/./imgs/image-20251107132431804.png" alt="image-20251107132431804"></p>
<p><strong>在卷中创建数据并验证</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试数据</span></span><br><span class="line">docker <span class="built_in">exec</span> my_container sh -c <span class="string">&quot;echo &#x27;Hello from Docker volume&#x27; &gt; /app/data/test.txt&quot;</span></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line">docker <span class="built_in">exec</span> my_container <span class="built_in">cat</span> /app/data/test.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>docker exec</code></strong>：在运行中的容器内执行命令。</p>
<p><strong><code>my_container</code></strong>：目标容器的名称。</p>
<p><strong><code>sh -c &quot;...&quot;</code></strong>：在容器内运行 shell 命令。</p>
<p><strong>实际命令</strong>：在卷中创建名为 <code>test.txt</code> 的文件，内容为 “Hello from Docker 卷”。</p>
</blockquote>
<p><img src="/./imgs/image-20251107132333480.png" alt="image-20251107132333480"></p>
<h3 id="9-4-容器之间共享数据"><a href="#9-4-容器之间共享数据" class="headerlink" title="9.4 容器之间共享数据"></a>9.4 容器之间共享数据</h3><p>Docker 卷的一大好处是能够在容器之间共享数据。</p>
<p>例如</p>
<p><strong>创建另一个使用相同卷的容器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name another_container -v my_data:/app/shared_data ubuntu:latest <span class="built_in">sleep</span> infinity</span><br></pre></td></tr></table></figure>

<p>此命令与之前的命令类似，但指定了不同的容器名称，并<strong>将卷挂载到容器内的不同路径</strong>。</p>
<p><img src="/./imgs/image-20251107132707944.png" alt="image-20251107132707944"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证卷中数据</span></span><br><span class="line">docker <span class="built_in">exec</span> another_container <span class="built_in">cat</span> /app/shared_data/test.txt</span><br></pre></td></tr></table></figure>

<p>应该会看到之前写入的”来自 Docker 卷的问候”消息。这表明两个容器访问的是同一个卷中的数据。</p>
<p><strong>添加更多数据验证</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第二个容器添加</span></span><br><span class="line">docker <span class="built_in">exec</span> another_container sh -c <span class="string">&quot;echo &#x27;Data from another container&#x27; &gt;&gt; /app/shared_data/test.txt&quot;</span></span><br><span class="line"><span class="comment"># 第一个容器验证</span></span><br><span class="line">docker <span class="built_in">exec</span> my_container <span class="built_in">cat</span> /app/data/test.txt</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107133053117.png" alt="image-20251107133053117"></p>
<p>可以发现两个容器都共享同一个卷。</p>
<h3 id="9-5-卷的备份和恢复"><a href="#9-5-卷的备份和恢复" class="headerlink" title="9.5 卷的备份和恢复"></a>9.5 卷的备份和恢复</h3><p>备份和恢复 Docker 卷对于数据保护至关重要。</p>
<p>以下是这个过程的步骤：</p>
<p>首先，需要停止并删除使用该卷的容器。这是因为 Docker 不允许删除正在被使用的卷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop my_container another_container</span><br><span class="line">docker <span class="built_in">rm</span> my_container another_container</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107133314843.png" alt="image-20251107133314843"></p>
<p><strong>创建卷的备份</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v my_data:/source:ro -v $(<span class="built_in">pwd</span>):/backup ubuntu tar cvf /backup/my_data_backup.tar -C /source .</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>docker run --rm</code></strong>：运行临时容器，完成后自动删除。</p>
<p><strong><code>-v my_data:/source:ro</code></strong>：以只读模式将卷 <code>my_data</code> 挂载到容器的 <code>/source</code> 目录。</p>
<p><strong><code>-v $(pwd):/backup</code></strong>：将当前主机目录挂载到容器的 <code>/backup</code> 目录。</p>
<p><strong><code>ubuntu</code></strong>：使用 Ubuntu 镜像。</p>
<p><strong><code>tar cvf /backup/my_data_backup.tar -C /source .</code></strong>：创建卷数据的 tar 归档文件。</p>
</blockquote>
<p><img src="/./imgs/image-20251107133727565.png" alt="image-20251107133727565"></p>
<p>可以看见挂载了本地目录到容器的backup后，进行备份，会直接传输到本地</p>
<p><strong>删除初始卷</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> my_data</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107133842673.png" alt="image-20251107133842673"></p>
<p><strong>恢复数据</strong></p>
<p>创建一个新卷并将备份解压到其中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新卷</span></span><br><span class="line">docker volume create my_restored_data</span><br><span class="line"><span class="comment"># 解压备份到新卷中</span></span><br><span class="line">docker run --<span class="built_in">rm</span> -v my_restored_data:/dest -v $(<span class="built_in">pwd</span>):/backup ubuntu bash -c <span class="string">&quot;tar xvf /backup/my_data_backup.tar -C /dest&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107134340725.png" alt="image-20251107134340725"></p>
<p><img src="/./imgs/image-20251107134347715.png" alt="image-20251107134347715"></p>
<p>检验数据是否恢复</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -v my_restored_data:/app/data ubuntu <span class="built_in">cat</span> /app/data/test.txt</span><br></pre></td></tr></table></figure>

<p><img src="/./imgs/image-20251107134406413.png" alt="image-20251107134406413"></p>
<p><strong>关键要点</strong></p>
<ul>
<li>Docker 卷是管理容器持久化数据的灵活高效方式。</li>
<li>可通过 Docker CLI 命令轻松创建、检查和删除卷。</li>
<li>卷数据可在多个容器之间共享。</li>
<li>备份和恢复卷对数据保护至关重要，可使用标准 Linux 命令实现。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Docker 基础概念</strong></p>
<ul>
<li><strong>容器</strong>：轻量级、独立可执行的包，包含运行软件所需的一切</li>
<li><strong>镜像</strong>：容器的模板或蓝图，包含创建容器所需的所有说明</li>
<li><strong>Docker Hub</strong>：Docker 镜像的中央仓库，用于存储和共享镜像</li>
<li><strong>Docker 引擎</strong>：在机器上运行和管理容器的核心技术</li>
</ul>
<p><strong>镜像管理</strong></p>
<ul>
<li>从 Docker Hub 拉取、本地查看、删除镜像</li>
<li>理解镜像分层结构及其优化作用</li>
<li>创建并标记自定义镜像，支持版本控制和环境隔离</li>
</ul>
<p><strong>容器运行</strong></p>
<ul>
<li>支持分离模式（后台运行）和交互模式（前台交互）</li>
<li>管理容器生命周期：启动、停止、重启、删除</li>
<li>通过 exec 在运行中的容器内执行命令</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li><strong>卷</strong>：首选机制，适合容器间共享和数据备份</li>
<li><strong>绑定挂载</strong>：将主机目录直接连接到容器</li>
<li><strong>tmpfs 挂载</strong>：临时存储在主机内存中</li>
</ul>
<p><strong>网络管理</strong></p>
<ul>
<li>三种网络模式：bridge（默认）、host（共享主机网络）、none（完全隔离）</li>
<li>自定义桥接网络实现容器隔离与精细控制</li>
<li>容器可通过容器名称进行 DNS 解析和通信</li>
<li>网络别名实现基本的负载均衡</li>
</ul>
<p><strong>Dockerfile 与镜像构建</strong></p>
<ul>
<li>关键指令：FROM、RUN、COPY、CMD、ENTRYPOINT、ENV、LABEL、HEALTHCHECK</li>
<li>多阶段构建优化镜像大小，仅包含必要文件</li>
<li>.dockerignore 文件排除构建时不需要的文件</li>
</ul>
<p><strong>运行参数</strong></p>
<ul>
<li><code>-p</code>：端口映射；<code>-v</code>：卷挂载；<code>-e</code>：环境变量</li>
<li><code>--memory</code>、<code>--cpus</code>：资源限制</li>
<li><code>--network</code>：网络配置；<code>--restart</code>：重启策略</li>
<li><code>-w</code>：工作目录；<code>--name</code>：容器命名</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Felix</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/10/28/docker/">http://example.com/2025/10/28/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/imgs/adater.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/10/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/" title="正则表达式和文本三剑客"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">正则表达式和文本三剑客</div></div><div class="info-2"><div class="info-item-1">正则表达式和文本三剑客一、正则表达式基础1.1 正则表达式概念正则表达式是一种强大的文本模式匹配工具，用来描述、匹配和查找符合某种规则的文本内容。 重要概念：  正则表达式用于模式匹配和文本搜索 不同工具支持的正则表达式语法有所差异 基础正则表达式（BRE）和扩展正则表达式（ERE）   ⚠️ 重要区别：正则表达式的元字符与 Shell 通配符不同  通配符：用于文件名匹配（*、?、[]） 元字符：用于文本内容匹配（在 grep、sed、awk 中使用）   1.2 基础正则表达式元字符（BRE）   元字符 含义 示例 匹配情况    . 匹配任意单个字符（除换行符） g.d god、gad、g3d   * 匹配前面的子表达式 0 次或多次 go*d gd、god、gooood   ^ 匹配行的开始 ^root 行首为 root   $ 匹配行的结束 bash$ 行尾为 bash   [] 字符集，匹配其中任意一个字符 [abc] a、b 或 c   [^] 否定字符集，匹配不在其中的字符 [^abc] 除 a、b、c 外的字符   \ 转义符，使特殊字符失去特殊含义 \. 实...</div></div></div></a><a class="pagination-related" href="/2025/10/24/SSH%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="SSH相关知识"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">SSH相关知识</div></div><div class="info-2"><div class="info-item-1">SSH相关知识一、DNS1.1 DNS是什么？什么作用？DNS（Domain Name System）是互联网的一项服务，它作用于OSI七层模型的第7层（L7应用层）。DNS的核心功能是将域名解析为IP地址（翻译官），使用户可以通过易记的域名访问网络资源。 1.2 DNS记录类型—面试问① A记录（主机记录）将域名解析为IP地址 例如：example.com → 192.168.110.140 ② P记录（指针记录）反向解析IP到域名，将IP地址转换回对应的域名 例如：192.168.110.140 → example.com 1.3 DNS解析配置   配置文件 位置 主要用途 优先级    &#x2F;etc&#x2F;hosts 本地主机文件 内部IP-主机名&#x2F;域名映射 最高   &#x2F;etc&#x2F;resolv.conf DNS解析配置 指定DNS服务器地址 中   &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 网卡配置 网卡级别DNS配置 中   ① &#x2F;etc&...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/imgs/adater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Felix</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/falsezxy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Docker"><span class="toc-number">1.1.</span> <span class="toc-text">一、初识Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%8F%AF%E7%94%A8%E9%95%9C%E5%83%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 查看本地可用镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Docker-Hub"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Docker Hub</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.</span> <span class="toc-text">二、使用docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%8EDocker-Hub%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 从Docker Hub拉取镜像并使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BB%8EDocker-Hub%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">①从Docker Hub拉取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E4%B8%8B%E8%BD%BD%E6%88%90%E5%8A%9F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">②检查是否下载成功</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">③运行容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%90%E8%A1%8C%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 运行不同版本的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%97%E5%87%BA%E5%92%8C%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 列出和删除镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%95%9C%E5%83%8F%E5%9B%BE%E5%B1%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 镜像图层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%9C%A8-Docker-Hub-%E4%B8%8A%E6%90%9C%E7%B4%A2%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 在 Docker Hub 上搜索镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 保存和加载镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E9%95%9C%E5%83%8F%E6%A0%87%E8%AE%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 镜像标记基础知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81docker%E8%BF%9B%E9%98%B6"><span class="toc-number">1.3.</span> <span class="toc-text">三、docker进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%A5%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 以不同模式运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 管理容器生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AFinspect"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 查看容器的详细信息inspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97logs"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 容器日志logs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%9C%A8%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4exec"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 在正在运行的容器中执行命令exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%B0%86%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%88%B0%E5%AE%B9%E5%99%A8%E6%88%96%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 将文件复制到容器或从容器复制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7 在容器中设置环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.8.</span> <span class="toc-text">3.8 限制容器资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Docker-Run%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">四、Docker Run命令参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%B9%E5%99%A8%E5%91%BD%E5%90%8D%E2%80%93name"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 容器命名–name</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84-p"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 端口映射 -p</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8D%B7%E6%8C%82%E8%BD%BD-%E6%8A%95%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2-v"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 卷挂载(投放自定义页面) -v</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-e"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 环境变量 -e</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 资源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E2%80%93network"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 网络设置–network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E2%80%93restart"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.7 重启策略–restart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E5%91%BD%E4%BB%A4-w"><span class="toc-number">1.4.8.</span> <span class="toc-text">4.8 工作目录和命令-w</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.</span> <span class="toc-text">五、自定义Docker镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84docker%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 创建简单的docker镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%BF%90%E8%A1%8C%E5%92%8C%E6%B5%8B%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%A0%E5%83%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 运行和测试自定义映像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%B0%86%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AF%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 将自定义软件添加到镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%BD%BF%E7%94%A8curl%E6%B5%8B%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 使用curl测试自定义镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%9C%A8%E9%95%9C%E5%83%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.6 在镜像中使用环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E5%9C%A8-Dockerfile-%E4%B8%AD%E4%BD%BF%E7%94%A8-ENTRYPOINT"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.7 在 Dockerfile 中使用 ENTRYPOINT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Dockerfile%E8%BF%9B%E9%98%B6"><span class="toc-number">1.6.</span> <span class="toc-text">六、Dockerfile进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BA%86%E8%A7%A3Dockerfile"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 了解Dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 多阶段构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-dockerignore%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 .dockerignore文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E9%AB%98%E9%98%B6Dockerfile"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 高阶Dockerfile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Docker%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.7.</span> <span class="toc-text">七、Docker网络基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 网络类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%BB%98%E8%AE%A4%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 默认桥接网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">检查桥接网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">创建自定义桥接网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%B0%86docker%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%BD%91%E7%BB%9C"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 将docker容器连接到网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%89%E9%A1%B9%E2%80%93network%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%93%AA%E4%B8%AA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">使用选项–network来指定容器连接到哪个网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">测试容器之间的通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%85%AC%E5%BC%80%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 公开容器端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E4%BD%BF%E7%94%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88host%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 使用主机网络（host）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Docker%E7%BD%91%E7%BB%9C"><span class="toc-number">1.8.</span> <span class="toc-text">八、深入了解Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 自定义桥接网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E8%B7%A8%E7%BD%91%E7%BB%9C%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 跨网络容器连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E4%B8%BB%E6%9C%BA%EF%BC%88host%EF%BC%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 主机（host）网络模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%97%A0%E7%BD%91%E7%BB%9C%EF%BC%88none%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 无网络（none）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E7%BD%91%E7%BB%9C%E5%88%AB%E5%90%8D%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 网络别名和服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%BB%93"><span class="toc-number">1.8.6.</span> <span class="toc-text">网络小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Docker-%E5%8D%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">九、Docker 卷管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Docker%E5%AD%98%E5%82%A8%E9%80%89%E9%A1%B9"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 Docker存储选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E5%91%BD%E5%90%8D%E5%8D%B7"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 创建和管理命名卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%B0%86%E5%8D%B7%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 将卷与容器一起使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 容器之间共享数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E5%8D%B7%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 卷的备份和恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/03/web%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/" title="Web服务和数据库">Web服务和数据库</a><time datetime="2025-11-03T10:17:19.000Z" title="Created 2025-11-03 18:17:19">2025-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/" title="正则表达式和文本三剑客">正则表达式和文本三剑客</a><time datetime="2025-10-29T01:27:22.000Z" title="Created 2025-10-29 09:27:22">2025-10-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/28/docker/" title="docker--草稿">docker--草稿</a><time datetime="2025-10-28T00:54:40.000Z" title="Created 2025-10-28 08:54:40">2025-10-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/24/SSH%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="SSH相关知识">SSH相关知识</a><time datetime="2025-10-24T12:26:06.000Z" title="Created 2025-10-24 20:26:06">2025-10-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/24/Shell%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="Shell相关知识">Shell相关知识</a><time datetime="2025-10-24T12:20:28.000Z" title="Created 2025-10-24 20:20:28">2025-10-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/imgs/background_footer.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Felix</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>