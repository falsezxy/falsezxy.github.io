<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Felix的个人博客</title><meta name="author" content="Felix"><meta name="copyright" content="Felix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Felix的个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Felix的个人博客">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/imgs/adater.jpg">
<meta property="article:author" content="Felix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/imgs/adater.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "Felix的个人博客",
  "alternateName": [
    "example.com"
  ],
  "url": "http://example.com/"
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Felix的个人博客',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'home'
}</script><meta name="generator" content="Hexo 8.0.0"></head><body><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url(/imgs/background_header.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Felix的个人博客</span></a></span><div id="menus"></div></nav><div id="site-info"><h1 id="site-title">Felix的个人博客</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts nc" id="recent-posts"><div class="recent-post-items"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/18/CI%20CD%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90Ruo-Yi%E9%A1%B9%E7%9B%AE/" title="CI/CD持续集成Ruo-Yi项目">CI/CD持续集成Ruo-Yi项目</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-18T11:27:44.000Z" title="Created 2025-12-18 19:27:44">2025-12-18</time></span></div><div class="content">CI&#x2F;CD持续集成Ruo-Yi项目CI&#x2F;CD工作原理图 部署流程一、环境准备1、主机环境123456789101112##通常情况需要准备如下服务器：192.168.118.128 K8S-master 192.168.118.129 K8S-worker01192.168.118.130 K8S-worker02 rancher 192.168.118.131 harbor192.168.118.132 gitlab（docker 部署）192.168.118.133 jenkins 部署## 节省服务器版本192.168.118.101 K8S-master  docker部署；gitlab jenkins rancher192.168.118.104 K8S-worker01 harbor192.168.118.105 K8S-worker02  K8S-master： 内存：10GB 处理器：4C 2、Jenkins工作流程 3、准备K8S集群与容器环境1234567891011121314151617181920212223242526① 搭建K8S...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/17/Kubernets-network_rbac_hpa/" title="Kubernetes 网络、RBAC 和 HPA 相关知识">Kubernetes 网络、RBAC 和 HPA 相关知识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-17T10:34:40.000Z" title="Created 2025-12-17 18:34:40">2025-12-17</time></span></div><div class="content">Kubernetes 网络、RBAC 和 HPA 相关知识一、Kubernetes 网络体系详解1.1 三层网络架构Kubernetes 集群网络由三个独立的网络层组成，每层承担不同的责任： 节点网络（Node Network） 定义：负责集群宿主机节点间的通信，并打通与集群外部的连接 IP 类型：nodeIP 实现基础：物理网卡或云网络基础设施 通信方式：通过物理网卡上的 nodeIP 实现跨主机通信 典型场景：集群内部节点相互访问、外部客户端访问集群入口  Pod 网络（Pod Network） 定义：为集群内所有 Pod 提供网络通信能力 IP 类型：podIP，全局唯一 关键特性：Pod 可以跨节点相互通信，无论它们运行在同一节点还是不同节点 实现机制：通过 CNI（Container Network Interface）网络插件实现 网络模型： Overlay（覆盖网络）：数据包经过二次封装，增加额外处理但支持跨网段 Route（路由网络）：基于路由表转发，性能更优但对网络基础设施有要求    Service 网络（Service Network） 定义：集群部署时指定...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/16/Kubernetes-Ingress%E6%9C%8D%E5%8A%A1/" title="Kubernetes-Ingress服务">Kubernetes-Ingress服务</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-16T10:12:58.000Z" title="Created 2025-12-16 18:12:58">2025-12-16</time></span></div><div class="content">Kubernetes-Ingress服务一、Ingress 概述1. 为什么需要 Ingress？K8s 内的 Pod IP 与 Service ClusterIP 仅在集群内部可见。为了让外部应用访问集群内服务，K8s 提供了多种方案： 现有方案的问题 NodePort：适合测试，但服务数量多时端口管理困难（端口范围 30000-32767，每个端口仅服务一种服务） LoadBalancer：需要云厂商支持，通常需要额外费用，仅适合公有云 externalIPs：为 service 分配外部 IP，配置相对复杂  Ingress（七层反向代理） 的优势 仅用一个或少量的公网 IP&#x2F;LB，即可同时将多个 HTTP&#x2F;HTTPS 服务暴露到外网 可理解为**”service 的 service”：基于域名&#x2F;URL 路径**将请求转发到一个或多个 service 集中管理端口，减少 K8s 对外暴露的入口数量    二、Ingress 的核心组件1. Ingress（规则定义） 以 YAML 格式定义的 API 对象 定义请求如何转发到 service 的...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/16/Kubernetes%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="Kubernetes存储管理">Kubernetes存储管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-16T01:35:04.000Z" title="Created 2025-12-16 09:35:04">2025-12-16</time></span></div><div class="content">Kubernetes 存储管理一、ConfigMap 与 Secret 配置管理1.1 ConfigMap（配置管理）概念ConfigMap 用于管理 Pod 中容器内服务的配置文件和环境变量。 适用场景 存储应用配置文件（如 Nginx.conf、数据库连接配置） 定义环境变量 非加密的配置数据  典型例子：Ruo-Yi 微服务 前端：Nginx + VUE 框架（DIST 文件） 配置文件：Nginx.conf  1.2 Secret（加密管理）概念Secret 管理 Pod 中容器的加密信息、令牌与密钥文件。 适用场景 存储加密密钥 管理用户凭证（用户名&#x2F;密码） 存储 API Token 和 Secret 密钥文件 敏感信息保护  Secret 创建方式方式一：使用 kubectl 命令创建 1kubectl create secret generic &lt;secret-name&gt; --from-file=&lt;file-path&gt;  方式二：Base64 编码后编写 YAML 12345678910111213141516# 编码敏感信息ech...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/15/Kubernetes%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" title="Kubernetes 配置资源管理">Kubernetes 配置资源管理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-15T02:54:40.000Z" title="Created 2025-12-15 10:54:40">2025-12-15</time></span></div><div class="content">Kubernetes 配置资源管理一、为什么需要 Secret 和 ConfigMap？在开发容器化应用时，我们经常面临一个问题：如何安全地管理应用配置和敏感信息？ 传统做法是把这些信息直接写入代码或镜像中，这样做有严重隐患：  敏感信息（密码、API密钥）被暴露在代码仓库中 不同环境的配置硬编码，难以维护 修改配置需要重新构建镜像，效率低下  Kubernetes 提供了 Secret 和 ConfigMap 两个资源对象来解决这些问题。  二、Secret：敏感信息的保险箱核心作用Secret 专门用于存储和管理敏感数据，让这些信息与应用代码和镜像分离。 工作中的常见用途1. 数据库连接凭证 123456789# 存储数据库用户名和密码apiVersion: v1kind: Secretmetadata:  name: db-secrettype: Opaquedata:  username: cm9vdA==        # base64编码的 &quot;root&quot;  password: aGFzaDAzMjE=    # base64编码的密码  2. 镜像...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/12/%E9%98%BF%E9%87%8C%E4%BA%91-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/" title="阿里云-设备管理平台部署">阿里云-设备管理平台部署</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-12T00:54:40.000Z" title="Created 2025-12-12 08:54:40">2025-12-12</time></span></div><div class="content">阿里云-设备管理平台部署前言本文档详细记录了基于阿里云的设备管理平台从零到一的完整部署过程，涵盖网络基础设施配置、中间件部署、计算资源管理以及高可用架构设计等核心内容。通过本文档，读者可以深入了解从传统IT架构到云计算架构的转变，以及各个云服务组件之间如何协同工作。 云平台技术映射与架构设计一、网络基础设施层1. VPC（Virtual Private Cloud - 虚拟私有云）传统IT概念对应：在企业数据中心中，我们会通过物理网络设备（交换机、路由器）隔离不同部门或项目的网络。 云平台作用：VPC是阿里云上完全隔离的虚拟网络环境。你可以在VPC中自定义IP地址范围、创建子网、配置路由规则。在本项目中，我们创建了”设备管理平台-VPC”，为所有云资源提供了一个专属的网络空间，确保不同项目之间的网络完全隔离。 实际应用：我们选择杭州地域创建VPC，使用172.16.0.0&#x2F;16作为CIDR地址块，为所有计算、存储、数据库资源提供网络基础。 2. 交换机（Subnet&#x2F;Vswitch）传统IT概念对应：物理网络中的二层交换机，用于划分局域网，让不同的设备通过子网...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/10/Kubernetes-Pod%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E6%9B%B4%E6%96%B0/" title="Kubernetes Pod的升级与更新">Kubernetes Pod的升级与更新</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-10T12:13:46.000Z" title="Created 2025-12-10 20:13:46">2025-12-10</time></span></div><div class="content">Kubernetes Pod的升级与更新一、滚动升级&#x2F;更新（Rolling Update）原理与流程滚动升级是逐步替换Pod的过程，在更新期间保持部分Pod运行，确保服务持续可用。 执行流程123456789初始状态: [Pod1:v1] [Pod2:v1] [Pod3:v1]        ↓第1步:   [Pod1:v2] [Pod2:v1] [Pod3:v1]  (停止1个旧Pod，启动1个新Pod)        ↓第2步:   [Pod1:v2] [Pod2:v2] [Pod3:v1]  (继续逐步替换)        ↓第3步:   [Pod1:v2] [Pod2:v2] [Pod3:v2]  (最后替换)        ↓完成状态: [Pod1:v2] [Pod2:v2] [Pod3:v2]  (全部更新完毕)  核心参数配置123456spec:  strategy:    type: RollingUpdate    rollingUpdate:      maxSurge: 25%          # 允许超出副本数的最大Pod数（支持百分比或具体...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/10/Kubernetes%20Controller%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kubernetes Controller 学习笔记">Kubernetes Controller 学习笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-10T10:34:40.000Z" title="Created 2025-12-10 18:34:40">2025-12-10</time></span></div><div class="content">Kubernetes Controller 学习笔记一、控制器基础概念什么是控制器控制器（又称工作负载 Workload）是Kubernetes中的中间层管理工具，通过标签选择器（label-selector）与Pod关联，实现对Pod的全生命周期管理。 核心职责：  创建和删除Pod 监听Pod运行状态 故障自动重建 支持扩容缩容 支持版本升级和回滚  控制器与Pod的关系 控制器 通过 label-selector 与 Pod 关联 Pod 通过控制器实现运维管理（伸缩、升级等）   二、常见控制器类型   控制器 用途 使用占比 核心特性    Deployment 无状态应用 60%~70% 支持滚动更新、回滚、声明式管理   StatefulSet 有状态应用 10%~20% 有序部署、稳定网络标识、专属存储   ReplicaSet 副本集管理 - 维护Pod副本数（通常由Deployment管理）   DaemonSet 守护进程 特殊场景 每个节点运行一个Pod   Job 一次性任务 测试、批处理 任务完成后退出（complete状态）   CronJob 周期...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/09/kubernetes%E9%9B%86%E7%BE%A4%E8%B0%83%E5%BA%A6%E7%AE%A1%E7%90%86/" title="Kubernetes集群调度机制">Kubernetes集群调度机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-09T08:54:40.000Z" title="Created 2025-12-09 16:54:40">2025-12-09</time></span></div><div class="content">Kubernetes 集群调度机制第一部分：调度器核心原理1.1 什么是调度器？定义： 调度器是 master 节点上的一个独立程序，负责监听 API Server 中 spec.nodeName 为空的 Pod，通过一系列算法选择最适合的节点并将 Pod 绑定到该节点。 工作模式：   持续监听 API Server（List-Watch 机制） 当发现新的 Pod 时触发调度流程 异步执行，不阻塞 API Server  关键点： 调度只是将 Pod 分配给节点（更新 spec.nodeName），实际的容器启动由 kubelet 负责。  1.2 调度过程详解（三个阶段）阶段一：Predicate（预选&#x2F;过滤）目的： 排除完全不符合条件的节点，得到候选节点列表 常见检查项（所有检查都必须通过）：    检查项 说明 例子    PodFitsResources CPU&#x2F;Memory 是否足够 节点可用 2C4G，Pod 需要 2C2G ✓   PodFitsHost 节点名是否匹配 nodeName Pod 指定 node01，只有 node01 通过 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2025/12/06/Kubernetes%20Pod%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Kubernetes Pod 学习笔记">Kubernetes Pod 学习笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">Created</span><time datetime="2025-12-06T00:54:40.000Z" title="Created 2025-12-06 08:54:40">2025-12-06</time></span></div><div class="content">Kubernetes Pod 学习笔记Pod 基础概念Pod 是 Kubernetes 中最小的调度与运行单位，是对一个或多个容器的封装。Kubernetes 直接管理的是 Pod，而不是容器。 Pod 的核心特性 共享资源  同一个 Pod 中的容器运行在同一个 Node 节点上 容器之间通过 localhost 互相通信 共享同一个 IP 地址和端口范围 共享同一个存储卷（Volume），实现容器间的数据共享   生命周期  Pod 内的容器共享生命周期 如果 Pod 被删除，容器也随之消失 Pod 是临时性的，可能被删除或重建     Pod 的三种容器类型图例： 1️⃣ Pause 容器（基础架构容器）定义：Pod 中第一个被启动的容器，也称为 Infrastructure Container、Sandbox Container 核心作用：  持有网络命名空间：为 Pod 分配 IP 地址，所有业务容器通过加入 Pause 容器的网络命名空间来共享这个 IP 生命周期管理：充当 Pod 的”父容器”，如果 Pause 容器挂了，整个 Pod 的网络环境就消失了 僵尸进程回...</div></div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/imgs/adater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Felix</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/falsezxy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/18/CI%20CD%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90Ruo-Yi%E9%A1%B9%E7%9B%AE/" title="CI/CD持续集成Ruo-Yi项目">CI/CD持续集成Ruo-Yi项目</a><time datetime="2025-12-18T11:27:44.000Z" title="Created 2025-12-18 19:27:44">2025-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/17/Kubernets-network_rbac_hpa/" title="Kubernetes 网络、RBAC 和 HPA 相关知识">Kubernetes 网络、RBAC 和 HPA 相关知识</a><time datetime="2025-12-17T10:34:40.000Z" title="Created 2025-12-17 18:34:40">2025-12-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/16/Kubernetes-Ingress%E6%9C%8D%E5%8A%A1/" title="Kubernetes-Ingress服务">Kubernetes-Ingress服务</a><time datetime="2025-12-16T10:12:58.000Z" title="Created 2025-12-16 18:12:58">2025-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/16/Kubernetes%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" title="Kubernetes存储管理">Kubernetes存储管理</a><time datetime="2025-12-16T01:35:04.000Z" title="Created 2025-12-16 09:35:04">2025-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/15/Kubernetes%20%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" title="Kubernetes 配置资源管理">Kubernetes 配置资源管理</a><time datetime="2025-12-15T02:54:40.000Z" title="Created 2025-12-15 10:54:40">2025-12-15</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>Tags</span></div><div class="card-tag-cloud"><a href="/tags/Linux%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0yum%E4%BB%93%E5%BA%93%E2%80%94%E2%80%94-%E8%BF%81%E7%A7%BB%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E5%88%B0%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93%E7%AD%89/" style="font-size: 1.1em; color: #999">Linux创建本地yum仓库——>迁移知识点，到企业服务器仓库等</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8C%81%E7%BB%AD%E7%A7%AF%E7%B4%AF%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/" style="font-size: 1.1em; color: #999">学习过程中持续积累的面试题</a> <a href="/tags/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E9%83%A8%E5%88%86Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" style="font-size: 1.1em; color: #999">简单介绍部分Linux常见命令</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>Archives</span>
      
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/12/">
            <span class="card-archive-list-date">
              December 2025
            </span>
            <span class="card-archive-list-count">14</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/11/">
            <span class="card-archive-list-date">
              November 2025
            </span>
            <span class="card-archive-list-count">15</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/10/">
            <span class="card-archive-list-date">
              October 2025
            </span>
            <span class="card-archive-list-count">12</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>Website Info</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">Article Count :</div><div class="item-count">41</div></div><div class="webinfo-item"><div class="item-name">Unique Visitors :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Page Views :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">Last Update :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-12-19T00:37:58.944Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/imgs/background_footer.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Felix</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.1"></script><script src="/js/main.js?v=5.5.1"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: str => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: subtitleType => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        btf.getScript('https://cdn.jsdelivr.net/npm/typed.js@2.1.0/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  },
  processSubtitle: (content, extraContents = []) => {
    if (true) {
      const sub = ["任凭风吹雨打，我自闲庭信步"].slice()

      if (extraContents.length > 0) {
        sub.unshift(...extraContents)
      }

      if (typeof content === 'string') {
        sub.unshift(content)
      } else if (Array.isArray(content)) {
        sub.unshift(...content)
      }

      sub.length > 0 && typedJSFn.init(sub)
    } else {
      document.getElementById('subtitle').textContent = typeof content === 'string' ? content :
        (Array.isArray(content) && content.length > 0 ? content[0] : '')
    }
  }
}
btf.addGlobalFn('pjaxSendOnce', () => { typed.destroy() }, 'typedDestroy')
</script><script>function subtitleType () {
  typedJSFn.processSubtitle(["任凭风吹雨打，我自闲庭信步"])
}
typedJSFn.run(subtitleType)</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>